<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>面试算法复盘</title>
    <url>/posts/426545e2.html</url>
    <content><![CDATA[<p>面试算法都很简单，感觉准备的太多了，面试的时候疯狂引导面试官多问我算法，因为别的也不太会。</p>
<a id="more"></a>
<p>二分、快排</p>
<p>二叉树最大深度：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> l = dfs(root-&gt;left);</span><br><span class="line">  <span class="keyword">int</span> r = dfs(root-&gt;right);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">max</span>(l, r) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字符串最长无重复字符字串长度：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>(), i=<span class="number">0</span>, j=<span class="number">0</span>, res=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; vis;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n &amp;&amp; j&lt;n)&#123;</span><br><span class="line">            vis[s[i]]++, i++;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;i &amp;&amp; vis[s[i<span class="number">-1</span>]] &gt; <span class="number">1</span>) vis[s[j]]--, j++;</span><br><span class="line">            res = <span class="built_in">max</span>(res, i-j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>手写最小堆：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> heap[<span class="number">1000010</span>];</span><br><span class="line"><span class="keyword">int</span> n, sz=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x / <span class="number">2</span> &amp;&amp; heap[x] &lt; heap[x / <span class="number">2</span>]) &#123;</span><br><span class="line">        swap(heap[x], heap[x / <span class="number">2</span>]);</span><br><span class="line">        x /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = x;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span> * x &lt;= sz &amp;&amp; heap[<span class="number">2</span> * x] &lt; heap[t]) t = <span class="number">2</span> * x;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span> * x + <span class="number">1</span> &lt;= sz &amp;&amp; heap[<span class="number">2</span> * x + <span class="number">1</span>] &lt; heap[t]) t = <span class="number">2</span> * x + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(x != t) &#123;</span><br><span class="line">        swap(heap[x], heap[t]);</span><br><span class="line">        down(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    heap[++sz] = x;</span><br><span class="line">    up(sz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    heap[<span class="number">1</span>] = heap[sz--];</span><br><span class="line">    down(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span>(n) &#123;</span><br><span class="line">        <span class="keyword">int</span> op;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;op);</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>) &#123; <span class="comment">// 插入</span></span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">            push(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,heap[<span class="number">1</span>]); <span class="comment">//打印堆中最小值</span></span><br><span class="line">        <span class="keyword">else</span> pop(); <span class="comment">// 删除最小值</span></span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>面试算法</category>
      </categories>
      <tags>
        <tag>面试算法</tag>
      </tags>
  </entry>
  <entry>
    <title>dp困难专题</title>
    <url>/posts/c4165ded.html</url>
    <content><![CDATA[<h1 id="leetcode-1411-给-N-x-3-网格图涂色的方案数"><a href="#leetcode-1411-给-N-x-3-网格图涂色的方案数" class="headerlink" title="leetcode 1411. 给 N x 3 网格图涂色的方案数"></a>leetcode 1411. 给 N x 3 网格图涂色的方案数</h1><p>你有一个 $n * 3$ 的网格图 $grid$ ，你需要用 红，黄，绿 三种颜色之一给每一个格子上色，且确保相邻格子颜色不同（也就是有相同水平边或者垂直边的格子颜色不同）。给你网格图的行数 $n$ 请你返回给 $grid$ 涂色的方案数。由于答案可能会非常大，请你返回答案对 $10^9 + 7$ 取余的结果。</p><a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：n = <span class="number">1</span></span><br><span class="line">输出：<span class="number">12</span></span><br><span class="line">解释：总共有 <span class="number">12</span> 种可行的方法：</span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：n = <span class="number">2</span></span><br><span class="line">输出：<span class="number">54</span></span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：n = <span class="number">3</span></span><br><span class="line">输出：<span class="number">246</span></span><br><span class="line">示例 <span class="number">4</span>：</span><br><span class="line"></span><br><span class="line">输入：n = <span class="number">7</span></span><br><span class="line">输出：<span class="number">106494</span></span><br><span class="line">示例 <span class="number">5</span>：</span><br><span class="line"></span><br><span class="line">输入：n = <span class="number">5000</span></span><br><span class="line">输出：<span class="number">30228214</span></span><br></pre></td></tr></table></figure>
<p>提示：</p>
<ol>
<li>$n == grid.length$</li>
<li>$grid[i].length == 3$</li>
<li>$1 &lt;= n &lt;= 5000$</li>
</ol>
<ul>
<li>来源：力扣（LeetCode）</li>
<li>链接：<a href="https://leetcode-cn.com/problems/number-of-ways-to-paint-n-3-grid" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-ways-to-paint-n-3-grid</a></li>
</ul>
<p>思路：状态表示：$f[i][j]$ 表示第 $i$ 行以 $j$ 涂色的方案数，那么第一个问题就是涂色怎么表示呢？将红黄绿看成是 $012_3$ ，所以我们可以用一个三进制数去表示这一行的涂色情况。<br>答案：$\sum_{i=1}^T(f[n][i])$, $T$ 是只有一行的总涂色数<br>状态转移：$f[i][j] += f[i-1][k]$ 既将与上一行涂色情况不冲突的所有方案数累加即可。<br>预处理：只有一行时，将合法的方案用一个数组types存起来,然后将所有不冲突的行的涂色情况用legal数组标记出来。</p>
<ul>
<li>时间复杂度：$O(T^2 * n)$</li>
<li>空间复杂度：$O(T^2 + n * T)$<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numOfWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; types;</span><br><span class="line">        <span class="comment">//求出第一行所有涂色方案表示</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">3</span>;k++)</span><br><span class="line">                    <span class="keyword">if</span>(i != j &amp;&amp; j != k) types.push_back(<span class="number">9</span> * i + <span class="number">3</span> * j + k);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> t = types.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; legal(t, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(t));</span><br><span class="line">        <span class="comment">//标记所有不冲突的上下行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x1 = types[i] / <span class="number">9</span>, x2 = types[i] / <span class="number">3</span> % <span class="number">3</span>, x3 = types[i] % <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;t;j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> y1 = types[j] / <span class="number">9</span>, y2 = types[j] / <span class="number">3</span> % <span class="number">3</span>, y3 = types[j] % <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">if</span>(x1 != y1 &amp;&amp; x2 != y2 &amp;&amp; x3 != y3) legal[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; (t));</span><br><span class="line">        <span class="comment">//初始化，第一行所有涂色方案数都为1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t;i++) f[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;t;j++) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;t;k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(legal[k][j]) f[i][j] = (f[i][j] + f[i<span class="number">-1</span>][k]) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t;i++) res = (res + f[n][i]) % mod;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="leetcode-1278-分割回文串-III"><a href="#leetcode-1278-分割回文串-III" class="headerlink" title="leetcode 1278. 分割回文串 III"></a>leetcode 1278. 分割回文串 III</h1><p>给你一个由小写字母组成的字符串 $s$ ，和一个整数 $k$ 。<br>请你按下面的要求分割字符串：<br>首先，你可以将 $s$ 中的部分字符修改为其他的小写英文字母。<br>接着，你需要把 $s$ 分割成 $k$ 个非空且不相交的子串，并且每个子串都是回文串。<br>请返回以这种方式分割字符串所需修改的最少字符数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"abc"</span>, k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：你可以把字符串分割成 <span class="string">"ab"</span> 和 <span class="string">"c"</span>，并修改 <span class="string">"ab"</span> 中的 <span class="number">1</span> 个字符，将它变成回文串。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"aabbc"</span>, k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：你可以把字符串分割成 <span class="string">"aa"</span>、<span class="string">"bb"</span> 和 <span class="string">"c"</span>，它们都是回文串。</span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"leetcode"</span>, k = <span class="number">8</span></span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li>$1 &lt;= k &lt;= s.length &lt;= 100$</li>
<li>$s 中只含有小写英文字母。$</li>
</ul>
<p>思路：<br>状态定义：$f[i][j]$表示将s前i个字符分成j部分每个子串都是回文串的最少修改次数<br>答案：$f[n-1][k]$<br>状态转移：$f[i][j] = min(f[i][j], f[k][j-1] + g[k+1][j])$<br>即每次将$k+1\sim i$ 这一段当成最后一段，找出所有情况中的最佳划分即可<br>$g[i][j]$ 表示将 $i\sim j$ 变成回文串的最小修改次数</p>
<ul>
<li>时间复杂度：$O(n^2*k)$</li>
<li>空间复杂度：$O(n^2 + n * k)$<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">palindromePartition</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//g[i][j]表示将i~j变成回文串的最小修改次数</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; g(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>;len&lt;=n;len++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+len<span class="number">-1</span>&lt;n;i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == s[j]) g[i][j] = g[i+<span class="number">1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span> g[i][j] = g[i+<span class="number">1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(k + <span class="number">1</span>, <span class="number">0x3f3f3f3f</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) f[i][<span class="number">1</span>] = g[<span class="number">0</span>][i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=k;j++) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">0</span>;p&lt;i;p++) &#123;</span><br><span class="line">                    f[i][j] = <span class="built_in">min</span>(f[i][j], f[p][j<span class="number">-1</span>] + g[p+<span class="number">1</span>][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n<span class="number">-1</span>][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="leetcode-1312-让字符串成为回文串的最少插入次数"><a href="#leetcode-1312-让字符串成为回文串的最少插入次数" class="headerlink" title="leetcode 1312. 让字符串成为回文串的最少插入次数"></a>leetcode 1312. 让字符串成为回文串的最少插入次数</h1><p>给你一个字符串 $s$ ，每一次操作你都可以在字符串的任意位置插入任意字符。<br>请你返回让 $s$ 成为回文串的 最少操作次数 。<br>「回文串」是正读和反读都相同的字符串。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"zzazz"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：字符串 <span class="string">"zzazz"</span> 已经是回文串了，所以不需要做任何插入操作。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"mbadm"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：字符串可变为 <span class="string">"mbdadbm"</span> 或者 <span class="string">"mdbabdm"</span> 。</span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"leetcode"</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：插入 <span class="number">5</span> 个字符后字符串变为 <span class="string">"leetcodocteel"</span> 。</span><br><span class="line">示例 <span class="number">4</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"g"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">示例 <span class="number">5</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"no"</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ol>
<li>$1 &lt;= s.length &lt;= 500$</li>
<li>$s 中所有字符都是小写字母$</li>
</ol>
<ul>
<li>来源：力扣（LeetCode）</li>
<li>链接：<a href="https://leetcode-cn.com/problems/minimum-insertion-steps-to-make-a-string-palindrome" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-insertion-steps-to-make-a-string-palindrome</a></li>
</ul>
<p>思路：简单水题，求解最长回文子序列的变形，答案就是字符串总长度减去最长回文子序列的长度</p>
<ul>
<li>时间复杂度：$O(n^2)$</li>
<li>空间复杂度：$O(n^2)$</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minInsertions</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//求解最长回文子序列</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) f[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>;len&lt;=n;len++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+len<span class="number">-1</span>&lt;n;i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == s[j]) f[i][j] = f[i+<span class="number">1</span>][j<span class="number">-1</span>] + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> f[i][j] = <span class="built_in">max</span>(f[i+<span class="number">1</span>][j], f[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n - f[<span class="number">0</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="leetcode-1611-使整数变为-0-的最少操作次数"><a href="#leetcode-1611-使整数变为-0-的最少操作次数" class="headerlink" title="leetcode 1611. 使整数变为 0 的最少操作次数"></a>leetcode 1611. 使整数变为 0 的最少操作次数</h1><p>给你一个整数 $n$，你需要重复执行多次下述操作将其转换为 $0$ ：</p>
<p>翻转 $n$ 的二进制表示中最右侧位（第 $0$ 位）。<br>如果第 $(i-1)$ 位为 $1$ 且从第 $(i-2)$ 位到第 $0$ 位都为 $0$，则翻转 $n$ 的二进制表示中的第 $i$ 位。<br>返回将 $n$ 转换为 $0$ 的最小操作次数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：n = <span class="number">0</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：n = <span class="number">3</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：<span class="number">3</span> 的二进制表示为 <span class="string">"11"</span></span><br><span class="line"><span class="string">"11"</span> -&gt; <span class="string">"01"</span> ，执行的是第 <span class="number">2</span> 种操作，因为第 <span class="number">0</span> 位为 <span class="number">1</span> 。</span><br><span class="line"><span class="string">"01"</span> -&gt; <span class="string">"00"</span> ，执行的是第 <span class="number">1</span> 种操作。</span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：n = <span class="number">6</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：<span class="number">6</span> 的二进制表示为 <span class="string">"110"</span>.</span><br><span class="line"><span class="string">"110"</span> -&gt; <span class="string">"010"</span> ，执行的是第 <span class="number">2</span> 种操作，因为第 <span class="number">1</span> 位为 <span class="number">1</span> ，第 <span class="number">0</span> 到 <span class="number">0</span> 位为 <span class="number">0</span> 。</span><br><span class="line"><span class="string">"010"</span> -&gt; <span class="string">"011"</span> ，执行的是第 <span class="number">1</span> 种操作。</span><br><span class="line"><span class="string">"011"</span> -&gt; <span class="string">"001"</span> ，执行的是第 <span class="number">2</span> 种操作，因为第 <span class="number">0</span> 位为 <span class="number">1</span> 。</span><br><span class="line"><span class="string">"001"</span> -&gt; <span class="string">"000"</span> ，执行的是第 <span class="number">1</span> 种操作。</span><br><span class="line">示例 <span class="number">4</span>：</span><br><span class="line"></span><br><span class="line">输入：n = <span class="number">9</span></span><br><span class="line">输出：<span class="number">14</span></span><br><span class="line">示例 <span class="number">5</span>：</span><br><span class="line"></span><br><span class="line">输入：n = <span class="number">333</span></span><br><span class="line">输出：<span class="number">393</span></span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ol>
<li>$0 &lt;= n &lt;= 10^9$</li>
</ol>
<ul>
<li>来源：力扣（LeetCode）</li>
<li>链接：<a href="https://leetcode-cn.com/problems/minimum-one-bit-operations-to-make-integers-zero" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-one-bit-operations-to-make-integers-zero</a></li>
</ul>
<p>思路:很有意思的一道题,其实是求格雷码的逆变换，本题从格雷码生成开始分析。<br>格雷码就是 $1\sim n$ 的一个排列中，相邻的两个数字的二进制表示只有一位不同。<br>如三位的格雷码：中间列是序号，左三位是三位格雷码的二进制表示，右三位是序号的二进制表示。<br>生成方式1.<br>(1)反转前一个格雷码的二进制位的最后一位<br>(2)将右边第一个二进制位是1的位置的左边的二进制位翻转<br>具体看以下样例<br>  0 0 0 –0–&gt; 0 0 0<br>  0 0 1 –1–&gt; 0 0 1<br>  0 1 1 –2–&gt; 0 1 0<br>  0 1 0 –3–&gt; 0 1 1<br>  1 1 0 –4–&gt; 1 0 0<br>  1 1 1 –5–&gt; 1 0 1<br>  1 0 1 –6–&gt; 1 1 0<br>  1 0 0 –7–&gt; 1 1 1</p>
<p>生成方式2.<br>显然：上述格雷码 $G(n)$ 和 $n$ 是有关系的, $G(n)$ 的二进制位表示中第 $i$ 位为 $1$ 只有两种情况(二进制位右边为最低位，左边为最高位)，序号 $n$ 的二进制表示中第 $i$ 位为 $1$ ，第 $i+1$ 位为 $0$ ，或者第 $i$ 位为 $0$ ，第 $i+1$ 位为 $1$ ，所以是个异或的过程，即 $G(n) = n \bigoplus (n &gt;&gt; 1)$</p>
<p>完成生成格雷码的过程后，再来看其逆变换的过程，从高位到低位有：</p>
<p>$n_k = g_k$<br>$n_{k-1} = g_{k-1} \bigoplus n_k = g_{k-1} \bigoplus g_k$<br>$n_{k-2} = g_{k-2} \bigoplus n_{k-1} = g_{k-2} \bigoplus g_{k-1} \bigoplus g_{k}$<br>…<br>$n_{k-j} = \bigoplus_{i=0}^j g_{k-i}$<br>所以其逆变换从最高位开始递推有：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minimumOneBitOperations</span><span class="params">(<span class="keyword">int</span> g)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;g;g&gt;&gt;=<span class="number">1</span>) n^=g;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：$O(log_n)$</li>
<li>空间复杂度：$O(1)$<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumOneBitOperations</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> g = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;n;n&gt;&gt;=<span class="number">1</span>) g^=n;</span><br><span class="line">        <span class="keyword">return</span> g;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>面经总结(转载)</title>
    <url>/posts/e266340d.html</url>
    <content><![CDATA[<h3 id="1-转载一篇别人总结好的面经。"><a href="#1-转载一篇别人总结好的面经。" class="headerlink" title="1. 转载一篇别人总结好的面经。"></a>1. 转载一篇别人总结好的面经。</h3><p>link:<a href="https://leetcode-cn.com/circle/discuss/XXGdoF/#65-reetrantlock-%E5%92%8C-synchronized%E7%9A%84%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener">https://leetcode-cn.com/circle/discuss/XXGdoF/#65-reetrantlock-%E5%92%8C-synchronized%E7%9A%84%E5%8C%BA%E5%88%AB</a></p>
<a id="more"></a>
<h3 id="2-操作系统"><a href="#2-操作系统" class="headerlink" title="2. 操作系统"></a>2. 操作系统</h3><ol>
<li><p><strong>进程和线程的区别？</strong></p>
<blockquote>
<p>1、<strong>进程是资源分配的最小单位，线程是任务执行的最小单位。（关键句）</strong><br> 2、进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费比进程要小得多，同时创建一个线程的开销也比进程要小很多。<br> 3、线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式(IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。</p>
</blockquote>
</li>
<li><p><strong>进程的调度算法有哪些？（主要）</strong></p>
<blockquote>
<ol>
<li><p>先来先服务，从后备队列选择最先进入的作业，调入内存。</p>
</li>
<li><p>时间片轮转法，遵循先来先服务原则，但是一次只能运行一个固定的时间片。</p>
</li>
<li><p>短作业优先，从后备队列选择估计运行时间最短的作业，调入内存。平均等待时间、平均周转时间最少。</p>
</li>
<li><p>多级反馈队列调度算法</p>
</li>
<li><p>优先级调度，分为非剥夺式和剥夺式。</p>
</li>
</ol>
</blockquote>
</li>
<li><p><strong>5种IO模型？</strong></p>
<blockquote>
<p><strong>关注消息通信机制：</strong></p>
<p><strong>同步：调用一个功能，在功能结果没有返回之前，一直等待结果返回。</strong></p>
<p><strong>异步：调用一个功能，调用立刻返回，但调用者不能立刻得到结果。调用者可以继续后续的操作，其结果一般通过状态，回调函数来通知调用者。</strong></p>
<p><strong>等待调用结果时的状态：</strong></p>
<p><strong>阻塞：调用一个函数，当调用结果返回之前，当前线程会被挂起，只有得到结果之后才会返回。</strong></p>
<p><strong>非阻塞：调用一个函数，不能立刻得到结果之前，调用不能阻塞当前线程。</strong></p>
</blockquote>
<blockquote>
<p><strong>一个输入操作通常包括两个阶段：</strong></p>
<ul>
<li><strong>等待数据准备好</strong></li>
<li><strong>从内核向进程复制数据</strong></li>
</ul>
<p><strong>对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待数据到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。</strong></p>
</blockquote>
<blockquote>
<p>阻塞IO模型：应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。</p>
<p>非阻塞IO模型：进程发起IO系统调用后，内核返回一个错误码而不会被阻塞；应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成。如果内核缓冲区有数据，内核就会把数据返回进程。</p>
<p>IO复用模型：使用 select 或者 poll 等待数据，可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后把数据从内核复制到进程中。（在多路复用IO模型中，会有一个线程不断去轮询多个socket的状态，只有当socket真正有读写事件时，才真正调用实际的IO读写操作。因为在多路复用IO模型中，只需要使用一个线程就可以管理多个socket，并且只有在真正有socket读写事件进行时，才会使用IO资源，所以它大大减少了资源占用。）</p>
<p>信号驱动IO模型：当进程发起一个IO操作，会向内核注册一个信号处理函数，然后进程返回不阻塞；当内核数据就绪时会发送一个信号给进程，进程便在信号处理函数中调用IO读取数据。</p>
<p>异步IO模型：当进程发起一个IO操作，进程返回不阻塞，但也不能返回结果；内核把整个IO处理完后，会通知进程结果。如果IO操作成功则进程直接获取到数据。</p>
</blockquote>
</li>
<li><p><strong>select、poll和epoll的区别？epoll的底层使用的数据结构。</strong></p>
<blockquote>
<p>select ，poll和epoll允许应用程序监视一组文件描述符，等待一个或者多个描述符成为就绪状态，从而完成 I/O 操作。</p>
<p>select 和 poll 的功能基本相同，不过在一些实现细节上有所不同。</p>
<ul>
<li>select 的描述符类型使用数组实现，FD_SETSIZE 大小默认为 1024，因此默认只能监听少于 1024 个描述符。如果要监听更多描述符的话，需要修改 FD_SETSIZE 之后重新编译；而 poll 没有描述符数量的限制，poll 中的描述符是 pollfd 类型的数组。；</li>
<li>poll 提供了更多的事件类型，并且对描述符的重复利用上比 select 高。</li>
<li>如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定。</li>
</ul>
<p>select 和 poll 速度都比较慢，每次调用都需要将全部描述符从应用进程缓冲区复制到内核缓冲区。</p>
</blockquote>
<blockquote>
<p>当某个进程调用epoll_create()方法时，内核会创建一个eventpoll对象。</p>
<p>创建epoll对象后，可以用epoll_ctl()向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将 I/O 准备好的描述符加入到一个链表中管理，进程调用 epoll_wait() 便可以得到事件完成的描述符。</p>
<p>就绪列表：epoll使用双向链表来实现就绪队列，是一种能够快速插入和删除的数据结构。</p>
<p>索引结构：epoll使用红黑树去监听并维护所有文件描述符。</p>
</blockquote>
<blockquote>
<p>epoll 的描述符事件有两种触发模式：LT（水平触发）和 ET（边沿触发）。</p>
<p>当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。</p>
<p>和 LT 模式不同的是，通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。</p>
<p>边沿触发仅触发一次，水平触发会一直触发。</p>
</blockquote>
</li>
<li><p><strong>进程的通信方式有哪些？线程呢？</strong></p>
<blockquote>
<p><strong>进程间的通信方式</strong>：</p>
<ol>
<li><p><strong>管道/匿名管道(Pipes)</strong> ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。<strong>所谓的管道，就是内核里面的一串缓存</strong>。从管道的一段写入的数据，实际上是缓存在内核中的，另一端读取，也就是从内核中读取这段数据。另外，管道传输的数据是无格式的流且大小受限。</p>
</li>
<li><p><strong>有名管道(Names Pipes)</strong> : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循<strong>先进先出(first in first out)</strong>。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。</p>
</li>
<li><p><strong>消息队列(Message Queuing)</strong> ：<strong>消息队列是保存在内核中的消息链表，具有特定的格式，存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。</strong>与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息的类型读取比 FIFO 更有优势。<strong>消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺。</strong></p>
</li>
<li><p><strong>信号(Signal)</strong> ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；（对于异常情况下的工作模式，就需要用「信号」的方式来通知进程，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令）。比如，Ctrl+C 产生 <code>SIGINT</code> 信号，表示终止该进程，Ctrl+Z 产生 <code>SIGTSTP</code> 信号，表示停止该进程，但还未结束）</p>
</li>
<li><p><strong>信号量(Semaphores)</strong> ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。（信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据）</p>
</li>
<li><p><strong>共享内存(Shared memory)</strong> ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。（共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中）</p>
</li>
<li><p><strong>套接字(Sockets)</strong> : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int socket(int domain, int type, int protocal)</span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<blockquote>
<p><strong>线程间的通信方式</strong>：</p>
<ol>
<li><strong>互斥量(Mutex)</strong>：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。</li>
<li><strong>信号量(Semphares)</strong>: 它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。</li>
<li><strong>事件(Event)</strong>: Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</li>
</ol>
</blockquote>
</li>
<li><p><strong>fork函数的作用？</strong></p>
<blockquote>
<p> 在Linux中fork函数是非常重要的函数，它的作用是从已经存在的进程中创建一个子进程，而原进程称为父进程。</p>
<p>调用fork(),当控制转移到内核中的fork代码后，内核开始做：<br>1.分配新的内存块和内核数据结构给子进程。<br>2.将父进程部分数据结构内容拷贝至子进程。<br>3.将子进程添加到系统进程列表。<br>4.fork返回，开始调度。</p>
</blockquote>
<blockquote>
<p>特点：</p>
<ul>
<li>调用一次，返回两次</li>
<li>并发执行</li>
<li>相同但是独立的地址空间</li>
<li>fork的返回值 : fock函数调用一次却返回两次；向父进程返回子进程的ID，向子进程中返回0，<ol>
<li>fork的子进程返回为0；</li>
<li>父进程返回的是子进程的pid。</li>
</ol>
</li>
<li>fokr调用失败的原因<ol>
<li>系统中有太多进程。</li>
<li>实际用户的进程数超过限制。</li>
</ol>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>协程的概念？</strong></p>
<blockquote>
<p>协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</p>
<p>对操作系统而言，线程是最小的执行单元，进程是最小的资源管理单元。无论是进程还是线程，都是由操作系统所管理的。</p>
<p>协程不是被操作系统内核所管理的，而是完全由程序所控制，也就是在用户态执行。这样带来的好处是性能大幅度的提升，因为不会像线程切换那样消耗资源。</p>
<ul>
<li><p>协程既不是进程也不是线程，协程仅仅是一个特殊的函数，协程它进程和进程不是一个维度的。</p>
</li>
<li><p>一个进程可以包含多个线程，一个线程可以包含多个协程。</p>
</li>
<li><p>一个线程内的多个协程虽然可以切换，但是多个协程是串行执行的，只能在一个线程内运行，没法利用CPU多核能力。</p>
</li>
<li><p>协程与进程一样，切换是存在上下文切换问题的。</p>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>linux进程和线程？</strong></p>
<blockquote>
<p>进程通过fork()创建</p>
<p>线程通过pthread_create()函数创建</p>
</blockquote>
</li>
<li><p><strong>僵尸进程产生的原因？</strong></p>
<blockquote>
<p>僵尸进程是指它的父进程没有等待(调用wait/waitpid)。</p>
<p><strong>如果子进程先结束而父进程后结束，即子进程结束后，父进程还在继续运行但是并未调用wait/waitpid那子进程就会成为僵尸进程。</strong></p>
<p>但如果子进程后结束，即父进程先结束了，但没有调用wait/waitpid来等待子进程的结束，此时子进程还在运行，父进程已经结束。那么并不会产生僵尸进程。应为每个进程结束时，系统都会扫描当前系统中运行的所有进程，看看有没有哪个进程时刚刚结束的这个进程的子进程，如果有，就有init来接管它，成为它的父进程。</p>
<p>进程设置僵尸状态的目的是维护子进程的信息，以便父进程在以后某个时间获取。要在当前进程中生成一个子进程，一般需要调用fork这个系统调用，fork这个函数的特别之处在于一次调用，两次返回，一次返回到父进程中，一次返回到子进程中，可以通过返回值来判断其返回点。如果子进程先于父进程退出， 同时父进程又没有调用wait/waitpid，则该子进程将成为僵尸进程。</p>
<p>在每个进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存。但是仍然保留了一些信息（如进程号pid 退出状态 运行时间等）。这些保留的信息直到进程通过调用wait/waitpid时才会释放。这样就导致了一个问题，如果没有调用wait/waitpid的话，那么保留的信息就不会释放。比如进程号就会被一直占用了。但系统所能使用的进程号的有限的，如果产生大量的僵尸进程，将导致系统没有可用的进程号而导致系统不能创建进程。所以我们应该避免僵尸进程。</p>
<p><strong>如果进程不调用wait / waitpid的话，</strong> <strong>那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。</strong></p>
</blockquote>
</li>
<li><p><strong>孤儿进程产生的原因？</strong></p>
<blockquote>
<p><strong>孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</strong></p>
<p><strong>孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了init进程身上，因此孤儿进程并不会有什么危害。</strong></p>
</blockquote>
</li>
<li><p><strong>讲一下虚拟内存。虚拟内存和物理内存的关系是什么？</strong></p>
<blockquote>
<p>虚拟内存使得应用程序认为它拥有一个<strong>连续的地址空间，而实际上，它通常是被分隔成多个物理内存碎片，还有一部分存储在外部磁盘存储器上，在需要时进行数据交换。</strong></p>
<p>虚拟内存可以让程序可以拥有超过系统物理内存大小的可用内存空间。虚拟内存让每个进程拥有一片连续完整的内存空间。</p>
</blockquote>
<blockquote>
<p>局部性原理表现在以下两个方面：</p>
<ol>
<li><strong>时间局部性</strong> ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。</li>
<li><strong>空间局部性</strong> ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问。</li>
</ol>
</blockquote>
<blockquote>
<p>操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，会将缺失的部分从磁盘装入物理内存。</p>
</blockquote>
<blockquote>
<p>页面置换算法：</p>
<p><strong>OPT 页面置换算法（最佳页面置换算法）</strong>：所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。</p>
<p><strong>FIFO（First In First Out） 页面置换算法（先进先出页面置换算法）</strong> : 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。</p>
<p><strong>LRU （Least Currently Used）页面置换算法（最近最久未使用页面置换算法）</strong>：将最近最久未使用的页面换出。需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。</p>
<p><strong>LFU （Least Frequently Used）页面置换算法（最少使用页面置换算法）</strong>：该置换算法选择在之前时期使用最少的页面作为淘汰页。被使用次数最少的数据优先淘汰。每个数据块都有一个引用计数，按照引用计数排序，具有相同计数的数据块按时间排序。</p>
</blockquote>
</li>
<li><p><strong>分段和分页讲一下？以及对应的场景？</strong></p>
<blockquote>
<p><strong>操作系统的内存管理机制了解吗？内存管理有哪几种方式?</strong></p>
<ol>
<li><strong>块式管理</strong> ： 将内存分为几个固定大小的块，每个块中只包含一个进程。</li>
<li><strong>页式管理</strong> ：把主存分为大小相等且固定的一页一页的形式，页较小，相对相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。</li>
<li><strong>段式管理</strong> ： 页式管理虽然提高了内存利用率，但是页式管理其中的页实际并无任何实际意义。 段式管理把主存分为一段段的，最重要的是段是有实际意义的，每个段定义了一组逻辑信息。 段式管理通过段表对应逻辑地址和物理地址。例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。</li>
<li><strong>段页式管理</strong>：段页式管理机制结合了段式管理和页式管理的优点。段页式管理机制就是把主存先分成若干段，每个段又分成若干页。</li>
</ol>
</blockquote>
<blockquote>
<p><strong>分段和分页</strong>：</p>
<ol>
<li>共同点<ul>
<li>分页机制和分段机制都是为了提高内存利用率，较少内存碎片。</li>
<li>页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。</li>
</ul>
</li>
<li>区别<ul>
<li>页的大小是固定的，由操作系统决定；而段的大小不固定，取决于我们当前运行的程序。</li>
<li>分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要。</li>
</ul>
</li>
</ol>
</blockquote>
</li>
<li><p><strong>讲一下用户态和内核态？所有的系统调用都会进入到内核态吗？</strong></p>
<blockquote>
<blockquote>
<p>操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序。</p>
<p>根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：</p>
<ol>
<li>用户态(user mode) : 用户态运行的进程或可以直接读取用户程序的数据。</li>
<li>内核态(kernel mode):可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。</li>
</ol>
<p>运行的程序基本都是运行在用户态。如果我们调用操作系统提供的内核态级别的子功能那就需要系统调用了。</p>
<p>系统调用：与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。</p>
<p>系统调用是操作系统为应用程序提供能够访问到内核态的资源的接口。</p>
</blockquote>
<p>   补充：</p>
<blockquote>
<p>用户态切换到内核态的几种方式</p>
<ul>
<li>系统调用: 系统调用是用户态主动要求切换到内核态的一种方式， 用户应用程序通过操作系统调用内核为上层应用程序开放的接口来执行程序。</li>
<li>异常: 当cpu在执行用户态的应用程序时，发生了某些不可知的异常。 于是当前用户态的应用进程切换到处理此异常的内核的程序中去。</li>
<li>硬件设备的中断: 当硬件设备完成用户请求后，会向cpu发出相应的中断信号， 这时cpu会暂停执行下一条即将要执行的指令，转而去执行与中断信号对应的应用程序， 如果先前执行的指令是用户态下程序的指令，那么这个转换过程也是用户态到内核台的转换。</li>
</ul>
</blockquote>
</blockquote>
</li>
<li><p><strong>如何查看占用内存比较多的进程？</strong></p>
<blockquote>
<p>ps aux | sort -k4nr | head -N</p>
<p><code>head</code>：-N可以指定显示的行数，默认显示10行。</p>
<p><code>ps</code>：a—指代所有的进程，u—userid—执行该进程的用户id，x—指代显示所有程序，不以终端机来区分。ps -aux的输出格式如下：</p>
<p><code>sort -k4nr</code>中：k代表从根据哪一个关键词排序，后面的数字4表示按照第四列排序；n指代numberic sort，根据其数值排序；r指代reverse，这里是指反向比较结果，输出时默认从小到大，反向后从大到小。%MEM在第4个位置，-k4按照内存占用排序。%CPU在第三个位置，-k3表示按照cpu占用率排序。</p>
</blockquote>
</li>
<li><p><strong>通过进程id查看占用的端口，通过端口号查看占用的进程id？</strong></p>
<blockquote>
<p>通过进程id查看占用的端口 : <code>netstat -nap | grep 进程id</code></p>
<p>通过端口号查看占用的进程id : <code>netstat -nap | grep 端口号</code></p>
</blockquote>
</li>
<li><p><strong>平常用什么linux命令比较多？如何打开文件并进行查找某个单词？怎么在某个目录下找到包含txt的文件？</strong></p>
<blockquote>
<ul>
<li><p><strong><code>pwd</code>：</strong> 显示当前所在位置</p>
</li>
<li><p><code>sudo + 其他命令</code>：以系统管理者的身份执行指令，也就是说，经由 sudo 所执行的指令就好像是 root 亲自执行。</p>
</li>
<li><p><strong><code>grep 要搜索的字符串 要搜索的文件 --color</code>：</strong> 搜索命令，–color代表高亮显示</p>
</li>
<li><p><strong><code>ps -ef</code>/<code>ps aux</code>：</strong> 这两个命令都是查看当前系统正在运行进程，两者的区别是展示格式不同。如果想要查看特定的进程可以使用这样的格式：<strong><code>ps aux|grep redis</code></strong> （查看包括redis字符串的进程），也可使用 <code>pgrep redis -a</code>。</p>
<p>注意：如果直接用ps（（Process Status））命令，会显示所有进程的状态，通常结合grep命令查看某进程的状态。</p>
</li>
<li><p><strong><code>kill -9 进程的pid</code>：</strong> 杀死进程（-9 表示强制终止），先用ps查找进程，然后用kill杀掉。</p>
</li>
<li><p><code>find 目录 参数</code>： 寻找目录（查）。在/home目录下查找以<code>.txt</code>结尾的文件名:<code>find /home -name &quot;*.txt&quot;</code></p>
</li>
<li><p><strong><code>ls或者ll</code></strong>:（ll是ls -l的别名，ll命令可以看到该目录下的所有目录和文件的详细信息）：查看目录信息。</p>
</li>
<li><p><strong><code>free</code></strong> : 显示系统内存的使用情况，包括物理内存、交换内存(swap)和内核缓冲区内存。</p>
</li>
<li><p><strong><code>tar -zcvf 打包压缩后的文件名 要打包压缩的文件</code></strong>: 打包并压缩文件，一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。c：压缩。</p>
</li>
<li><p><strong><code>tar -xvf 压缩文件 -C 解压的位置</code></strong>: 解压压缩包。x: 解压。</p>
</li>
<li><p><strong><code>wget</code></strong>: 是从远程下载的工具。</p>
</li>
<li><p><strong><code>vmstat</code></strong>: 虚拟内存性能监控、CPU监控。</p>
</li>
<li><p><strong><code>top</code></strong>: 常用来监控Linux的系统状况，比如CPU、内存的使用，显示系统上正在运行的进程。load average：系统负载，就是进程队列的长度。当这个值&gt;cpu核心数的时候就说明有进程在等待处理了，是负载过重。</p>
</li>
</ul>
</blockquote>
<blockquote>
<p><code>find /home -name &quot;*.txt&quot;</code></p>
<p><code>cat a.txt | grep redis</code></p>
</blockquote>
</li>
<li><p><strong>用过Ping命令么？简单介绍一下。TTL是什么意思？</strong></p>
<blockquote>
<p><code>ping</code>: 查看与某台机器的连接情况。TTL：生存时间。数据报被路由器丢弃之前允许通过的网段数量。</p>
</blockquote>
</li>
<li><p><strong>怎么判断一个主机是不是开放某个端口？</strong></p>
<blockquote>
<p><code>telnet 127.0.0.1 3389</code> <code>telnet IP地址 端口</code></p>
</blockquote>
</li>
<li><p><strong>Linux文件系统？</strong></p>
<blockquote>
<p>inode 是 linux/unix 文件系统的基础。</p>
<p>硬盘的最小存储单位是扇区(Sector)，块(block)由多个扇区组成。文件数据存储在块中。块的最常见的大小是 4kb，约为 8 个连续的扇区组成（每个扇区存储 512 字节）。一个文件可能会占用多个块，但是一个块只能存放一个文件。</p>
<p>我们将文件存储在了块(block)中，但是我们还需要一个空间来存储文件的 <strong>元信息 metadata</strong> ：如某个文件被分成几块、每一块在的地址、文件拥有者，创建时间，权限，大小等。这种 <strong>存储文件元信息的区域就叫 inode</strong>，译为索引节点：<strong>i (index) + node</strong>。 每个文件都有一个 inode，存储文件的元信息。</p>
<p>可以使用 <code>stat</code> 命令可以查看文件的 inode 信息。每个 inode 都有一个号码，Linux/Unix 操作系统不使用文件名来区分文件，而是使用 inode 号码区分不同的文件。</p>
<p><strong>inode 就是用来维护某个文件被分成几块、每一块在的地址、文件拥有者，创建时间，权限，大小等信息。</strong></p>
</blockquote>
<blockquote>
<ul>
<li><strong>inode</strong> ：记录文件的属性信息，可以使用 stat 命令查看 inode 信息。</li>
<li><strong>block</strong> ：实际文件的内容，如果一个文件大于一个块时候，那么将占用多个 block，但是一个块只能存放一个文件。（因为数据是由 inode 指向的，如果有两个文件的数据存放在同一个块中，就会乱套了）</li>
</ul>
</blockquote>
</li>
<li><p><strong>硬链接和软链接？</strong></p>
<blockquote>
<ul>
<li>硬链接： 硬连接指通过索引节点<code>inode</code>来进行的连接，即每一个硬链接都是一个指向对应区域的文件。</li>
<li>软链接： 保存了其代表的文件的绝对路径，是另外一种文件，在硬盘上有独立的区块，访问时替换自身路径。</li>
</ul>
</blockquote>
</li>
<li><p><strong>中断的分类？</strong></p>
<blockquote>
<ol>
<li>中断可以分为同步中断（synchronous）和异步中断(asynchronous)。</li>
<li>中断可分为硬中断和软中断。</li>
<li>中断可分为可屏蔽中断（Maskable interrupt）和非屏蔽中断（Nomaskable interrupt）。</li>
</ol>
</blockquote>
<blockquote>
<p>同步中断是在指令执行时由CPU主动产生的，受到CPU控制，其执行点是可控的。</p>
<p>异步中断是CPU被动接收到的，由外设发出的电信号引起，其发生时间不可预测。</p>
</blockquote>
</li>
<li><p><strong>软中断和硬中断？</strong></p>
<blockquote>
<p>从本质上讲，中断(硬)是一种电信号，当设备有某种事情发生的时候，他就会产生中断，通过总线把电信号发送给中断控制器。如果中断的线是激活的，中断控制器就把电信号发送给处理器的某个特定引脚。处理器于是立即停止自己正在做的事，跳到中断处理程序的入口点，进行中断处理。</p>
<p>硬中断是由硬件产生的，比如，像磁盘，网卡，键盘，时钟等。每个设备或设备集都有它自己的IRQ（中断请求）。</p>
<p>软中断是由当前正在运行的进程所产生的。</p>
<p>软中断比硬中断少了一个硬件发送信号的步骤。产生软中断的进程一定是当前正在运行的进程，因此它们不会中断CPU。但是它们会中断调用代码的流程。如果硬件需要CPU去做一些事情，那么这个硬件会使CPU中断当前正在运行的代码。</p>
</blockquote>
</li>
</ol>
<hr>
<h3 id="3-Java-基础"><a href="#3-Java-基础" class="headerlink" title="3. Java 基础"></a>3. Java 基础</h3><ol>
<li><p><strong>StringBuilder 和 StringBuffer（StringBuffer 是线程安全的，StringBuilder 是不安全的）</strong></p>
</li>
<li><p><strong>Java实现连续空间的内存分配? java的内存管理 对象的分配与释放</strong></p>
<blockquote>
<p>基本数据类型的数组，存放在栈内存里，连续分配</p>
<p>对象数组,在栈内存里的引用是连续分配的，实际数据分配在堆内存，不是连续分配的;</p>
</blockquote>
<blockquote>
<p> java的内存管理，对象的分配与释放</p>
<p>分配:</p>
<p>通过new为每个对象申请内存空间（基本类型除外）所有对象都在堆中分配空间;</p>
<p>释放：</p>
<p>对象的释放是由垃圾回收机制决定和执行的,这样极大的简化CG(垃圾处理装置)的负担,当然同时也为程序员带来便利(例如c语言需要手动的去处理已经不在使用的对象,如果遗忘内存就会被越占越多)。</p>
<p>2大类:堆内存与栈内存</p>
<p>（1）在<strong>函数中</strong>定义的基本类型变量（即基本类型的局部变量）和对象的<strong>引用变量</strong>（即对象的变量名指向该对象的内存地址）都在栈内存中分配；</p>
<p>（2）堆内存用来存储由<strong>new创建的对象和数组</strong>以及<strong>对象的实例变量</strong>（即全局变量）</p>
<p>（3）每个线程包含一个栈区，保存基础数据类型的对象和自定义对象的引用，每个栈中的数据（原始类型和对象引用）都是私有的，其他栈不能访问。还有一个方法区：存储所有对象数据共享区域，存储静态变量和普通方法、静态方法、常量、字符串常量等信息，又叫静态区，是所有线程共享的。</p>
</blockquote>
</li>
<li><p><strong>创建对象的方式有哪几种？</strong></p>
<blockquote>
<ol>
<li><p>new Obj..()</p>
</li>
<li><p>clone()：使用Object类的clone方法。</p>
</li>
<li><p>反射</p>
<blockquote>
<ol>
<li><p>调用public无参构造器 ，若是没有，则会报异常：Object o = clazz.newInstance();　</p>
</li>
<li><p>有带参数的构造函数的类，先获取到其构造对象，再通过该构造方法类获取实例：</p>
<p>/ /获取构造函数类的对象</p>
<p>Constroctor constroctor = User.class.getConstructor(String.class);</p>
<p>// 使用构造器对象的newInstance方法初始化对象</p>
<p>Object obj = constroctor.newInstance(“name”);</p>
</li>
</ol>
</blockquote>
</li>
<li><p>通过反序列化来创建对象： 实现Serializable接口。</p>
</li>
</ol>
</blockquote>
</li>
<li><p><strong>接口和抽象类有什么区别？</strong></p>
</li>
<li><p><strong>深拷贝和浅拷贝区别？</strong></p>
</li>
<li><p><strong>讲一讲封装，继承，多态(重要)。</strong></p>
<blockquote>
<p>编译时多态</p>
<p><strong>方法重载</strong>都是编译时多态。根据实际参数的数据类型、个数和次序，Java在编译时能够确定执行重载方法中的哪一个。</p>
<p><strong>方法覆盖</strong>表现出两种多态性，当对象引用本类实例时，为编译时多态，否则为运行时多态。</p>
<p>运行时多态</p>
<p>通过父类对象引用变量引用子类对象来实现。当父类对象引用子类实例时。</p>
<p>通过接口类型变量引用实现接口的类的对象来实现 。</p>
<p>运行时多态主要是通过继承和接口实现的。</p>
</blockquote>
</li>
<li><p><strong>泛型是什么?类型擦除？</strong></p>
<blockquote>
<p>泛型：将类型当作参数传递给一个类或者是方法。</p>
<p>类型擦除：<strong>Java的泛型是伪泛型，这是因为Java在编译期间，所有的泛型信息都会被擦掉，正确理解泛型概念的首要前提是理解类型擦除。</strong></p>
<p>Java的泛型基本上都是在编译器这个层次上实现的，在生成的字节码中是不包含泛型中的类型信息的，使用泛型的时候加上类型参数，在编译器编译的时候会去掉，这个过程成为类型擦除。</p>
<p><strong>原始类型</strong> 就是擦除去了泛型信息，最后在字节码中的类型变量的真正类型，无论何时定义一个泛型，相应的原始类型都会被自动提供，类型变量擦除，并使用其限定类型（无限定的变量用Object）替换。</p>
<p><strong>Java编译器是通过先检查代码中泛型的类型，然后在进行类型擦除，再进行编译。当具体的类型确定后，泛型提供了一种类型检测的机制，只有相匹配的数据才能正常的赋值，否则编译器就不通过。</strong></p>
</blockquote>
</li>
<li><p><strong>如何实现静态代理？有啥缺陷？</strong></p>
<blockquote>
<ol>
<li>为现有的每一个类都编写一个<strong>对应的</strong>代理类，并且让它实现和目标类相同的接口。</li>
<li>在创建代理对象时，通过构造器塞入一个目标对象，然后在代理对象的方法内部调用目标对象同名方法，并在调用前后增加一些其他方法。比如打印日志。代理对象 = 增强代码 + 目标对象。</li>
</ol>
<p>需要为每一个目标类编写对应的代理类，工作量太大了。</p>
</blockquote>
</li>
<li><p><strong>动态代理的作用？在哪些地方用到了？（<em>AOP、RPC 框架中都有用到</em>）</strong></p>
<blockquote>
<p>为其它对象提供一种代理以控制对这个对象的访问控制，在程序运行时，通过反射机制动态生成。</p>
<p>动态代理的调用处理程序必须实现InvocationHandler接口，及使用Proxy类中的newProxyInstance方法动态的创建代理类。</p>
</blockquote>
</li>
<li><p><strong>JDK 的动态代理和 CGLIB 有什么区别？</strong></p>
<blockquote>
<p><strong>JDK 动态代理只能只能代理实现了接口的类，而 CGLIB 可以代理未实现任何接口的类。</strong> 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。</p>
</blockquote>
</li>
<li><p><strong>谈谈对 Java 注解的理解，解决了什么问题？</strong></p>
<blockquote>
<p><strong>Java 语言中的类、方法、变量、参数和包等都可以注解标记，程序运行期间我们可以获取到相应的注解以及注解中定义的内容，这样可以帮助我们做一些事情。比如说 Spring 中如果检测到说你的类被 <code>@Component</code>注解标记的话，Spring 容器在启动的时候就会把这个类归为自己管理，这样你就可以通过 <code>@Autowired</code>注解注入这个对象了。</strong></p>
</blockquote>
</li>
<li><p><strong>Java 反射？反射有什么缺点？你是怎么理解反射的（为什么框架需要反射）？</strong></p>
<blockquote>
<blockquote>
<p><strong>反射介绍：</strong></p>
<p>JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。</p>
</blockquote>
<blockquote>
<p><strong>反射的优缺点如下：</strong></p>
<ul>
<li><strong>优点：</strong> 运行期类型的判断，动态加载类，提高代码灵活度。</li>
<li><strong>缺点：</strong> 1,性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的 java 代码要慢很多。2,安全问题，让我们可以动态操作改变类的属性同时也增加了类的安全隐患。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>为什么框架需要反射技术？</strong></p>
<p>在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关。动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。</p>
<ol>
<li>我们在使用 JDBC 连接数据库时使用 <code>Class.forName()</code>通过反射加载数据库的驱动程序；</li>
<li>Spring 框架的 IOC（动态加载管理 Bean）创建对象以及 AOP（动态代理）功能都和反射有联系；</li>
<li>动态配置实例的属性；</li>
</ol>
</blockquote>
<blockquote>
<p><strong>获取 Class 对象的两种方式</strong></p>
<p>如果我们动态获取到这些信息，我们需要依靠 Class 对象。Class 类对象将一个类的方法、变量等信息告诉运行的程序。Java 提供了两种方式获取 Class 对象:</p>
<p>1.知道具体类的情况下可以使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class alunbarClass = TargetObject<span class="class">.<span class="keyword">class</span></span>;</span><br></pre></td></tr></table></figure>

<p>但是我们一般是不知道具体类的，基本都是通过遍历包下面的类来获取 Class 对象</p>
<p>2.通过 <code>Class.forName()</code>传入类的路径获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class alunbarClass1 = Class.forName(<span class="string">"cn.javaguide.TargetObject"</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
</li>
<li><p><strong>内存泄露和内存溢出的场景。</strong></p>
<blockquote>
<p>内存泄漏：内存泄漏是指无用对象（不再使用的对象）持续占有内存或无用对象的内存得不到及时释放，从而造成内存空间的浪费称为内存泄漏。</p>
<p>Java内存泄漏的根本原因是长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是因为长生命周期持有它的引用而导致不能被回收，这就是Java中内存泄漏的发生场景。</p>
<p>内存溢出：指程序运行过程中无法申请到足够的内存而导致的一种错误。内存溢出通常发生于OLD段或Perm段垃圾回收后，仍然无内存空间容纳新的Java对象的情况。</p>
</blockquote>
<blockquote>
<p><strong>内存泄露的场景</strong></p>
<ol>
<li><strong>静态集合类引起内存泄漏</strong>：静态成员的生命周期是整个程序运行期间。比如：Map是在堆上动态分配的对象，正常情况下使用完毕后，会被gc回收。而如果Map被static修饰，且没有删除机制，静态成员是不会被回收的，所以会导致这个很大的Map一直停留在堆内存中。懒初始化<code>static</code>变量，且尽量避免使用。</li>
<li><strong>当集合里面的对象属性被修改后，再调用remove()方法时不起作用</strong>：修改hashset中对象的参数值，且参数是计算哈希值的字段。当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段，否则对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了。</li>
<li><strong>各种连接对象(IO流对象、数据库连接对象、网络连接对象)使用后未关闭</strong>：因为每个流在操作系统层面都对应了打开的文件句柄，流没有关闭，会导致操作系统的文件句柄一直处于打开状态，而jvm会消耗内存来跟踪操作系统打开的文件句柄。</li>
<li><strong>监听器的使用</strong>：在释放对象的同时没有相应删除监听器的时候也可能导致内存泄露。</li>
<li><strong>不正确使用单例模式是引起内存泄漏</strong>：单例对象在初始化后将在JVM的整个生命周期中存在（以静态变量的方式），如果<strong>单例对象持有外部的引用</strong>，那么这个对象将不能被JVM正常回收，导致内存泄漏。</li>
</ol>
<p>解决措施</p>
<p>​    1.尽量减少使用静态变量，类的静态变量的生命周期和类同步的。  </p>
<p>​    2.声明对象引用之前，明确内存对象的有效作用域，尽量减小对象的作用域，将类的成员变量改写为方法内的局部变量；</p>
<p>​    3.减少长生命周期的对象持有短生命周期的引用；</p>
<p>​    4.使用StringBuilder和StringBuffer进行字符串连接，Sting和StringBuilder以及StringBuffer等都可以代表字符串，其中String字符串代表的是不可变的字符串，后两者表示可变的字符串。如果使用多个String对象进行字符串连接运算，在运行时可能产生大量临时字符串，这些字符串会保存在内存中从而导致程序性能下降。  </p>
<p>​    5.对于不需要使用的对象手动设置null值，不管GC何时会开始清理，我们都应及时的将无用的对象标记为可被清理的对象；</p>
<p>​    6.各种连接（数据库连接，网络连接，IO连接）操作，务必显示调用close关闭。</p>
</blockquote>
<blockquote>
<p><strong>内存溢出场景</strong></p>
<ol>
<li><p><strong>JVM Heap（堆）溢出：OutOfMemoryError: Java heap space</strong>： 发生这种问题的原因是java虚拟机创建的对象太多，在进行垃圾回收之间，虚拟机分配的到堆内存空间已经用满了。</p>
<p>JVM在启动的时候会自动设置JVM Heap的值， 可以利用JVM提供的-Xmn -Xms -Xmx等选项可进行设置。Heap的大小是新生代和老年代之和。</p>
<p>解决方法：1. 手动设置JVM Heap（堆）的大小。2. 检查程序，看是否有死循环或不必要地重复创建大量对象。</p>
</li>
<li><p><strong>Metaspace溢出： java.lang.OutOfMemoryError: Metaspace</strong>：程序中使用了大量的jar或class，使java虚拟机装载类的空间不够，与metaspace大小有关。</p>
<p>方法区用于存放Java类型的相关信息。在类装载器加载class文件到内存的过程中，虚拟机会提取其中的类型信息，并将这些信息存储到方法区。当需要存储类信息而方法区的内存占用又已经达到-XX:MaxMetaspaceSize设置的最大值，将会抛出OutOfMemoryError异常。对于这种情况的测试，基本的思路是运行时产生大量的类去填满方法区，直到溢出。</p>
<p>解决方法:通过-XX:MetaspaceSize和-XX:MaxMetaspaceSize设置永久代大小即可。</p>
</li>
<li><p><strong>栈溢出： java.lang.StackOverflowError : Thread Stack space</strong>：线程的方法嵌套调用层次太多(如递归调用)，以致于把栈区溢出了。</p>
<p>解决方法：</p>
<p>  1：修改程序。2：通过 -Xss: 来设置每个线程的Stack大小即可。</p>
</li>
</ol>
</blockquote>
</li>
<li><p><strong>讲一下，强引用，弱引用，软引用，虚引用。</strong></p>
<blockquote>
<ol>
<li>强引用：被强引用关联的对象不会被回收。使用 new 一个新对象的方式来创建强引用。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>软引用：被软引用关联的对象只有在内存不够的情况下才会被回收。使用 SoftReference 类来创建软引用。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> SoftReference&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>;  <span class="comment">// 使对象只被软引用关联</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>弱引用：被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。</li>
</ol>
<p>使用 WeakReference 类来创建弱引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">WeakReference&lt;Object&gt; wf = <span class="keyword">new</span> WeakReference&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p><strong>4. 虚引用：一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。</strong></p>
</blockquote>
</li>
<li><p><strong>讲一下Java的NIO，AIO, BIO?</strong></p>
<blockquote>
<p><strong>BIO (Blocking I/O)</strong>：同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。</p>
<p><strong>NIO (Non-blocking/New I/O):</strong> NIO 是一种同步非阻塞的 I/O 模型，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。Java NIO使我们可以进行非阻塞IO操作。比如说，单线程中从通道读取数据到buffer，同时可以继续做别的事情，当数据读取到buffer中后，线程再继续处理数据。写数据也是一样的。另外，非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。JDK 的 NIO 底层由 epoll 实现。</p>
<p>通常来说NIO中的所有IO都是从 Channel（通道） 开始的。</p>
<ul>
<li>从通道进行数据读取 ：创建一个缓冲区，然后请求通道读取数据。</li>
<li>从通道进行数据写入 ：创建一个缓冲区，填充数据，并要求通道写入数据。</li>
</ul>
<p><strong>AIO (Asynchronous I/O)</strong>：异步非阻塞IO模型，异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 的应用还不是很广泛。</p>
</blockquote>
</li>
<li><p><strong>Java中finalize()方法的使用?</strong></p>
<blockquote>
<p>finalize()是Object的protected方法，子类可以覆盖该方法以实现资源清理工作，GC在回收对象之前调用该方法。</p>
<p>finalize()方法中一般用于释放非Java 资源（如打开的文件资源、数据库连接等）,或是调用非Java方法（native方法）时分配的内存（比如C语言的malloc()系列函数）。</p>
<p><strong>避免使用的原因：</strong></p>
<p>首先，由于finalize()方法的调用时机具有不确定性，从一个对象变得不可到达开始，到finalize()方法被执行，所花费的时间这段时间是任意长的。我们并不能依赖finalize()方法能及时的回收占用的资源，可能出现的情况是在我们耗尽资源之前，gc却仍未触发，因而通常的做法是提供显示的close()方法供客户端手动调用。<br>另外，重写finalize()方法意味着延长了回收对象时需要进行更多的操作，从而延长了对象回收的时间。</p>
</blockquote>
</li>
<li><p><strong>GC Root 对象有哪些</strong></p>
<blockquote>
<ul>
<li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li>
<li>本地方法栈(Native方法)中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
</ul>
</blockquote>
</li>
<li><p><strong>Java中Class.forName和ClassLoader的区别？</strong></p>
<blockquote>
<p>类的加载：</p>
<p>加载：通过类的全限定名获取二进制字节流，将二进制字节流转换成方法区中的运行时数据结构，在内存中生成Java.lang.class对象；</p>
<p>链接：执行下面的校验、准备和解析步骤，其中解析步骤是可以选择的；</p>
<p>　　校验：检查导入类或接口的二进制数据的正确性；（文件格式验证，元数据验证，字节码验证，符号引用验证）</p>
<p>　　准备：给类的静态变量分配内存并初始化内存空间；</p>
<p>　　解析：将常量池中的符号引用转成直接引用；</p>
<p>初始化：激活类的静态变量的初始化Java代码和静态Java代码块，并初始化程序员设置的变量值。</p>
</blockquote>
<blockquote>
<p>在java中Class.forName()和ClassLoader都可以对类进行加载。ClassLoader就是遵循<strong>双亲委派模型</strong>最终调用启动类加载器的类加载器，实现的功能是通过一个类的全限定名来获取描述此类的二进制字节流，获取到二进制流后放到JVM中。classloader只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容。</p>
<p>Class.forName()方法实际上也是调用的CLassLoader来实现的。Class.forName()除了将类的.class文件加载到jvm中之外，还会对类进行初始化，执行类中的static块。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className)</span><br><span class="line">               <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">       Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">       <span class="keyword">return</span> forName0(className, <span class="keyword">true</span>, ClassLoader.getClassLoader(caller), caller);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>最后调用的方法是forName0这个方法，在这个forName0方法中的第二个参数被默认设置为了true，这个参数代表是否对加载的类进行初始化，设置为true时会类进行初始化，代表会执行类中的静态代码块，以及对静态变量的赋值等操作。</p>
</blockquote>
</li>
<li><p><strong>讲一下CopyOnWriteArrayList和CopyOnWriteArraySet?</strong></p>
<blockquote>
<p><strong>CopyOnWrite容器</strong>：写时复制的容器。当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。</p>
<p>以下代码是向ArrayList里添加元素，可以发现在添加的时候是需要加锁的，否则多线程写的时候会Copy出N个副本出来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(T e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">// 复制出新数组</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 把新元素添加到新数组里</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">// 把原数组引用指向新数组</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">    array = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读的时候不需要加锁，如果读的时候有多个线程正在向ArrayList添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的ArrayList。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CopyOnWrite并发容器用于读多写少的并发场景。</p>
<p><strong>CopyOnWrite的缺点</strong></p>
<p>CopyOnWrite容器有很多优点，但是同时也存在两个问题，即<strong>内存占用问题</strong>和<strong>数据一致性问题</strong>。所以在开发的时候需要注意一下。</p>
<p><strong>内存占用问题</strong>。因为CopyOnWrite的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象（注意:在复制的时候只是复制容器里的引用，只是在写的时候会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）。如果这些对象占用的内存比较大，比如说200M左右，那么再写入100M数据进去，内存就会占用300M，那么这个时候很有可能造成频繁的Yong GC和Full GC。</p>
<p>针对内存占用问题，可以通过压缩容器中的元素的方法来减少大对象的内存消耗，比如，如果元素全是10进制的数字，可以考虑把它压缩成36进制或64进制。或者不使用CopyOnWrite容器，而使用其他的并发容器，如ConcurrentHashMap。</p>
<p><strong>数据一致性问题</strong>。CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。</p>
</blockquote>
</li>
<li><p><strong>说一下你最用的比较多得模式（我说的工厂模式和观察者模式），再实现一个单例模式。 为什么要用voliate修饰? 出现synchronized为啥还需要voliate，以及synchronized能保证啥？</strong></p>
<blockquote>
<p>观察者模式：观察者模式定义了一系列对象之间的一对多关系。当一个对象改变状态, 其他依赖着都会受到通知。车辆的数据时不断更新的，需要监控数据的变化，当有新数据时就通知观测者observers。</p>
<p>迭代器模式：提供一种顺序访问聚合对象元素的方法。 hasNext() 和 next() 方法。</p>
<p>代理模式：代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。</p>
<p><strong>JDK 动态代理和 CGLIB 动态代理均是实现 Spring AOP 的基础</strong>。</p>
<p>适配器模式：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作。</p>
</blockquote>
</li>
<li><p><strong>单例模式代码（重要）</strong></p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线程安全，调用效率高，但是不能延时加载，单例未使用的时候便创建完成，可能造成资源浪费。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton1 instance = <span class="keyword">new</span> Singleton1();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 线程安全，调用效率不高，但是能延时加载，线程安全通过synchronized实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton2 instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton2 <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton2();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 双重校验锁，线程安全，延迟加载。</span></span><br><span class="line"><span class="comment">// instance = new Singleton3(); 分为三个过程。</span></span><br><span class="line"><span class="comment">// 1. 为instance分配内存空间</span></span><br><span class="line"><span class="comment">// 2. 初始化instance</span></span><br><span class="line"><span class="comment">// 3. 将instance指向分配的内存空间</span></span><br><span class="line"><span class="comment">// 变量如果没有声明成volatile，多线程下会导致一个线程获得一个未初始化的实例。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton3 instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton3<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton3();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 静态内部类可以不依赖外部类的实例而被实例化。只有调用getSingleton()才进行初始化。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton4</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton4 instance = <span class="keyword">new</span> Singleton4();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton4 <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Inner.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
<hr>
<h3 id="4-集合框架"><a href="#4-集合框架" class="headerlink" title="4. 集合框架"></a>4. 集合框架</h3><ol>
<li><p><strong>ArrayList的扩容机制？</strong></p>
<blockquote>
<p>ArrayList扩容发生在add()方法调用的时候，下面是add()方法的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//扩容</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ArrayList扩容的关键方法grow():</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 获取到ArrayList中elementData数组的内存空间长度</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// 扩容至原来的1.5倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 再判断一下新数组的容量够不够，够了就直接使用这个长度创建新数组，</span></span><br><span class="line">    <span class="comment">// 不够就将数组长度设置为需要的长度</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    	newCapacity = minCapacity;</span><br><span class="line">    	<span class="comment">//若预设值大于默认的最大值检查是否溢出</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// 调用Arrays.copyOf方法将elementData数组指向新的内存空间时newCapacity的连续空间</span></span><br><span class="line">    <span class="comment">// 并将elementData的数据复制到新的内存空间</span></span><br><span class="line">     elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</p>
<p>oldCapacity &gt;&gt; 1  右移运算符  原来长度的一半 再加上原长度也就是每次扩容是原来的1.5倍</p>
<p>之前的所有都是确定新数组的长度，确定之后就是把老数组copy到新数组中，这样数组的扩容就结束了</p>
<p>以上的一切都是ArrayList扩容的第一步，第二步就没啥说的了，就是把需要添加的元素添加到数组的最后一位</p>
</blockquote>
</li>
<li><p><strong>HashMap 的底层实现、JDK 1.8 的时候为啥将链表转换成红黑树？HashMap 的负载因子、HashMap 和 Hashtable 的区别？HashMap如何实现扩容？</strong></p>
<blockquote>
<p><strong>HashMap是用数组+链表+红黑树进行实现的，当添加一个元素（key-value）时，就首先计算元素key的hash值，并根据hash值来确定插入数组中的位置，但是可能存在其他元素已经被放在数组同一位置了，这个时候便使用链表来解决哈希冲突，当链表长度太长的时候，便将链表转换为红黑树来提高搜索的效率。</strong></p>
<p>HashMap是基于拉链法实现的一个散列表，内部由数组和链表和红黑树实现。</p>
<ol>
<li>数组的初始容量为16，而容量是以2的次方扩充的，一是为了提高性能使用足够大的数组，二是为了能使用位运算代替取模预算。</li>
<li>数组是否需要扩充是通过负载因子判断的，如果当前元素个数为数组容量的0.75时，就会扩充数组。这个0.75就是默认的负载因子，可由构造传入。</li>
<li>为了解决碰撞，数组中的元素是单向链表类型。当链表长度到达一个阈值时（&gt;=8），会将链表转换成红黑树提高性能。而当链表长度缩小到另一个阈值时（&lt;=6），又会将红黑树转换回单向链表提高性能，这里是一个平衡点。</li>
</ol>
<p>当个数不多的时候，直接链表遍历更方便，实现起来也简单。而红黑树的实现要复杂的多。</p>
</blockquote>
</li>
<li><p><strong>ConcurrentHashMap的底层实现。</strong></p>
<blockquote>
<p>底层数据结构： JDK1.7的 ConcurrentHashMap 底层采用 分段的数组+链表 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</p>
<p>实现线程安全的方式（重要）：<br>① 在JDK1.7的时候，ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。(TreeBin: 红黑二叉树节点 Node: 链表节点)</p>
<p>② Hashtable(同一把锁) :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</p>
</blockquote>
<blockquote>
<p><strong>为什么 ConcurrentHashMap 的读操作不需要加锁？</strong></p>
<blockquote>
<p>ConcurrentHashMap 在jdk1.7中是采用Segment + HashEntry + ReentrantLock的方式进行实现的，而1.8中放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现。</p>
<p>总结：定义成volatile的变量，能够在线程之间保持可见性，能够被多线程同时读，而不会读到过期的值。由于get操作中只需要读不需要写共享变量，所以可以不用加锁。之所以不会读到过期的值，依据Java内存模型的happen before原则，对volatile字段的写入操作先于读操作，get总能拿到最新的值。</p>
<ul>
<li>get操作全程不需要加锁是因为Node的成员val是用volatile修饰的和数组用volatile修饰没有关系。</li>
<li>数组用volatile修饰主要是保证在数组扩容的时候保证可见性。</li>
</ul>
</blockquote>
</blockquote>
<blockquote>
<p><strong>HashMap，LinkedHashMap，TreeMap 有什么区别？HashMap ，TreeMap，LinkedHashMap 使用场景？</strong></p>
<p>LinkedHashMap 保存了记录的插入顺序，在用 Iterator 遍历时，先取到的记录肯定是先插入的；遍历比 HashMap 慢；</p>
<p>TreeMap 实现 SortMap 接口，能够把它保存的记录根据键排序（默认按键值升序排序，也可以指定排序的比较器）</p>
<p>一般情况下，使用最多的是 HashMap。</p>
<p>HashMap：在 Map 中插入、删除和定位元素时；</p>
<p>TreeMap：在需要按自然顺序或自定义顺序遍历键的情况下；</p>
<p>LinkedHashMap：在需要输出的顺序和输入的顺序相同的情况下。</p>
</blockquote>
</li>
<li><p><strong>有哪些集合是线程不安全的，又有哪些集合是线程不安全的？怎么解决呢？</strong></p>
<blockquote>
<p><strong>线程安全的集合类</strong></p>
<p>Vector</p>
<p>Stack</p>
<p>Hashtable</p>
<p>java.util.concurrent包下所有的集合类（ConcurrentHashMap，CopyOnWriteArrayList和CopyOnWriteArraySet等）</p>
</blockquote>
</li>
<li><p><strong>什么是快速失败(fail-fast)、能举个例子吗？什么是安全失败(fail-safe)呢？</strong></p>
<blockquote>
<p><strong>快速失败(fail-fast)</strong></p>
<p>快速失败(fail-fast)是 Java 集合的一种<strong>错误检测机制</strong>。<strong>在使用迭代器对集合进行遍历的时候</strong>，我们在多线程下操作非安全失败(fail-safe)的集合类可能就会触发 fail-fast 机制，导致抛出 <code>ConcurrentModificationException</code> 异常。另外，在单线程下，如果在遍历过程中对集合对象的内容进行了修改的话也会触发 fail-fast 机制。</p>
<p>举个例子：多线程下，如果线程 1 正在对集合进行遍历，此时线程 2 对集合进行修改（增加、删除、修改），或者线程 1 在遍历过程中对集合进行修改，都会导致线程 1 抛出 <code>ConcurrentModificationException</code> 异常。</p>
<p><strong>安全失败(fail-safe)</strong></p>
<p>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是<strong>先复制原有集合内容，在拷贝的集合上进行遍历</strong>。所以，在遍历过程中对原集合所作的修改并不能被迭代器检测到，故不会抛 <code>ConcurrentModificationException</code> 异常。</p>
</blockquote>
</li>
<li><p><strong>HashMap 多线程操作导致死循环问题</strong></p>
<blockquote>
<p>主要原因在于并发下的 rehash 会造成元素之间会形成一个循环链表。不过，jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用 HashMap，因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失。</p>
</blockquote>
</li>
</ol>
<hr>
<h3 id="5-多线程"><a href="#5-多线程" class="headerlink" title="5. 多线程"></a>5. 多线程</h3><ol>
<li><p><strong>Java 怎么实现线程？</strong></p>
<blockquote>
<p>① 继承 Thread 类并重写 <code>run</code> 方法。实现简单，但不符合里氏替换原则，不可以继承其他类。</p>
<p>② 实现 Runnable 接口并重写 <code>run</code> 方法。避免了单继承局限性，实现解耦。</p>
<p>③实现 Callable 接口并重写 <code>call</code> 方法。可以获取线程执行结果的返回值，并且可以抛出异常。</p>
</blockquote>
</li>
<li><p><strong>Java 线程通信的方式？</strong></p>
<blockquote>
<p>Java 采用共享内存模型，线程间的通信总是隐式进行，整个通信过程对程序员完全透明。</p>
<p>volatile 告知程序任何对变量的读需要从主内存中获取，写必须同步刷新回主内存，保证所有线程对变量访问的可见性。</p>
<p>synchronized 确保多个线程在同一时刻只能有一个处于方法或同步块中，保证线程对变量访问的原子性、可见性和有序性。</p>
<p>等待通知机制指一个线程 A 调用了对象的 <code>wait</code> 方法进入等待状态，另一线程 B 调用了对象的 <code>notify/notifyAll</code> 方法，线程 A 收到通知后结束阻塞并执行后序操作。对象上的 <code>wait</code> 和 <code>notify/notifyAll</code> 完成等待方和通知方的交互。</p>
<p>如果一个线程执行了某个线程的 <code>join</code> 方法，这个线程就会阻塞等待执行了 <code>join</code> 方法的线程终止，这里涉及等待/通知机制。<code>join</code> 底层通过 <code>wait</code> 实现，线程终止时会调用自身的 <code>notifyAll</code> 方法，通知所有等待在该线程对象上的线程。</p>
<p>管道 IO 流用于线程间数据传输，媒介为内存。PipedOutputStream 和 PipedWriter 是输出流，相当于生产者，PipedInputStream 和 PipedReader 是输入流，相当于消费者。管道流使用一个默认大小为 1KB 的循环缓冲数组。输入流从缓冲数组读数据，输出流往缓冲数组中写数据。当数组已满时，输出流所在线程阻塞；当数组首次为空时，输入流所在线程阻塞。</p>
<p>ThreadLocal 是线程共享变量，但它可以为每个线程创建单独的副本，副本值是线程私有的，互相之间不影响。</p>
</blockquote>
</li>
<li><p><strong>在多线程情况下如何保证线程安全</strong>。</p>
</li>
<li><p><strong>写一个死锁的例子</strong></p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> flag = <span class="number">1</span>;  </span><br><span class="line">    <span class="comment">//静态对象是类的所有对象共享的  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object o1 = <span class="keyword">new</span> Object(), o2 = <span class="keyword">new</span> Object();  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"flag="</span> + flag);  </span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;  </span><br><span class="line">            <span class="keyword">synchronized</span> (o1) &#123;  </span><br><span class="line">                <span class="keyword">try</span> &#123;  </span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);  </span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">                    e.printStackTrace();  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">synchronized</span> (o2) &#123;  </span><br><span class="line">                    System.out.println(<span class="string">"1"</span>);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="keyword">synchronized</span> (o2) &#123;  </span><br><span class="line">                <span class="keyword">try</span> &#123;  </span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);  </span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">                    e.printStackTrace();  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">synchronized</span> (o1) &#123;  </span><br><span class="line">                    System.out.println(<span class="string">"0"</span>);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">          </span><br><span class="line">        DeadLock td1 = <span class="keyword">new</span> DeadLock();  </span><br><span class="line">        DeadLock td2 = <span class="keyword">new</span> DeadLock();  </span><br><span class="line">        td1.flag = <span class="number">1</span>;  </span><br><span class="line">        td2.flag = <span class="number">0</span>;  </span><br><span class="line">        <span class="comment">//td1,td2都处于可执行状态，但JVM线程调度先执行哪个线程是不确定的。  </span></span><br><span class="line">        <span class="comment">//td2的run()可能在td1的run()之前运行  </span></span><br><span class="line">        <span class="keyword">new</span> Thread(td1).start();  </span><br><span class="line">        <span class="keyword">new</span> Thread(td2).start();  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>讲一下volatile关键字的作用。</strong></p>
<blockquote>
<ol>
<li><strong>保证了不同线程对该变量操作的内存可见性。</strong></li>
<li><strong>禁止指令重排序。</strong></li>
</ol>
</blockquote>
<blockquote>
<p><strong>当写一个volatile变量时，JMM将本地内存更改的变量写回到主内存中。</strong></p>
<p><strong>当取一个volatile变量时，JMM将使线程对应的本地内存失效，然后线程将从主内存读取共享变量。</strong></p>
<p>volatile 可以保证线程可见性且提供了一定的有序性，但是无法保证原子性。在 JVM 底层是基于内存屏障实现的。</p>
<ul>
<li>当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到 CPU 缓存中。如果计算机有多个CPU，每个线程可能在不同的 CPU 上被处理，这意味着每个线程可以拷贝到不同的本地内存中。</li>
<li>而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过本地内存这一步，所以就不会有可见性问题<ul>
<li><strong>对 volatile 变量进行写操作时，会在写操作后加一条 store 屏障指令，将工作内存中的共享变量刷新回主内存；</strong></li>
<li><strong>对 volatile 变量进行读操作时，会在读操作前加一条 load 屏障指令，从主内存中读取共享变量；</strong></li>
</ul>
</li>
</ul>
<p><strong>volatile可以通过内存屏障防止指令重排序问题。硬件层面的内存屏障分为读屏障和写屏障。</strong></p>
<p><strong>对于读屏障来说，在指令前插入读屏障，可以让高速缓存中的数据失效，强制重新从主内存加载数据。</strong><br><strong>对于写屏障来说，在指令后插入写屏障，能让写入缓存中的最新数据更新写入主内存，让其他线程可见。</strong></p>
</blockquote>
</li>
<li><p><strong>synchronized 作用，讲一讲底层实现。</strong></p>
<blockquote>
<p>synchronized关键字解决的是多个线程之间访问资源的同步性，调用操作系统内核态做同步，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p>
<p>在 Java 早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</p>
</blockquote>
<blockquote>
<p><strong>synchronized关键字最主要的三种使用方式：</strong></p>
<ul>
<li><strong>修饰实例方法:</strong> 作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁</li>
<li><strong>修饰静态方法:</strong> 也就是给当前类加锁，会作用于类的所有对象实例。因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。</li>
<li><strong>修饰代码块:</strong> 指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>synchronized 关键字底层原理属于 JVM 层面。</strong></p>
<p><strong>① synchronized 同步语句块的情况</strong>：<strong>synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。</strong></p>
<p><strong>② synchronized 修饰方法的的情况</strong>：<strong>JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</strong></p>
</blockquote>
</li>
<li><p><strong>ReetrantLock 和 synchronized 的区别</strong></p>
</li>
<li><p><strong>说说 synchronized 关键字和 volatile 关键字的区别</strong></p>
<blockquote>
<ul>
<li><strong>volatile关键字</strong>是线程同步的<strong>轻量级实现</strong>，所以<strong>volatile性能肯定比synchronized关键字要好</strong>。但是<strong>volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块</strong>。synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，<strong>实际开发中使用 synchronized 关键字的场景还是更多一些</strong>。</li>
<li><strong>多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞</strong></li>
<li><strong>volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。</strong></li>
<li><strong>volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性。</strong></li>
</ul>
</blockquote>
</li>
<li><p><strong>ReetrantLock实现方式</strong></p>
<blockquote>
<p>锁的获取过程：</p>
<ol>
<li><p>通过cas操作来修改state状态，表示争抢锁的操作，如果能够获取到锁，设置当前获得锁状态的线程。compareAndSetState(0, 1)</p>
</li>
<li><p>如果没有获取到锁，尝试去获取锁。acquire(1)。</p>
<p>（1）通过tryAcquire尝试获取独占锁，如果成功返回true，失败返回false。如果是同一个线程来获得锁，则直接增加重入次数，并返回true。</p>
<p>（2）如果tryAcquire失败，则会通过addWaiter方法将当前线程封装成Node，添加到AQS队列尾部</p>
<p>（3）acquireQueued，将Node作为参数，通过自旋去尝试获取锁。（如果前驱为head才有资格进行锁的抢夺。）</p>
<p>（4）如果获取锁失败，则挂起线程。</p>
</li>
</ol>
</blockquote>
<blockquote>
<p>锁的释放过程：</p>
<ol>
<li>释放锁。</li>
<li>如果锁能够被其他线程获取，唤醒后继节点中的线程。一般情况下只要唤醒后继结点的线程就行了，但是后继结点可能已经取消等待，所以从队列尾部往前回溯，找到离头结点最近的正常结点，并唤醒其线程。</li>
</ol>
</blockquote>
<blockquote>
<p>在获得同步锁时，同步器维护一个同步队列，获取状态失败的线程都会被加入到队列中并在队列中进行自旋；移出队列（或停止自旋）的条件是前驱节点为头节点且成功获取了同步状态。在释放同步状态时，同步器调用tryRelease(int arg)方法释放同步状态，然后唤醒头节点的后继节点。</p>
</blockquote>
</li>
<li><p><strong>AQS原理</strong></p>
<blockquote>
<p><strong>AQS是一个用来构建锁和同步器的框架</strong>。AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就<strong>需要一套线程阻塞等待以及被唤醒时锁分配的机制</strong>，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</p>
<p>CLH队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node）来实现锁的分配。</p>
<p>AQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。AQS使用CAS对该同步状态进行原子操作实现对其值的修改。</p>
<p>状态信息通过protected类型的getState，setState，compareAndSetState进行操作。</p>
<p><strong>AQS定义两种资源共享方式</strong></p>
<p>Exclusive（独占）：只有一个线程能执行，如ReentrantLock。又可分为公平锁和非公平锁：</p>
<p>Share（共享）：多个线程可同时执行。</p>
</blockquote>
<blockquote>
<p>以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。</p>
<p>再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS(Compare and Swap)减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。</p>
</blockquote>
</li>
<li><p><strong>interrupt，interrupted与isInterrupted方法的区别? 如何停止一个正在运行的线程</strong></p>
<blockquote>
<p>（1）interrupt()方法的作用实际上是：在线程受到阻塞时抛出一个中断信号，这样线程就得以退出阻塞状态。</p>
<p>（2）interrupted()调用的是currentThread().isInterrupted(true)方法，即说明是返回当前线程的是否已经中断的状态值，而且有清理中断状态的机制。</p>
<p>测试当前线程是否已经中断，线程的中断状态由该方法清除。即如果连续两次调用该方法，则第二次调用将返回false（在第一次调用已清除flag后以及第二次调用检查中断状态之前，当前线程再次中断的情况除外）所以，interrupted()方法具有清除状态flag的功能</p>
<p>（3）isInterrupted()调用的是isInterrupted(false)方法，意思是返回线程是否已经中断的状态，它没有清理中断状态的机制。</p>
</blockquote>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread())</span><br><span class="line">        checkAccess();</span><br><span class="line">    <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">        Interruptible b = blocker;</span><br><span class="line">        <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">            interrupt0();        <span class="comment">// Just to set the interrupt flag</span></span><br><span class="line">            b.interrupt(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interrupt0();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>interrupt()</strong> <strong>方法用于中断线程。调用该方法的线程的状态为将被置为”中断”状态。</strong><br><strong>中断可以理解为线程的一个标识位属性，它表示一个运行中的线程是否被其他线程进行了中断操作。中断好比其他线程对该线程打了个招呼，其他线程通过调用该线程的interrupt()方法对其进行中断操作。</strong><br>注意：<strong>线程中断仅仅是置线程的中断状态位，不会停止线程。需要用户自己去监视线程的状态为并做处理。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static boolean interrupted() &#123;</span><br><span class="line">    return currentThread().isInterrupted(true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>interrupted()</strong> 检测当前线程是否已经中断，是则返回true，否则false，并清除中断状态。换言之，如果该方法被连续调用两次，第二次必将返回false，除非在第一次与第二次的瞬间线程再次被中断。如果中断调用时线程已经不处于活动状态，则返回false。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean isInterrupted() &#123;</span><br><span class="line">    return isInterrupted(false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>isInterrupted()</strong> 检测当前线程是否已经中断，是则返回true，否则false。中断状态不受该方法的影响。如果中断调用时线程已经不处于活动状态，则返回false。</p>
</blockquote>
<blockquote>
<p><strong>在java中有以下3种方法可以终止正在运行的线程：</strong></p>
<ul>
<li>使用stop方法强行终止，但是不推荐这个方法，因为stop和suspend及resume一样都是过期作废的方法</li>
<li>使用interrupt()方法中断线程</li>
</ul>
</blockquote>
</li>
<li><p><strong>线程池作用？Java 线程池有哪些参数？阻塞队列有几种？拒绝策略有几种？线程池的工作机制？（非大厂会问：有哪些线程池）</strong></p>
<blockquote>
<ul>
<li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源,还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>线程池通过 ThreadPoolExecutor 的方式进程创建</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                           TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                           BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                           ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                           RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure>

<p><strong><code>ThreadPoolExecutor</code> 3 个最重要的参数：</strong></p>
<ul>
<li><strong><code>corePoolSize</code> :</strong> 核心线程数线程数定义了最小可以同时运行的线程数量。</li>
<li><strong><code>maximumPoolSize</code> :</strong> 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li>
<li><strong><code>workQueue</code>:</strong> 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li>
</ul>
<p><code>ThreadPoolExecutor</code>其他常见参数:</p>
<ol>
<li><strong><code>keepAliveTime</code></strong>:当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li>
<li><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</li>
<li><strong><code>threadFactory</code></strong> :executor 创建新线程的时候会用到。</li>
<li><strong><code>handler</code></strong> :饱和策略。关于饱和策略下面单独介绍一下。</li>
</ol>
</blockquote>
<blockquote>
<p><strong>阻塞队列有几种</strong></p>
<p>用来保存等待被执行的任务的阻塞队列，且任务必须实现Runable接口，在JDK中提供了如下阻塞队列：</p>
<p>1、ArrayBlockingQueue（有界队列）：基于数组结构的有界阻塞队列，按FIFO排序任务；</p>
<p>2、LinkedBlockingQuene（有/无界队列（基于链表的，传参就是有界，不传就是无界）：基于链表结构的阻塞队列，按FIFO排序任务，吞吐量通常要高于ArrayBlockingQuene；</p>
<p>3、SynchronousQuene（同步移交队列（需要一个线程调用put方法插入值，另一个线程调用take方法删除值））：一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene；</p>
<p>4、PriorityBlockingQuene（具有优先级的、无限阻塞队列）：具有优先级的无界阻塞队列；</p>
</blockquote>
<blockquote>
<p><strong><code>ThreadPoolExecutor</code> 饱和策略定义:</strong></p>
<p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任时，<code>ThreadPoolTaskExecutor</code> 定义一些策略:</p>
<ul>
<li><strong><code>ThreadPoolExecutor.AbortPolicy</code></strong>：抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li>
<li><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code></strong>：调用执行自己的线程运行任务。也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li>
<li><strong><code>ThreadPoolExecutor.DiscardPolicy</code>：</strong> 不处理新任务，直接丢弃掉。</li>
<li><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：</strong> 此策略将丢弃最早的未处理的任务请求。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>线程池的工作过程</strong></p>
<ol>
<li><p>提交任务后，线程池先判断线程数是否达到了核心线程数（corePoolSize）。如果未达到线程数，则创建核心线程处理任务；否则，就执行下一步；</p>
</li>
<li><p>接着线程池判断任务队列是否满了。如果没满，则将任务添加到任务队列中；否则，执行下一步；</p>
</li>
<li><p>接着因为任务队列满了，线程池就判断线程数是否达到了最大线程数。如果未达到，则创建非核心线程处理任务；否则，就执行饱和策略，默认会抛出RejectedExecutionException异常。</p>
</li>
</ol>
</blockquote>
<blockquote>
<p><strong>常见线程池</strong></p>
<ol>
<li><p>newFixedThreadPool：最大线程和核心线程一致，用的是LinkedBlockingQueue，无限容量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>newSingleThreadExecutor：最大线程和核心线程一致，用的是LinkedBlockingQueue，无限容量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>newCachedThreadPool：没有核心线程,直接向 SynchronousQueue 中提交任务，如果有空闲线程，就去取出任务执行。如果没有空闲线程，就新建一个。执行完任务的线程有 60 秒生存时间，如果在这个时间内可以接到新任务，才可以存活下去。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>newScheduledThreadPool：核心线程和最大线程都有，采用DelayedWorkQueue 队列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DEFAULT_KEEPALIVE_MILLIS = <span class="number">10L</span>;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</blockquote>
</li>
<li><p><strong>线程池拒绝策略分别使用在什么场景?</strong></p>
<blockquote>
<ol>
<li><p>AbortPolicy中止策略：丢弃任务并抛出RejectedExecutionException异常。</p>
<p>使用场景：这个就没有特殊的场景了，但是有一点要正确处理抛出的异常。当自己自定义线程池实例时，使用这个策略一定要处理好触发策略时抛的异常，因为他会打断当前的执行流程。</p>
</li>
<li><p>DiscardPolicy丢弃策略：ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常。如果线程队列已满，则后续提交的任务都会被丢弃，且是静默丢弃。</p>
<p>使用场景：如果你提交的任务无关紧要，你就可以使用它 。</p>
</li>
<li><p>DiscardOldestPolicy弃老策略：丢弃队列最前面的任务，然后重新提交被拒绝的任务。</p>
<p>使用场景：这个策略还是会丢弃任务，丢弃时也是毫无声息，但是特点是丢弃的是老的未执行的任务，而且是待执行优先级较高的任务。基于这个特性，能想到的场景就是，发布消息和修改消息，当消息发布出去后，还未执行，此时更新的消息又来了，这个时候未执行的消息的版本比现在提交的消息版本要低就可以被丢弃了。</p>
</li>
<li><p>CallerRunsPolicy调用者运行策略：由调用线程处理该任务。</p>
<p>使用场景：一般在不允许失败的、对性能要求不高、并发量较小的场景下使用。</p>
</li>
</ol>
</blockquote>
</li>
<li><p><strong>线程死锁，解除线程死锁有哪几种方式？(两次栽倒这题上了，时间太久又忘记了，如何解决很重要)</strong></p>
<blockquote>
<p>线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p>
</blockquote>
<blockquote>
<p>如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Tyk3dODBkz5r5bJNlGsiaZZMwtRYk40nToD1zpdfevdj6AoHqU9UGE0M53DxU9rCuItuuObElMSGKQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p><strong>解决死锁的策略</strong></p>
<ul>
<li>死锁预防</li>
<li>死锁避免</li>
<li>死锁检测</li>
<li>死锁解除</li>
</ul>
<ol>
<li><strong>死锁预防：</strong> 破坏导致死锁必要条件中的任意一个就可以预防死锁。<br>（1）<strong>破坏占有和等待条件：</strong> 一次性申请所有资源，之后不再申请资源，如果不满足资源条件则得不到资源分配。<br>（2）<strong>破坏不可剥夺条件：</strong> 当一个进程获得某个不可剥夺的资源时，提出新的资源申请，若不满足，则释放所有资源。<br>（3）<strong>破坏循环等待条件：</strong> 按某一顺序申请资源，释放资源则反序释放。</li>
<li><strong>死锁避免：</strong> 进程在每次申请资源时判断这些操作是否安全。</li>
<li><strong>死锁检测：</strong> 判断系统是否属于死锁的状态，如果是，则执行死锁解除策略。</li>
<li><strong>死锁解除：</strong> 将某进程所占资源进行强制回收，然后分配给其他进程。（与死锁检测结合使用的）</li>
</ol>
</blockquote>
</li>
<li><p><strong>ThreadLocal 是什么，应用场景是什么，原理是怎样的？</strong></p>
<blockquote>
<p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。<strong>如果想实现每一个线程都有自己的专属本地变量该如何解决呢？</strong> JDK 中提供的<code>ThreadLocal</code>类正是为了解决这样的问题。<strong><code>ThreadLocal</code>类主要解决的就是让每个线程绑定自己的值，可以将<code>ThreadLocal</code>类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</strong></p>
<p><strong>如果你创建了一个<code>ThreadLocal</code>变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是<code>ThreadLocal</code>变量名的由来。他们可以使用 <code>get()</code> 和 <code>set()</code>方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</strong></p>
<p><strong><code>ThreadLocal</code>最终的变量是放在了当前线程的 <code>ThreadLocalMap</code> 中，并不是存在 <code>ThreadLocal</code> 上，<code>ThreadLocal</code> 可以理解为只是<code>ThreadLocalMap</code>的封装，传递了变量值。</strong> 我们可以把 <code>ThreadLocalMap</code> 理解为<code>ThreadLocal</code> 类实现的定制化的 <code>HashMap</code>。<code>ThrealLocal</code> 类中可以通过<code>Thread.currentThread()</code>获取到当前线程对象后，直接通过<code>getMap(Thread t)</code>可以访问到该线程的<code>ThreadLocalMap</code>对象。</p>
<p><strong>每个<code>Thread</code>中都具备一个<code>ThreadLocalMap</code>，而<code>ThreadLocalMap</code>可以存储以<code>ThreadLocal</code>为 key ，Object 对象为 value 的键值对。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如我们在同一个线程中声明了两个 <code>ThreadLocal</code> 对象的话，会使用 <code>Thread</code>内部都是使用仅有那个<code>ThreadLocalMap</code> 存放数据的，<code>ThreadLocalMap</code>的 key 就是 <code>ThreadLocal</code>对象，value 就是 <code>ThreadLocal</code> 对象调用<code>set</code>方法设置的值。</p>
</blockquote>
</li>
<li><p><strong>ThreadLocal类为什么要加上private static修饰</strong>？</p>
<blockquote>
<p>首先，private修饰与ThreadLocal本身没有关系，private更多是在安全方面进行考虑。static修饰这个变量，这个变量是针对一个线程内所有操作共享的，所以设置为静态变量，所有此类实例共享此静态变量，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象(只要是这个线程内定义的)都可以操控这个变量。（设置为static可以避免每个线程从任务队列中获取task后重复创建ThreadLocal所关联的对象）</p>
<p><strong>可以解决内存泄露问题（看下一问）。</strong></p>
</blockquote>
</li>
<li><p><strong>ThreadLocal 有什么缺陷？如果线程池的线程使用ThreadLocal 会有什么问题？</strong></p>
<blockquote>
<p><code>采用线性探测的方式</code>。ThreadLocalMap如何解决冲突？</p>
</blockquote>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line">ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用,而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，<code>ThreadLocalMap</code> 中就会出现key为null的Entry。假如我们不做任何措施的话，value 永远无法被GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后 最好手动调用<code>remove()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">	<span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">	Object value;</span><br><span class="line">	Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">		<span class="keyword">super</span>(k);</span><br><span class="line">		value = v;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在ThreadLocalMap中，也是用Entry来保存K-V结构数据的。但是Entry中key只能是ThreadLocal对象，这点被Entry的构造方法已经限定死了。<strong>Entry继承自WeakReference（<code>弱引用，生命周期只能存活到下次GC前</code>），但只有Key是弱引用类型的，Value并非弱引用。</strong>由于ThreadLocalMap的key是弱引用，而Value是强引用。这就导致了一个问题，ThreadLocal在没有外部对象强引用时，<strong>发生GC时弱引用Key会被回收，而Value不会回收</strong>。当线程没有结束，但是ThreadLocal已经被回收，则可能导致线程中存在ThreadLocalMap&lt;null, Object&gt;的键值对，<strong>造成内存泄露。</strong>（<code>ThreadLocal被回收，ThreadLocal关联的线程共享变量还存在</code>）。</p>
</blockquote>
<blockquote>
<p>为了防止此类情况的出现，我们有两种手段。</p>
<ul>
<li>1、使用完线程共享变量后，显示调用ThreadLocalMap.remove()方法清除线程共享变量；</li>
</ul>
<p>既然Key是弱引用，那么我们要做的事，就是在调用ThreadLocal的get()、set()方法时完成后再<strong>调用remove方法，将Entry节点和Map的引用关系移除</strong>，这样整个Entry对象在GC Roots分析后就变成不可达了，下次GC的时候就可以被回收。</p>
<ul>
<li>2、JDK建议ThreadLocal定义为private static，这样ThreadLocal的弱引用问题则不存在了。</li>
</ul>
</blockquote>
</li>
<li><p><strong>介绍一下 Java 有哪些锁</strong></p>
<p>(synchronized、juc 提供的锁如 ReentrantLock、CountDownLatch、CyclicBarrier、Semaphore等)</p>
<blockquote>
<ul>
<li>公平锁/非公平锁 (重要)</li>
<li>可重入锁</li>
<li>独享锁/共享锁 (重要)</li>
<li>互斥锁/读写锁</li>
<li>乐观锁/悲观锁 (重要)</li>
<li>偏向锁/轻量级锁/重量级锁 (重要)</li>
<li>自旋锁</li>
</ul>
</blockquote>
<blockquote>
<ol>
<li><p>公平锁/非公平锁</p>
<p>公平锁是指多个线程按照申请锁的顺序来获取锁。<br>非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。</p>
<p>对于Java ReentrantLock而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。对于Synchronized而言，也是一种非公平锁。由于其并不像ReentrantLock是通过AQS的来实现线程调度，所以并没有任何办法使其变成公平锁。</p>
</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li><p>可重入锁</p>
<p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。</p>
<p>对于Java ReentrantLock而言，是一个可重入锁，其名字是Re entrant Lock重新进入锁。<br>对于Synchronized而言，也是一个可重入锁。可重入锁的一个好处是可一定程度避免死锁。</p>
</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li><p>独享锁/共享锁 (互斥锁/读写锁)</p>
<p>独享锁是指该锁一次只能被一个线程所持有。<br>共享锁是指该锁可被多个线程所持有。</p>
<p>对于Java ReentrantLock而言，其是独享锁。但是对于Lock的另一个实现类ReadWriteLock，其读锁是共享锁，其写锁是独享锁。</p>
<p>上面讲的独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。</p>
<p>互斥锁在Java中的具体实现就是ReentrantLock<br>读写锁在Java中的具体实现就是ReadWriteLock</p>
</li>
</ol>
</blockquote>
<blockquote>
<ol start="4">
<li><p>乐观锁/悲观锁</p>
<p>乐观锁与悲观锁不是指具体的什么类型的锁，而是指<strong>看待并发同步的角度</strong>。</p>
<p>对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。<br>乐观锁在更新数据的时候，主要就是两个步骤：冲突检测和数据更新。乐观的认为，不加锁的并发操作是没有事情的。当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，<strong>失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</strong></p>
<p>从上面的描述我们可以看出，悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。<br>悲观锁在Java中的使用，就是利用各种锁。<br>乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。</p>
<blockquote>
<p>CAS包含三个参数 CAS（V,E,N）。V表示要更新的变量，E表示预期的值，N表示新值。仅当要更新的变量值等于预期的值时，才会将要更新的变量值的值设置成新值，否则什么都不做。</p>
</blockquote>
</li>
</ol>
</blockquote>
<blockquote>
<ol start="5">
<li><p>偏向锁/轻量级锁/重量级锁</p>
<p>这三种锁是指锁的状态，并且是针对Synchronized。</p>
<p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。<br>轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。<br>重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。</p>
</li>
</ol>
</blockquote>
<blockquote>
<ol start="6">
<li><p>自旋锁</p>
<p>自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。</p>
</li>
</ol>
</blockquote>
</li>
<li><p><strong>乐观锁和悲观锁讲一下，哪些地方用到。</strong></p>
<blockquote>
<p>乐观锁与悲观锁不是指具体的什么类型的锁，而是指<strong>看待并发同步的角度</strong>。<br>悲观锁对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。<br>乐观锁在更新数据的时候，会采用尝试更新，不断重试的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。</p>
<p><strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>，传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁，数据库的for update SQL语句。Java中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p>
<p><strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>。在Java中<code>java.util.concurrent.atomic</code>包下面的原子变量类就是使用了乐观锁的一种实现方式<strong>CAS</strong>实现的。</p>
<p><strong>乐观锁适用于写比较少的情况下（多读场景）</strong>，<strong>一般多写的场景下用悲观锁就比较合适</strong>，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能。</p>
</blockquote>
</li>
</ol>
<hr>
<h3 id="6-JVM"><a href="#6-JVM" class="headerlink" title="6. JVM"></a>6. JVM</h3><ol>
<li><p><strong>讲一下 JVM 的内存结构</strong></p>
<blockquote>
<p>堆，方法区(元空间)，程序计数器，虚拟机栈，本地方法栈。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">堆设置</span><br><span class="line">-Xms:初始堆大小</span><br><span class="line">-Xmx:最大堆大小</span><br><span class="line">-Xmn:新生代堆最大可用值</span><br><span class="line">-XX:PermSize：表示非堆区初始内存分配大小，其缩写为permanent size（持久化内存）</span><br><span class="line">-XX:MaxPermSize：表示对非堆区分配的内存的最大上限。</span><br><span class="line">备注：在Java8中永久代的参数-XX:PermSize 和-XX：MaxPermSize已经失效。</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Minor gc 和 Full gc 的区别，详细介绍。</strong></p>
<blockquote>
<p>针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：</p>
<p>部分收集 (Partial GC)：</p>
<ul>
<li>新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；</li>
<li>老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</li>
<li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li>
</ul>
<p>整堆收集 (Full GC)：收集整个 Java 堆和方法区。</p>
<p>minor GC、major GC和full GC。对新生代进行垃圾回收叫做minor GC，对老年代进行垃圾回收叫做major GC，同时对新生代、老年代和永久代进行垃圾回收叫做full GC，Full GC 一般消耗的时间比较长，远远大于Minor GC，因此，有时候我们必须降低Full GC 发生的频率。</p>
<p>许多major GC是由minor GC触发的，所以很难将这两种垃圾回收区分开。Major GC通常是跟Full GC是等价的，收集整个GC堆。</p>
</blockquote>
<blockquote>
<p>触发条件：</p>
<ul>
<li><p>Minor GC：新生代中的eden区域分配满了的时候触发。Minor GC后新生代中有部分存活对象会晋升到老年代中，所以老年代的占用量会提高。</p>
</li>
<li><p>Full GC：</p>
<p>（1）<strong>调用 System.gc()</strong></p>
<p>（2）<strong>老年代空间不足</strong>：晋升进入老年代的对象大小大于老年代的可用内存，这个时候会触发Full GC。</p>
<p>（3）<strong>Metaspace区内存达到阈值</strong>：从JDK8开始，永久代(PermGen)的概念被废弃掉了，取而代之的是一个称为Metaspace的存储空间。Metaspace使用的是本地内存，而不是堆内存，也就是说在默认情况下Metaspace的大小只与本地内存大小有关。</p>
<p>（4）<strong>统计得到的Minor GC晋升到老年代的平均大小大于老年代的剩余空间</strong>：当准备触发一次Minor GC的时候，如果发现统计数据说之前Minor GC的平均晋升大小比目前老年代的空间大，则不会触发Minor GC，转而触发Major GC。</p>
<p>（5）<strong>老年代连续空间不足</strong>：JVM如果判断老年代没有做足够的连续空间来放置大对象，那么就会引起Full GC。</p>
<p>（6）<strong>CMS GC时出现promotion failed和concurrent mode failure</strong>：执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。（美团三面时问过，问的是浮动垃圾是什么？导致老年代空间不足会发生什么？还是要灵活应变，差点不记得了）</p>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>方法区和永久代的关系？</strong></p>
<blockquote>
<p>方法区也被称为永久代。<strong>方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。</strong>方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现。</p>
</blockquote>
</li>
<li><p><strong>JDK 1.8 HotSpot 的永久代为啥被彻底移除？有哪些常用参数？</strong></p>
<blockquote>
<p>JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-XX:MetaspaceSize=N //设置 Metaspace 的初始（和最小大小）</span><br><span class="line">-XX:MaxMetaspaceSize=N //设置 Metaspace 的最大大小</span><br></pre></td></tr></table></figure>

<p><strong>为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?</strong></p>
<p>(1) 整个永久代有一个 JVM 本身设置固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。</p>
<p>你可以使用 <code>-XX：MaxMetaspaceSize</code> 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。<code>-XX：MetaspaceSize</code> 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。</p>
<p>(2) 元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 <code>MaxPermSize</code> 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。(永久代的调优是很困难的，虽然可以设置永久代的大小，但是很难确定一个合适的大小)</p>
</blockquote>
</li>
<li><p><strong>主要进行 gc 的区域。永久代会发生 gc 吗？元空间呢？</strong></p>
<blockquote>
<p>主要进行 gc 的区域是堆，就 HotSpot 虚拟机来说，永久代会发生 gc (full gc)，但是，元空间使用的是直接内存不会发生 gc。</p>
</blockquote>
</li>
<li><p><strong>各种垃圾回收算法和回收器，说出自己的理解。</strong></p>
<blockquote>
<p><strong>垃圾回收算法</strong>：标记-清除，标记-整理，复制，分代收集。</p>
<p><strong>垃圾回收器</strong>：新生代垃圾收集器：Serial，ParNew，Parallel Scanvenge。</p>
<p>老年代垃圾收集器：CMS，Serial Old，Parallel Old。</p>
<p>整堆收集器：G1；</p>
<p>除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。</p>
</blockquote>
<blockquote>
<p><strong>Serial</strong>：新生代，复制算法，单线程收集，必须暂停所有工作线程，直到完成。</p>
<p><strong>ParNew</strong>： ParNew垃圾收集器是Serial收集器的多线程版本。</p>
<p><strong>Parallel Scavenge</strong>：高吞吐量为目标，即减少垃圾收集时间，让用户代码获得更长的运行时间。</p>
<p><strong>Serial Old</strong>：Serial收集器的老年代版本，采用”标记-整理”算法。</p>
<p><strong>Parallel Old</strong>：Parallel Old垃圾收集器是Parallel Scavenge收集器的老年代版本。采用”标记-整理”算法。</p>
<p><strong>CMS</strong>：CMS 收集器是一种 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p>
<ol>
<li><strong>初始标记</strong>：仅标记一下GC Roots能直接关联到的对象；2. <strong>并发标记</strong>：进行 GC Roots Tracing 的过程，也就是从GC Roots开始找到它能引用的所有其它对象。3. <strong>重新标记</strong>：修正并发标记期间因用户程序继续运作而导致标记变动的那一部分对象的标记记录。4. <strong>并发清除</strong>：回收所有的垃圾对象， 开启用户线程， GC 线程开始对<strong>未标记</strong>的区域做清扫。</li>
</ol>
<ul>
<li>并发阶段占用cpu资源，拖慢用户程序，降低吞吐量，CMS默认启用（CPU + 3)/4个线程执行。</li>
<li>无法处理浮动垃圾，并发清理阶段用户程序产生的垃圾，成为浮动垃圾，无法被当次处理。</li>
<li>基于标记-清除算法的CMS，会使老年代产生很多空间碎片，不利于大对象的使用</li>
</ul>
<p><strong>G1</strong>：G1 可以直接对新生代和老年代一起回收。G1 把堆划分成多个大小相等的独立区域，维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 区域。</p>
<ol>
<li>初始标记。2. 并发标记。3. 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录。4. 筛选回收：首先对各个区域中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。</li>
</ol>
</blockquote>
<blockquote>
<p>G1收集器的设计目标是取代CMS收集器，它同CMS相比，在以下方面表现的更出色：</p>
<ul>
<li>G1是一个有<strong>整理内存</strong>过程的垃圾收集器，<strong>不会产生很多内存碎片</strong>。</li>
<li>CMS采用的是标记清除垃圾回收算法，可能会产生不少的内存碎片。</li>
<li>G1的Stop The World(STW)更可控，G1在停顿时间上添加了<strong>预测机制</strong>，用户可以<strong>指定期望停顿时间</strong>。</li>
</ul>
</blockquote>
</li>
<li><p><strong>zgc ？zgc vs g1？（我懵逼了~我只是听过有这个东西，完全没有去了解过）</strong></p>
<blockquote>
<p>ZGC适用于大内存低延迟服务的内存管理和回收。</p>
<p>ZGC：JDK11 中加入的具有实验性质的低延迟垃圾收集器，目标是尽可能在不影响吞吐量的前提下，实现在任意堆内存大小都可以把停顿时间限制在 10ms 以内的低延迟。基于 Region 内存布局，不设分代，使用了读屏障、染色指针和内存多重映射等技术实现可并发的标记整理。ZGC 的 Region 具有动态性，是动态创建和销毁的，并且容量大小也是动态变化的。</p>
</blockquote>
</li>
<li><p><strong>如何对进行性能分析？会用到哪些命令？</strong></p>
<blockquote>
<p><strong>top</strong>：查看当前所有进程的使用情况，CPU占有率，内存使用情况，服务器负载状态等参数。</p>
<p><strong>jps</strong>：列出正在运行的虚拟机进程。</p>
<p><strong>jstat</strong>：可以用来监视虚拟机各种运行状态信息（堆和非堆的大小及其内存使用量）。</p>
<p><strong>jstack</strong>：生成虚拟机当前时刻的线程快照。</p>
<p><strong>jinfo</strong>：可以查看虚拟机的各项参数。</p>
<p><strong>jmap：</strong>：生成堆转储快照，查看内存占用情况。</p>
<p><strong>jconsole</strong>：一个java GUI监视工具，可以以图表化的形式显示各种数据。并可通过远程连接监视远程的服务器的jvm进程。</p>
</blockquote>
</li>
</ol>
<hr>
<h3 id="7-数据库"><a href="#7-数据库" class="headerlink" title="7. 数据库"></a>7. 数据库</h3><ol>
<li><p><strong>数据库三大范式</strong></p>
<blockquote>
<p>第一范式：每个列都不可以再拆分。</p>
<p>第二范式：在第一范式的基础上，非主属性完全依赖于主键。</p>
<p>第三范式：在第二范式的基础上，非主属性只依赖于主键，不存在传递依赖。</p>
</blockquote>
</li>
<li><p><strong>关系型数据库和非关系型数据库的区别？</strong></p>
<blockquote>
<p>关系型数据库最典型的数据结构是表，由二维表及其之间的联系所组成的一个数据组织。</p>
<p>非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合，可以是文档或者键值对等。</p>
</blockquote>
</li>
<li><p><strong>char和varchar的区别</strong></p>
<blockquote>
<ol>
<li>char是固定长度，varchar长度可变。varchar：<strong>如果原先存储的位置无法满足其存储的需求</strong>，就需要一些额外的操作，根据存储引擎的不同，有的会采用<strong>拆分机制</strong>，有的采用<strong>分页机制</strong>。</li>
<li>char和varchar的存储字节由<strong>具体的字符集</strong>来决定;</li>
<li>char是固定长度，长度不够的情况下，用空格代替。varchar表示的是实际长度的数据类型</li>
</ol>
</blockquote>
</li>
<li><p><strong>内连接、左连接和外连接？</strong></p>
<blockquote>
<p>左外连接    以左表为主表，可以查询左表存在而右表为 null 的记录。          </p>
<p>右外连接    以右表为主表，可以查询右表存在而左表为 null 的记录。          </p>
<p>内连接    查询左右表同时满足条件的记录，两边都不可为 null。</p>
</blockquote>
</li>
<li><p><strong>MySQL 有哪些聚合函数？</strong></p>
<blockquote>
<p>① max 求最大值。② min 求最小值。③ count 统计数量。④ avg 求平均值。⑤ sum 求和。</p>
</blockquote>
</li>
<li><p><strong>说一下 MVCC</strong></p>
<blockquote>
<p>MVCC就是多版本并发控制。MVCC解决的问题是读写互相不阻塞的问题，每次更新都产生一个新的版本，读的话可以读历史版本。MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问。MVCC是行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只锁定必要的行。</p>
<p>在Mysql的InnoDB引擎中就是指在读已提交(READ COMMITTD)和可重复读(REPEATABLE READ)这两种隔离级别下的事务对于SELECT操作会访问版本链中的记录的过程。</p>
<p>这就使得别的事务可以修改这条记录，反正每次修改都会在版本链中记录。SELECT可以去版本链中拿记录，这就实现了读-写，写-读的并发执行，提升了系统的性能。 InnoDB只查找版本(DB_TRX_ID)早于当前事务版本的数据行。</p>
<blockquote>
<p><strong>版本链</strong></p>
<p>在InnoDB引擎表中，它的聚簇索引记录中有两个必要的隐藏列：</p>
<p><strong>trx_id</strong>这个id用来存储的每次对某条聚簇索引记录进行修改的时候的事务id。</p>
<p><strong>roll_pointer</strong>每次<strong>对哪条聚簇索引记录有修改的时候</strong>，都会<strong>把老版本写入undo log中</strong>。这个roll_pointer就是存了一个指针，它<strong>指向这条聚簇索引记录的上一个版本的位置</strong>，通过它来获得上一个版本的记录信息。</p>
</blockquote>
</blockquote>
</li>
<li><p><strong>为什么要使用索引？</strong></p>
<blockquote>
<ol>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>
<li>可以大大加快 数据的检索速度（大大减少的检索的数据量）, 这也是创建索引的最主要的原因。</li>
<li>帮助服务器避免排序和临时表。</li>
<li>将随机IO变为顺序IO。</li>
<li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</li>
</ol>
</blockquote>
</li>
<li><p><strong>数据库原理相关补充</strong></p>
<blockquote>
<p>局部性原理与磁盘预读 由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中。</p>
<p>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。</p>
<p>预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页的大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p>
<p>先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：</p>
<p>每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</p>
<p>B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。</p>
<p>而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。</p>
<p>综上所述，用B-Tree作为索引结构效率是非常高的。</p>
</blockquote>
</li>
<li><p><strong>说一聚簇索引和非聚簇索引的有什么不同</strong>?</p>
<blockquote>
<p><strong>1. 聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。</strong></p>
<p>优点：聚集索引的查询速度非常的快，因为整个B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。</p>
<p>缺点：1. 依赖于有序的数据，不是有序的数据的话，插入或查找的速度肯定比较慢。2. 更新代价大。</p>
</blockquote>
<blockquote>
<p><strong>2. 非聚集索引即索引结构和数据分开存放的索引。叶子节点存的是键值和数据所在物理地址</strong></p>
<p>优点：更新代价比聚集索引要小 。</p>
<p>缺点：1. 依赖于有序的数据，不是有序的数据的话，插入或查找的速度肯定比较慢。2. 可能会二次查询(回表)，当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</p>
</blockquote>
</li>
<li><p><strong>关于索引的各种轰炸。Mysql的索引，以及B+树与hash索引的区别，为什么不采用B树而采用B+树？B树和B+树的区别</strong></p>
<blockquote>
<p>B+树：非叶子节点不存储data，只存储索引，这样可以放更多的索引，data只存在叶子节点，这样到达叶子节点的路径查询长度都一样，使用b+树索引更加稳定。叶子节点用双向指针连接，提高区间访问的性能。B+ 树索引，底层是多路查询平衡树，节点是天然有序的（左节点小于服节点，右节点大于父节点），所以对于范围查找的时候不需要做全表扫描；</p>
<p>hash索引：底层是哈希表，数据存储在哈希表中顺序是没有关联的，所以他不适合范围查找，如果要范围查找就需要全表扫描，他只适合全值扫描；简单的来说就是hash索引适合等值查找，不适合范围查找。</p>
</blockquote>
<blockquote>
<p>MySQL索引使用的数据结构主要有<strong>BTree索引</strong> 和 <strong>哈希索引</strong> 。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。</p>
</blockquote>
<blockquote>
<p>MySQL的BTree索引使用的是B树中的B+Tree，但对于主要的两种存储引擎的实现方式是不同的。</p>
<ul>
<li><strong>MyISAM:</strong> B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。</li>
<li><strong>InnoDB:</strong> 其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”。而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。<strong>在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。</strong> <strong>因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</strong></li>
</ul>
</blockquote>
</li>
<li><p><strong>红黑树和B+树的使用场景？</strong></p>
<blockquote>
<p>红黑树和B树应用场景有何不同？<br>2者都是有序数据结构，可用作数据容器。红黑树多用在内部排序，即全放在内存中的。B树多用在内存里放不下，大部分数据存储在外存上时。因为B树层数少，因此可以确保每次操作，读取磁盘的次数尽可能的少。<br>在数据较小，可以完全放到内存中时，红黑树的时间复杂度比B树低。反之，数据量较大，外存中占主要部分时，B树因其读磁盘次数少，而具有更快的速度。</p>
</blockquote>
<blockquote>
<p>分析数据结构问题的时候，权衡三个因素: 查找速度，数据量，内存使用。</p>
<p>B树(B+树)相对于平衡二叉树的不同是，每个节点包含的关键字增多了，特别是在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把节点大小限制和充分使用在磁盘块大小范围；把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度;</p>
</blockquote>
</li>
<li><p><strong>B+比B树更适合实际应用中操作系统的文件索引和数据库索引？</strong></p>
<blockquote>
<p>1) B+树的磁盘读写代价更低</p>
<p>B+的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</p>
<p>2) B+tree的查询效率更加稳定</p>
<p>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p>
<p>3）B树只适合随机检索，而B+树同时支持随机检索和顺序检索；</p>
<p>4）增删文件时，效率更高。因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率。</p>
</blockquote>
<blockquote>
<p>B+树的叶子节点有一条链相连，而B树的叶子节点各自独立。</p>
<p>由于B+树的内部节点只存放键，不存放值，因此，一次读取，可以在内存页中获取更多的键，有利于更快地缩小查找范围。B+树的叶节点由一条链相连，因此，当需要进行一次全数据遍历的时候，B+树只需要使用O(logN)时间找到最小的一个节点，然后通过链进行O(N)的顺序遍历即可。而B树则需要对树的每一层进行遍历，这会需要更多的内存置换次数，因此也就需要花费更多的时间</p>
</blockquote>
</li>
<li><p><strong>非聚簇索引一定会回表查询吗？</strong></p>
<blockquote>
<p>不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。</p>
</blockquote>
</li>
<li><p><strong>MySql的存储引擎，以及InnoDB和MyISAM的区别？</strong></p>
<blockquote>
<p>存储引擎: InnoDB和MyISAM</p>
<ol>
<li><strong>是否支持行级锁</strong> : MyISAM 只有表级锁(table-level locking)，而InnoDB 支持行级锁(row-level locking)和表级锁，默认为行级锁。</li>
<li><strong>是否支持事务和崩溃后的安全恢复： MyISAM</strong> 强调的是性能，每次查询具有原子性,其执行速度比InnoDB类型更快，但是不提供事务支持。但是<strong>InnoDB</strong> 提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</li>
<li><strong>是否支持外键：</strong> MyISAM不支持，而InnoDB支持。</li>
<li><strong>是否支持MVCC</strong> ：仅 InnoDB 支持。应对高并发事务，MVCC比单纯的加锁更高效；MVCC只在 <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 两个隔离级别下工作；MVCC可以使用 乐观锁和悲观锁来实现；各数据库中MVCC实现并不统一。</li>
</ol>
</blockquote>
</li>
<li><p><strong>Mysql联合索引的最左匹配原则。给出联合索引(a,b)，select *from table where a&gt;0 and b&gt;0，是否走索引，哪个走索引，哪个不走，以及从联合索引的底层结构去解释为什么？</strong>（字段a走索引，字段b不走索引）</p>
<blockquote>
<p>联合索引即由多列属性组成索引。</p>
<p>当B+树的数据项是复合的数据结构，比如(num,name,age)的时候，B+数是按照从左到右的顺序来建立搜索树的，B+树会<strong>优先比较num来确定下一步的所搜方向</strong>，如果num相同再依次比较name和age，最后得到检索的数据；</p>
<p>范围查询列可以使用索引（前提必须满足最左前缀），范围列后面的列无法使用索引。同时，索引最多作用于一个范围列。</p>
</blockquote>
</li>
<li><p><strong>讲一下最左前缀原则？</strong></p>
<blockquote>
<p>最左前缀原则是发生在复合索引上的，只有复合索引才会有所谓的左和右之分。当查询条件精确匹配左边连续一个或多个列时，索引可以被使用。</p>
<p>假设创建的联合索引由三个字段组成:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE table ADD INDEX index_name (num,name,age)</span><br></pre></td></tr></table></figure>

<p>那么当查询的条件有为:num / (num AND name) / (num AND name AND age)时，索引才生效。所以在创建联合索引时，尽量把查询最频繁的那个字段作为最左(第一个)字段。查询的时候也尽量以这个字段为第一条件。</p>
</blockquote>
</li>
<li><p><strong>left join，right join，inner join，full join之间的区别</strong></p>
<blockquote>
<ol>
<li>inner join，在两张表进行连接查询时，只保留两张表中完全匹配的结果集。</li>
<li>left join，在两张表进行连接查询时，会返回左表所有的行，即使在右表中没有匹配的记录。</li>
<li>right join，在两张表进行连接查询时，会返回右表所有的行，即使在左表中没有匹配的记录。</li>
<li>full join，在两张表进行连接查询时，返回左表和右表中所有没有匹配的行。</li>
</ol>
<p>在 <code>join</code> 的过程中，其实就是从驱动表里面依次(注意理解这里面的依次)取出每一个值，然后去非驱动表里面进行匹配。</p>
</blockquote>
</li>
<li><p><strong>为什么InnoDB表必须有主键，并且推荐使用整形的自增主键？</strong></p>
<blockquote>
<p>因为叶子节点是按顺序排列的，如果是非自增的话，就会插入的时候频繁的分裂页（效率降低）</p>
<p>1、如果设置了主键，那么InnoDB会选择主键作为聚集索引、如果没有显式定义主键，则InnoDB会选择第一个不包含有NULL值的唯一索引作为主键索引、如果也没有这样的唯一索引，则InnoDB会选择内置6字节长的ROWID作为隐含的聚集索引(ROWID随着行记录的写入而主键递增)。</p>
<p>2、如果表使用自增主键<br>那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，主键的顺序按照数据记录的插入顺序排列，自动有序。当一页写满，就会自动开辟一个新的页</p>
<p>3、如果使用非自增主键（如果身份证号或学号等）<br>由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置，此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</p>
</blockquote>
</li>
<li><p><strong>间隙锁讲解一下</strong>？</p>
<blockquote>
<p>for update是在数据库中上锁用的，可以为数据库中的行上一个排它锁。当一个事务的操作未完成时候，其他事务可以读取但是不能写入或更新。for update 仅适用于InnoDB，并且必须开启事务，在begin与commit之间才生效。</p>
<p>InnoDB默认是行级别的锁，当有明确指定的主键时候（且主键存在），是行级锁。否则是表级别。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> foods <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> foods <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">and</span> <span class="keyword">name</span>=’咖啡色的羊驼’ <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>间隙锁的目的是为了防止幻读，其主要通过两个方面实现这个目的：<br>（1）防止间隙内有新数据被插入<br>（2）防止已存在的数据，更新成间隙内的数据</p>
<p>innodb自动使用间隙锁的条件：</p>
<p>（1）必须在可重复读级别下<br>（2）检索条件必须有索引</p>
<p>next-key锁其实包含了记录锁和间隙锁，即锁定一个范围，并且锁定记录本身，InnoDB默认加锁方式是next-key 锁。</p>
</blockquote>
</li>
<li><p><strong>数据库问题，说一下从你打开命令行到发送请求，mysql服务器的整个相应流程? (当问到需要介绍数据库底层时可以这样回答)</strong></p>
<blockquote>
<ul>
<li>MySQL 主要分为 Server 层和引擎层。</li>
<li>Server 层主要包括连接器、查询缓存、分析器、优化器、执行器，同时还有一个日志模块（binlog），这个日志模块所有执行引擎都可以共用, redolog 只有 InnoDB 有。</li>
<li>引擎层是插件式的，目前主要包括，MyISAM,InnoDB,Memory 等。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><strong>连接器：</strong> 身份认证和权限相关(登录 MySQL 的时候)。</li>
<li><strong>查询缓存:</strong> 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。</li>
<li><strong>分析器:</strong> 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。先词法分析，再语法分析</li>
<li><strong>优化器：</strong> 按照 MySQL 认为最优的方案去执行。</li>
<li><strong>执行器:</strong> 执行语句，然后从存储引擎返回数据。</li>
</ul>
</blockquote>
<blockquote>
<p>查询语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from tb_student  A where A.age=&apos;18&apos; and A.name=&apos; 张三 &apos;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>先检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限，在 MySQL8.0 版本以前，会先查询缓存，以这条 sql 语句为 key 在内存中查询是否有结果，如果有直接缓存，如果没有，执行下一步。</p>
</li>
<li><p>通过分析器进行词法分析，提取 sql 语句的关键元素，比如提取上面这个语句是查询 select，提取需要查询的表名为 tb_student,需要查询所有的列，查询条件是这个表的 id=’1’。然后判断这个 sql 语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步。</p>
</li>
<li><p>接下来就是优化器进行确定执行方案，上面的 sql 语句，可以有两种执行方案：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a.先查询学生表中姓名为“张三”的学生，然后判断是否年龄是 18。</span><br><span class="line">b.先找出学生中年龄 18 岁的学生，然后再查询姓名为“张三”的学生。</span><br></pre></td></tr></table></figure>

<p>那么优化器根据自己的优化算法进行选择执行效率最好的一个方案（优化器认为，有时候不一定最好）。那么确认了执行计划后就准备开始执行了。</p>
</li>
<li><p>进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。</p>
</li>
</ul>
</blockquote>
<blockquote>
<p>更新语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update tb_student A set A.age=&apos;19&apos; where A.name=&apos; 张三 &apos;;</span><br></pre></td></tr></table></figure>

<p>我们来给张三修改下年龄，在实际数据库肯定不会设置年龄这个字段的，不然要被技术负责人打的。其实条语句也基本上会沿着上一个查询的流程走，只不过执行更新的时候肯定要记录日志啦，这就会引入日志模块了，MySQL 自带的日志模块式 <strong>bin log（归档日志）</strong> ，所有的存储引擎都可以使用，我们常用的 InnoDB 引擎还自带了一个日志模块 <strong>redo log（重做日志）</strong>，我们就以 InnoDB 模式下来探讨这个语句的执行流程。流程如下：</p>
<ul>
<li>先查询到张三这一条数据，如果有缓存，也是会用到缓存。</li>
<li>然后拿到查询的语句，把 age 改为 19，然后调用引擎 API 接口，写入这一行数据，InnoDB 引擎把数据保存在内存中，同时记录 redo log，此时 redo log 进入 prepare 状态，然后告诉执行器，执行完成了，随时可以提交。</li>
<li>执行器收到通知后记录 binlog，然后调用引擎接口，提交 redo log 为提交状态。</li>
<li>更新完成。</li>
</ul>
<p><strong>这里肯定有同学会问，为什么要用两个日志模块，用一个日志模块不行吗?</strong></p>
<p>这是因为最开始 MySQL 并没与 InnoDB 引擎( InnoDB 引擎是其他公司以插件形式插入 MySQL 的) ，MySQL 自带的引擎是 MyISAM，但是我们知道 redo log 是 InnoDB 引擎特有的，其他存储引擎都没有，这就导致会没有 crash-safe 的能力(crash-safe 的能力即使数据库发生异常重启，之前提交的记录都不会丢失)，binlog 日志只能用来归档。</p>
<p>并不是说只用一个日志模块不可以，只是 InnoDB 引擎就是通过 redo log 来支持事务的。那么，又会有同学问，我用两个日志模块，但是不要这么复杂行不行，为什么 redo log 要引入 prepare 预提交状态？这里我们用反证法来说明下为什么要这么做？</p>
<ul>
<li><strong>先写 redo log 直接提交，然后写 binlog</strong>，假设写完 redo log 后，机器挂了，binlog 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 binlog 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。</li>
<li><strong>先写 binlog，然后写 redo log</strong>，假设写完了 bin log，机器异常重启了，由于没有 redo log，本机是无法恢复这一条记录的，但是 bin log 又有记录，那么和上面同样的道理，就会产生数据不一致的情况。</li>
</ul>
<p>如果采用 redo log 两阶段提交的方式就不一样了，写完 binglog 后，然后再提交 redo log 就会防止出现上述的问题，从而保证了数据的一致性。那么问题来了，有没有一个极端的情况呢？假设 redo log 处于预提交状态，binglog 也已经写完了，这个时候发生了异常重启会怎么样呢？ 这个就要依赖于 MySQL 的处理机制了，MySQL 的处理过程如下：</p>
<ul>
<li>判断 redo log 是否完整，如果判断是完整的，就立即提交。</li>
<li>如果 redo log 只是预提交但不是 commit 状态，这个时候就会去判断 binlog 是否完整，如果完整就提交 redo log, 不完整就回滚事务。</li>
</ul>
<p>这样就解决了数据一致性的问题。</p>
</blockquote>
<blockquote>
<ul>
<li>查询语句的执行流程如下：权限校验（如果命中缓存）–&gt; 查询缓存 –&gt; 分析器 –&gt; 优化器 –&gt; 权限校验 –&gt; 执行器 –&gt; 引擎</li>
<li>更新语句执行流程如下：分析器 –&gt; 权限校验 –&gt; 执行器 –&gt; 引擎 – redo log(prepare 状态) –&gt; binlog –&gt; redo log(commit状态)</li>
</ul>
</blockquote>
</li>
<li><p><strong>讲一下redo log，undo log，binlog？</strong></p>
<blockquote>
<p>redo Log：重做日志用来实现事务的<strong>持久性</strong>，用于记录事务操作的变化，记录的是<strong>数据修改之后的值</strong>。redo log由两部分组成：redo log buffer和redo log file。当事务提交(COMMIT)时，必须先将该事务的所有重做日志缓冲写入到重做日志文件进行持久化，才能COMMIT成功。MySQL宕机时，通过读取Redo Log中的数据，对数据库进行恢复。</p>
<p>undo Log：回滚日志用来实现事务的回滚和多版本并发控制(MVCC)。Undo Log和Redo Log正好相反，记录的是数据<strong>被修改前</strong>的信息。undo log包括：insert undo log和update undo log。</p>
<p>binlog：记录了对MySQL数据库执行更改的所有操作。</p>
</blockquote>
</li>
<li><p><strong>MySQL 的数据如何恢复到任意时间点？</strong></p>
<blockquote>
<p>恢复到任意时间点以定时的做全量备份，以及备份增量的 binlog 日志为前提。恢复到任意时间点首先将全量备份恢复之后，再此基础上回放增加的 binlog 直至指定的时间点。</p>
</blockquote>
</li>
<li><p><strong>一张数据库表如果要删除大量的数据如何提高效率，如何做？</strong></p>
<blockquote>
<p>（1）抽取需要保留的数据到备份表中；<br>（2）删除旧表数据；<br>（3）备份表中的数据再插入旧表；</p>
</blockquote>
</li>
<li><p><strong>Mysql如何保证一致性？</strong></p>
<blockquote>
<p>通过预写式日志，undo log保证原子性，redo log保证持久性，设置隔离级别，保证并发事务进行的时候，保证数据一致性。恢复机制会将redo log中已提交的事务重做，保证事务的持久性；而undo log中未提交的事务进行回滚，保证事务的原子性。</p>
</blockquote>
<blockquote>
<ul>
<li>原子性：语句要么全执行，要么全不执行，是事务最核心的特性，事务本身就是以原子性来定义的；实现主要基于undo log</li>
<li>持久性：保证事务提交后不会因为宕机等原因导致数据丢失；实现主要基于redo log</li>
<li>隔离性：保证事务执行尽可能不受其他事务影响；InnoDB默认的隔离级别是RR，RR的实现主要基于锁机制、数据的隐藏列、undo log和next-key lock机制</li>
<li>一致性：事务追求的最终目标，一致性的实现既需要数据库层面的保障，也需要应用层面的保障</li>
</ul>
</blockquote>
</li>
<li><p><strong>数据库的主从复制？</strong></p>
<blockquote>
<p>MySQL主从复制的流程</p>
<ol>
<li>主库db的更新事件(update、insert、delete)被写到binlog</li>
<li>主库创建一个dump thread，把binlog的内容发送到从库</li>
<li>从库启动并发起连接，连接到主库</li>
<li>从库启动之后，创建一个I/O线程，读取主库传过来的binlog内容并写入到relay log</li>
<li>从库启动之后，创建一个SQL线程，从relay log里面读取内容，并解析成sql语句逐一执行</li>
</ol>
</blockquote>
<blockquote>
<p><strong>MySQL主从复制是一个异步的复制过程，主库发送更新事件到从库，从库读取更新记录，并执行更新记录，使得从库的内容与主库保持一致。</strong></p>
<p><strong>主从同步过程中主服务器有一个工作线程dump thread，从服务器有两个工作线程I/O thread和SQL thread。主库把外界接收的SQL请求记录到自己的binlog日志中，从库的I/O thread去请求主库的binlog日志，并将binlog日志写到relay log(中继日志)中，然后从库重做中继日志的SQL语句。主库通过dump thread给从库I/O thread传送binlog日志。</strong></p>
</blockquote>
<blockquote>
<p>binlog：binary log，主库中保存所有更新事件日志的二进制文件。<code>binlog</code>是数据库服务启动的一刻起，保存数据库所有变更记录（数据库结构和内容）的文件。在主库中，只要有更新事件出现，就会被依次地写入到<code>binlog</code>中，之后会推送到从库中作为从库进行复制的数据源。</p>
</blockquote>
</li>
<li><p><strong>Mysq的事务隔离级别有哪几种，说一下可重复读解决了什么问题？还有什么问题没解决？幻读如何解决的？幻读的具体场景？说一下间隙锁如何实施的？</strong></p>
<blockquote>
<p>并发事务带来哪些问题?</p>
<ul>
<li><p><strong>脏读（Dirty read）:</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</p>
</li>
<li><p><strong>丢失修改（Lost to modify）:</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。</p>
</li>
<li><p><strong>不可重复读（Unrepeatableread）:</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</p>
<p>(读取数据的事务将会禁止写事务(但允许读事务)，写事务则禁止任何其他事务。Mysql默认使用该隔离级别。这可以通过“共享读锁”和“排他写锁”实现，即事物需要对某些数据进行修改必须对这些数据加 X 锁，读数据时需要加上 S 锁，当数据读取完成并不立刻释放 S 锁，而是等到事物结束后再释放)</p>
</li>
<li><p><strong>幻读（Phantom read）:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p>
</li>
</ul>
</blockquote>
<blockquote>
<p><strong>事务是逻辑上的一组操作，要么都执行，要么都不执行。</strong></p>
<ul>
<li><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</li>
<li><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</li>
<li><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</li>
<li><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</li>
</ul>
</blockquote>
<blockquote>
<p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong></p>
</blockquote>
<blockquote>
<p>InnoDB 存储引擎在 <strong>REPEATABLE-READ（可重读）</strong> 事务隔离级别下使用的是Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server) 是不同的。所以说InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong> 已经可以完全保证事务的隔离性要求，即达到了 SQL标准的 <strong>SERIALIZABLE(可串行化)</strong> 隔离级别。</p>
</blockquote>
<blockquote>
<p><strong>InnoDB存储引擎的锁的算法有三种：</strong></p>
<ul>
<li>Record lock：单个行记录上的锁</li>
<li>Gap lock：间隙锁，锁定一个范围，不包括记录本身</li>
<li>Next-key lock：record+gap 锁定一个范围，包含记录本身</li>
</ul>
</blockquote>
</li>
<li><p><strong>Mysql一条sql非常慢，如何进行分析？</strong></p>
<blockquote>
<p>分以下两种情况来讨论。</p>
<p><strong>1、大多数情况是正常的，只是偶尔会出现很慢的情况。</strong></p>
<p><strong>2、在数据量不变的情况下，这条SQL语句一直以来都执行的很慢。</strong></p>
<p><strong>第一种情况：偶尔</strong></p>
<p>（1）<strong>数据库在刷新脏页</strong>（当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。）</p>
<p>当我们要往数据库插入一条数据、或者要更新一条数据的时候，我们知道数据库会在<strong>内存</strong>中把对应字段的数据更新了，但是更新之后，这些更新的字段并不会马上同步持久化到<strong>磁盘</strong>中去，而是把这些更新的记录写入到 redo log 日记中去，等到空闲的时候，在通过 redo log 里的日记把最新的数据同步到<strong>磁盘</strong>中去。（<strong>如果redo log写满了，这个时候就没办法等到空闲的时候再把数据同步到磁盘的，只能暂停其他操作，全身心来把数据同步到磁盘中去的，而这个时候，</strong>就会导致我们平时正常的SQL语句突然执行的很慢）</p>
<p>（2）<strong>拿不到锁，所要执行的语句涉及到了别人对表或行加的锁</strong></p>
<p><strong>第二种情况：一直</strong></p>
<p>（1）<strong>所要查询的字段没有索引（全表扫描）</strong></p>
<p>（2）<strong>字段有索引，但却没有用索引，由于对字段进行运算、函数操作导致无法用索引。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from t where c - 1 = 1000;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from t where pow(c,2) = 1000;</span><br></pre></td></tr></table></figure>

<p>（4）<strong>数据库选错了索引（主要在回表查询的时候，二次查询可能导致，由于统计的失误，导致系统没有走索引，而是走了全表扫描</strong>）</p>
</blockquote>
</li>
</ol>
<hr>
<h3 id="8-Redis"><a href="#8-Redis" class="headerlink" title="8. Redis"></a>8. Redis</h3><ol>
<li><p><strong>Redis介绍</strong></p>
<blockquote>
<p>Redis 就是一个内存数据库。<strong>Redis 除了做缓存之外，Redis 也经常用来做分布式锁，甚至是消息队列。</strong></p>
<p>Redis 提供了多种数据类型来支持不同的业务场景。Redis 还支持事务 、持久化、Lua 脚本、多种集群方案。</p>
<ul>
<li>完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。</li>
<li>数据结构简单，对数据操作也简单，<strong>Redis</strong>中的数据结构是专门进行设计的；</li>
<li>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 <strong>CPU</strong>，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</li>
<li>使用多路I/O复用模型，非阻塞IO；</li>
</ul>
</blockquote>
</li>
<li><p><strong>Redis的原子性？</strong></p>
<blockquote>
<p>Redis所有单个命令的执行都是原子性的，这与它的单线程机制有关；<br><strong>对Redis来说，执行get、set以及eval等API，都是一个一个的任务，这些任务都会由Redis的线程去负责执行，任务要么执行成功，要么执行失败，这就是Redis的命令是原子性的原因。</strong></p>
</blockquote>
</li>
<li><p><strong>为什么要用缓存(Redis)？</strong></p>
<blockquote>
<p><strong>高性能</strong></p>
<p>假如用户第一次访问数据库中的某些数据的话，这个过程是比较慢，毕竟是从硬盘中读取的。但是，如果说，用户访问的数据属于高频数据并且不会经常改变的话，那么我们就可以很放心地将该用户访问的数据存在缓存中。</p>
<p><strong>这样有什么好处呢？</strong> 那就是保证用户下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。</p>
<p>不过，要保持数据库和缓存中的数据的一致性。 如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</p>
</blockquote>
<blockquote>
<p><strong>高并发</strong></p>
<p>直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。进而，我们也就提高的系统整体的并发。</p>
</blockquote>
</li>
<li><p><strong>Redis的单线程理解</strong></p>
<blockquote>
<p>其中执行命令阶段，由于Redis是单线程来处理命令的，所有到达服务端的命令都不会立刻执行，所有的命令都会进入一个队列中，然后逐个执行，并且多个客户端发送的命令的执行顺序是不确定的，但是可以确定的是不会有两条命令被同时执行，不会产生并发问题，这就是Redis的单线程基本模型。</p>
<p><strong>Redis基于Reactor模式开发了自己的网络事件处理模型——文件事件处理器，由于文件事件处理器是单线程方式运行的，所以我们一般都说 Redis 是单线程模型。文件事件处理器使用I/O多路复用程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</strong></p>
<p>I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗。</p>
</blockquote>
<blockquote>
<p>文件事件处理器（file event handler）主要是包含 4 个部分：</p>
<ul>
<li>多个 socket（客户端连接）</li>
<li>IO 多路复用程序（支持多个客户端连接的关键）</li>
<li>文件事件分派器（将 socket 关联到相应的事件处理器）</li>
<li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li>
</ul>
</blockquote>
<blockquote>
<p>Reactor模式</p>
<p>Reactor模式(反应器模式)是一种处理一个或多个客户端并发交付服务请求的事件设计模式。当请求抵达后，服务处理程序使用I/O多路复用策略，然后同步地派发这些请求至相关的请求处理程序。</p>
</blockquote>
<blockquote>
<p>Redis是单线程，快的原因：</p>
<p> 1）完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是O(1)；</p>
<p> 2）数据结构简单，对数据操作也简单，Redis 中的数据结构是专门进行设计的；</p>
<p> 3）采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</p>
<p> 4）使用多路 I/O 复用模型，非阻塞 IO；</p>
<p> 5）使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis 直接自己构建了 VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</p>
</blockquote>
</li>
<li><p><strong>Redis主从复制</strong></p>
<blockquote>
<p> 1、redis的复制功能是支持多个数据库之间的数据同步。一类是主数据库（master）一类是从数据库（slave），主数据库可以进行读写操作，当发生写操作的时候自动将数据同步到从数据库，而从数据库一般是只读的，并接收主数据库同步过来的数据，一个主数据库可以有多个从数据库，而一个从数据库只能有一个主数据库。</p>
<p> 2、通过redis的复制功能可以很好的实现数据库的读写分离，提高服务器的负载能力。主数据库主要进行写操作，而从数据库负责读操作。</p>
</blockquote>
<blockquote>
<p><strong>过程：（同步和命令传播）</strong></p>
<p><strong>1：当一个从数据库启动时，会向主数据库发送sync命令。</strong></p>
<p><strong>2：主数据库接收到sync命令后会开始一个线程并在后台保存快照（执行rdb操作），并将保存期间接收到的命令缓存起来。</strong></p>
<p><strong>3：当快照完成后，redis会将快照文件和所有缓存的命令发送给从数据库。</strong></p>
<p><strong>4：从数据库收到后，会载入快照文件并执行收到的缓存的命令。</strong></p>
<p><strong>Redis2.8之后支持完整重同步和部分重同步。</strong></p>
</blockquote>
<blockquote>
<p><strong>SYNC 命令</strong></p>
<p>每次执行 <code>SYNC</code> 命令，主从服务器需要执行如下动作：</p>
<ol>
<li><strong>主服务器</strong> 需要执行 <code>BGSAVE</code> 命令来生成 RDB 文件，这个生成操作会 <strong>消耗</strong> 主服务器大量的 <strong>CPU、内存和磁盘 I/O 的资源</strong>；</li>
<li><strong>主服务器</strong> 需要将自己生成的 RDB 文件 发送给从服务器，这个发送操作会 <strong>消耗</strong> 主服务器 <strong>大量的网络资源</strong>，并对主服务器响应命令请求的时间产生影响；</li>
<li>接收到 RDB 文件的 <strong>从服务器</strong> 需要载入主服务器发来的 RBD 文件，并且在载入期间，从服务器 <strong>会因为阻塞而没办法处理命令请求</strong>；</li>
</ol>
<p>特别是当出现 <strong>断线重复制</strong> 的情况是时，为了让从服务器补足断线时确实的那一小部分数据，却要执行一次如此耗资源的 <code>SYNC</code> 命令，显然是不合理的。</p>
<p><strong>PSYNC 命令的引入</strong></p>
<p>所以在 <strong>Redis 2.8</strong> 中引入了 <code>PSYNC</code> 命令来代替 <code>SYNC</code>，它具有两种模式：</p>
<ol>
<li><strong>全量复制：</strong> 用于初次复制或其他无法进行部分复制的情况，将主节点中的所有数据都发送给从节点，是一个非常重型的操作；</li>
<li><strong>部分复制：</strong> 用于网络中断等情况后的复制，只将 <strong>中断期间主节点执行的写命令</strong> 发送给从节点，与全量复制相比更加高效。<strong>需要注意</strong> 的是，如果网络中断时间过长，导致主节点没有能够完整地保存中断期间执行的写命令，则无法进行部分复制，仍使用全量复制；</li>
</ol>
<p>部分复制的原理主要是靠主从节点分别维护一个 <strong>复制偏移量</strong>，有了这个偏移量之后断线重连之后一比较，之后就可以仅仅把从服务器断线之后确实的这部分数据给补回来了。</p>
</blockquote>
</li>
<li><p><strong>Redis如何保证高可用？</strong></p>
<blockquote>
<p>Redis保证高可用主要通过哨兵模式进行实现。他提供了对master的监控和故障转移，当master节点出现故障后，可以自动通过选举选出一台slave做master，且哨兵之间也可以做集群部署，相互监测。防止单个哨兵死掉的情况。</p>
</blockquote>
</li>
<li><p><strong>redis的5种数据结构，redis的zset底层用的什么数据结构？跳表。介绍一下、画一下基本结构，搜索插入数据过程，时间复杂度。</strong></p>
<blockquote>
<p><strong>Redis</strong> 有 5 种基础数据结构，它们分别是：<strong>string(字符串)</strong>、<strong>list(列表)</strong>、<strong>hash(字典)</strong>、<strong>set(集合)</strong> 和 <strong>zset(有序集合)</strong>。</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">存储值</th>
<th align="center">应用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center">String</td>
<td align="center">字符串、整数、浮点数</td>
<td align="center">简单的键值对缓存</td>
</tr>
<tr>
<td align="center">List</td>
<td align="center">列表</td>
<td align="center">存储列表型数据结构，例如：评论列表、商品列表</td>
</tr>
<tr>
<td align="center">Set</td>
<td align="center">无序集合</td>
<td align="center">适合交集、并集、查集操作，例如朋友关系</td>
</tr>
<tr>
<td align="center">Zset</td>
<td align="center">有序集合</td>
<td align="center">去重后排序，适合排名场景</td>
</tr>
<tr>
<td align="center">Hash</td>
<td align="center">哈希</td>
<td align="center">结构化数据，比如存储对象</td>
</tr>
</tbody></table>
</blockquote>
<blockquote>
<p><strong>string</strong></p>
<p>Redis 底层对于字符串的定义SDS实现</p>
<p>分别需要记录已使用字节的长度len，记录当前字节数组总共分配的字节数量alloc，字节数组</p>
<p>优点：</p>
<ol>
<li><strong>获取字符串长度为 O(1) 级别的操作</strong></li>
<li>杜绝 <strong>缓冲区溢出/内存泄漏</strong> 的问题</li>
<li>保证二进制安全</li>
</ol>
</blockquote>
<blockquote>
<p><strong>hash</strong></p>
<p>Redis 中的字典相当于 Java 中的 <strong>HashMap</strong>，内部实现也差不多类似，都是通过 <strong>“数组 + 链表”</strong> 的链地址法来解决部分 <strong>哈希冲突</strong>，同时这样的结构也吸收了两种不同数据结构的优点。</p>
<p><strong>实际上字典结构的内部包含两个 hashtable</strong>，通常情况下只有一个 hashtable 是有值的，但是在字典扩容缩容时，需要分配新的 hashtable，然后进行 <strong>渐进式搬迁</strong></p>
<p>渐进式 rehash 会在 rehash 的同时，保留新旧两个 hash 结构，如上图所示，查询时会同时查询两个 hash 结构，然后在后续的定时任务以及 hash 操作指令中，循序渐进的把旧字典的内容迁移到新字典中。当搬迁完成了，就会使用新的 hash 结构取而代之。</p>
</blockquote>
<blockquote>
<p><strong>zset</strong></p>
<p>zset的编码有<strong>ziplist（压缩链表）</strong>和<strong>skiplist（跳表）</strong>两种。</p>
<p>内部编码：① ziplist（key &lt;= 128 且 member &lt;= 64B）。② skiplist（key &gt; 128 或 member &gt; 64B）。</p>
<p><strong>ziplist（压缩链表）</strong></p>
<p>当zset满足以下两个条件的时候，使用ziplist：</p>
<blockquote>
<ol>
<li>保存的元素少于128个</li>
<li>保存的所有元素大小都小于64字节</li>
</ol>
</blockquote>
<p>ziplist 是由一系列特殊编码的<strong>连续内存块组成的顺序型数据结构</strong>。<strong>压缩列表节点组成</strong>：previous_entry_length表示前一个节点的长度，如果长度能够使用1个字节保存，则就使用一个字节保存，否则使用5个字节保存（第一个字节会被填充为全1）；encoding表示当前节点数据的类型和长度。content表示节点数据，可以是一个字节数组或者整数。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14654442-9a02fb2da5d9072e.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/14654442-dacfa515b14caabf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/498/format/webp" alt="img"></p>
<p><strong>skiplist（跳表）</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span>&#123;</span></span><br><span class="line">     <span class="comment">//跳跃表</span></span><br><span class="line">     zskiplist *zsl;</span><br><span class="line">     <span class="comment">//字典</span></span><br><span class="line">     dict *dice;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure>

<p>skiplist编码的有序集合底层是一个命名为zset的结构体，而一个zset结构同时包含一个字典和一个跳跃表。跳跃表按score从小到大保存所有集合元素。而字典则保存着从member到score的映射，这样就可以用O(1)的复杂度来查找member对应的score值。虽然同时使用两种结构，但它们会通过指针来共享相同元素的member和score，因此不会浪费额外的内存。</p>
<p>假如我们单独使用字典，虽然能以 O(1) 的时间复杂度查找成员的分值，但是因为字典是以无序的方式来保存集合元素，所以每次进行范围操作的时候都要进行排序；假如我们单独使用跳跃表来实现，虽然能执行范围操作，但是查找操作有 O(1)的复杂度变为了O(logN)。因此Redis使用了两种数据结构来共同实现有序集合。</p>
<p>跳表的产生就是为了解决链表过长的问题，通过增加链表的多级索引来加快原始链表的查询效率。这样的方式可以让查询的时间复杂度从O(n)提升至O(logn)。<strong>最低层的链表维护了跳表内所有的元素，每上面一层链表都是下面一层的子集</strong>。</p>
<p>跳表内的所有链表的元素都是排序的。查找时，可以从顶级链表开始找。一旦发现被查找的元素大于当前链表中的取值，就会转入下一层链表继续找。这也就是说在查找过程中，搜索是跳跃式的。</p>
<ul>
<li>backward字段是指向链表前一个节点的指针。只有第1层链表是一个双向链表。</li>
<li>level[]存放指向各层链表后一个节点的指针。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ZSETs use a specialized version of Skiplists */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// value</span></span><br><span class="line">    sds ele;</span><br><span class="line">    <span class="comment">// 分值</span></span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="comment">// 层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="comment">// 跨度</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="comment">// 跳跃表头指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="comment">// 表中节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line">    <span class="comment">// 表中层数最大的节点的层数</span></span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/beba612e-dc5b-4fc2-869d-0b23408ac90a.png" width="600px"/> </div><br>
</blockquote>
</li>
<li><p><strong>redis为什么使用跳表而不是用红黑树？</strong></p>
<blockquote>
<ol>
<li><strong>在做范围查找的时候，平衡树比skiplist操作要复杂。</strong>在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。</li>
<li><strong>平衡树的插入和删除操作可能引发子树的调整，逻辑复杂</strong>，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。</li>
<li><strong>从内存占用上来说，skiplist比平衡树更灵活一些。</strong>一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。</li>
<li>查找单个key，skiplist和平衡树的时间复杂度都为O(log n)，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近O(1)，性能更高一些。所以我们平常使用的各种Map或dictionary结构，大都是基于哈希表实现的。</li>
<li>从算法实现难度上来比较，skiplist比平衡树要简单得多。</li>
</ol>
</blockquote>
</li>
<li><p><strong>Redis集群数据分区方案？</strong></p>
<blockquote>
<p><strong>（1）哈希取余分区。（2）一致性哈希分区。（3）带虚拟节点的一致性哈希分区。</strong></p>
<p>（1）哈希取余分区思路非常简单：计算 <code>key</code> 的 hash 值，然后对节点数量进行取余，从而决定数据映射到哪个节点上。</p>
<p>不过该方案最大的问题是，<strong>当新增或删减节点时</strong>，节点数量发生变化，系统中所有的数据都需要 <strong>重新计算映射关系</strong>，引发大规模数据迁移。</p>
<p>（2）一致性哈希算法将 <strong>整个哈希值空间</strong> 组织成一个虚拟的圆环，范围是 *[0 , 2^32-1]*，对于每一个数据，根据 <code>key</code> 计算 hash 值，确数据在环上的位置，然后从此位置沿顺时针行走，找到的第一台服务器就是其应该映射到的服务器：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7896890-40e8a2c096c8da92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>与哈希取余分区相比，一致性哈希分区将 <strong>增减节点的影响限制在相邻节点</strong>。以上图为例，如果在 <code>node1</code> 和 <code>node2</code> 之间增加 <code>node5</code>，则只有 <code>node2</code> 中的一部分数据会迁移到 <code>node5</code>；如果去掉 <code>node2</code>，则原 <code>node2</code> 中的数据只会迁移到 <code>node4</code> 中，只有 <code>node4</code> 会受影响。</p>
<p>一致性哈希分区的主要问题在于，当 <strong>节点数量较少</strong> 时，增加或删减节点，<strong>对单个节点的影响可能很大</strong>，造成数据的严重不平衡。还是以上图为例，如果去掉 <code>node2</code>，<code>node4</code> 中的数据由总数据的 <code>1/4</code> 左右变为 <code>1/2</code> 左右，与其他节点相比负载过高。</p>
<p>（3）带虚拟节点的一致性哈希分区：该方案在 <strong>一致性哈希分区的基础上</strong>，引入了 <strong>虚拟节点</strong> 的概念。为了避免出现数据倾斜问题，一致性 Hash 算法引入了虚拟节点的机制，也就是每个机器节点会进行多次哈希，最终每个机器节点在哈希环上会有多个虚拟节点存在，使用这种方式来大大削弱甚至避免数据倾斜问题。这样就解决了服务节点少时数据倾斜的问题。</p>
<p>Redis 集群使用的便是该方案，其中的虚拟节点称为 <strong>槽（slot）</strong>。槽是介于数据和实际节点之间的虚拟概念，每个实际节点包含一定数量的槽，每个槽包含哈希值在一定范围内的数据。</p>
<p>在使用了槽的一致性哈希分区中，<strong>槽是数据管理和迁移的基本单位</strong>。槽 <strong>解耦</strong> 了 <strong>数据和实际节点</strong> 之间的关系，增加或删除节点对系统的影响很小。仍以上图为例，系统中有 <code>4</code> 个实际节点，假设为其分配 <code>16</code> 个槽(0-15)；</p>
<ul>
<li>槽 0-3 位于 node1；4-7 位于 node2；以此类推….</li>
</ul>
<p>如果此时删除 <code>node2</code>，只需要将槽 4-7 重新分配即可，例如槽 4-5 分配给 <code>node1</code>，槽 6 分配给 <code>node3</code>，槽 7 分配给 <code>node4</code>；可以看出删除 <code>node2</code> 后，数据在其他节点的分布仍然较为均衡。</p>
</blockquote>
</li>
<li><p><strong>为什么redis集群的最大槽数是16384个？</strong></p>
<blockquote>
<p>Redis 集群并没有使用一致性hash，而是引入了哈希槽的概念。Redis 集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。Redis 集群包含了 <code>16384</code> 个哈希槽，每个 Key 经过计算后会落在一个具体的槽位上，而槽位具体在哪个机器上是用户自己根据自己机器的情况配置的，机器硬盘小的可以分配少一点槽位，硬盘大的可以分配多一点。如果节点硬盘都差不多则可以平均分配。所以哈希槽这种概念很好地解决了一致性哈希的弊端。</p>
<p>在redis节点发送心跳包时需要把所有的槽放到这个心跳包里，以便让节点知道当前集群信息，16384=16k，在发送心跳包时使用<code>char</code>进行bitmap压缩后是2k（<code>2 * 8 (8 bit) * 1024(1k) = 2K</code>），也就是说使用2k的空间创建了16k的槽数。</p>
<p>虽然使用CRC16算法最多可以分配65535（2^16-1）个槽位，65535=65k，压缩后就是8k（<code>8 * 8 (8 bit) * 1024(1k) = 8K</code>），也就是说需要需要8k的心跳包，作者认为这样做不太值得；并且一般情况下一个redis集群不会有超过1000个master节点，所以16k的槽位是个比较合适的选择。</p>
</blockquote>
</li>
<li><p><strong>缓存雪崩，缓存穿透，如何解决？</strong></p>
<blockquote>
<p><strong>缓存穿透</strong>：大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。</p>
<p>解决办法:</p>
<ol>
<li><strong>缓存无效 key</strong> ：如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间。</li>
<li><strong>布隆过滤器</strong>：对请求进行过滤。可以非常方便地判断一个给定数据是否存在于海量数据中。<ol>
<li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li>
<li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li>
</ol>
</li>
</ol>
</blockquote>
<blockquote>
<p><strong>缓存雪崩</strong>：缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。</p>
<p>解决办法:</p>
<p><strong>针对 Redis 服务不可用的情况（如果缓存层因为某些问题不能提供服务，所有请求都会到达存储层，对数据库造成巨大压力）：</strong></p>
<ol>
<li>采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li>
<li>限流，避免同时处理大量的请求。</li>
<li>构建多级缓存，增加本地缓存，降低请求直达存储层概率。</li>
</ol>
<p><strong>针对热点缓存失效的情况（对于热数据的访问量非常大，在其缓存失效的瞬间，大量请求直达存储层，导致服务崩溃）：</strong></p>
<ol>
<li>合理设置缓存过期时间来实现。</li>
<li>缓存永不失效。</li>
</ol>
</blockquote>
</li>
<li><p><strong>如何保证缓存与数据库双写时的数据一致性?</strong></p>
<blockquote>
<p>一般情况下我们都是这样使用缓存的：先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。这种方式很明显会存在缓存和数据库的数据不一致的情况。</p>
<p>你只要用缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题？</p>
<p>一般来说，如果允许缓存可以稍微的跟数据库偶尔有不一致的情况，也就是说如果你的系统<strong>不是严格要求</strong> “缓存+数据库” 必须保持一致性的话，最好不要做这个方案，即：<strong>读请求和写请求串行化</strong>，串到一个<strong>内存队列</strong>里去。</p>
<p>串行化可以保证一定不会出现不一致的情况，但是它也会导致系统的吞吐量大幅度降低，用比正常情况下多几倍的机器去支撑线上的一个请求。把一些列的操作都放到队列里面，顺序肯定不会乱，但是并发高了，这队列很容易阻塞，反而会成为整个系统的弱点，瓶颈。</p>
</blockquote>
<blockquote>
<p>最经典的缓存+数据库读写的模式</p>
<ul>
<li>读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。</li>
<li>更新的时候，<strong>先更新数据库，然后再删除缓存</strong>。</li>
</ul>
<p>这里是懒加载的思想，需要被使用的时候再重新计算。</p>
</blockquote>
</li>
<li><p><strong>如何解决 Redis 的并发竞争 Key 问题？</strong></p>
<blockquote>
<p>Redis 的并发竞争 Key 的问题也就是多个系统同时对一个 key 进行操作，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同！</p>
<p>推荐一种方案：分布式锁（zookeeper 和 Redis 都可以实现分布式锁）。（如果不存在 Redis 的并发竞争 Key 问题，不要使用分布式锁，这样会影响性能）</p>
<p>基于 zookeeper 临时有序节点可以实现的分布式锁。大致思想为：每个客户端对某个方法加锁时，在 zookeeper 上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。</p>
<p>在实践中，当然是从以可靠性为主。所以首推 Zookeeper。</p>
</blockquote>
</li>
</ol>
<hr>
<h3 id="9-网络"><a href="#9-网络" class="headerlink" title="9. 网络"></a>9. 网络</h3><ol>
<li><p><strong>为什么网络要分层？</strong></p>
<blockquote>
<p>说到分层，我们先从我们平时使用框架开发一个后台程序来说，我们往往会按照每一层做不同的事情的原则将系统分为 三层（复杂的系统分层可能会更多）:</p>
<ol>
<li>Repository（数据库操作）</li>
<li>Service（业务操作）</li>
<li>Controller（数据交互）</li>
</ol>
<p><strong>网络分层的原则：每一层独立于其它层完成自己的工作，而不需要相互依赖，上下层之间通过标准结构来互相通信，简单易用又具有拓展性。</strong></p>
<p><strong>复杂的系统需要分层，因为每一层都需要专注于一类事情。我们的网络分层的原因也是一样，每一层只专注于做一类事情。</strong></p>
<p><strong>为什么计算机网络要分层呢？</strong> ,我们再来较为系统的说一说：</p>
<ol>
<li><strong>各层之间相互独立</strong>：各层之间相互独立，各层之间不需要关心其他层是如何实现的，只需要知道自己如何调用下层提供好的功能就可以了（可以简单理解为接口调用）<strong>。这个和我们对开发时系统进行分层是一个道理。</strong></li>
<li><strong>提高了整体灵活性</strong> ：每一层都可以使用最适合的技术来实现，你只需要保证你提供的功能以及暴露的接口的规则没有改变就行了。<strong>这个和我们平时开发系统的时候要求的高内聚、低耦合的原则也是可以对应上的。</strong></li>
<li><strong>大问题化小</strong> ：分层可以将复杂的网络间题分解为许多比较小的、界线比较清晰简单的小问题来处理和解决。这样使得复杂的计算机网络系统变得易于设计，实现和标准化。<strong>这个和我们平时开发的时候，一般会将系统功能分解，然后将复杂的问题分解为容易理解的更小的问题是相对应的，这些较小的问题具有更好的边界（目标和接口）定义。</strong></li>
</ol>
</blockquote>
</li>
<li><p><strong>TCP/IP 4 层模型了解么？</strong></p>
<blockquote>
<p>TCP/IP 4 层模型:</p>
<ol>
<li>应用层</li>
<li>传输层</li>
<li>网络层</li>
<li>网络接口层</li>
</ol>
</blockquote>
</li>
<li><p><strong>HTTP 是哪一层的协议？http常见的状态码。</strong></p>
<blockquote>
<p>HTTP 协议 属于应用层的协议。</p>
<p><strong>HTTP 协议是基于 TCP 协议的</strong>，发送 HTTP 请求之前首先要建立 TCP 连接也就是要经历 3 次握手。目前使用的 HTTP 协议大部分都是 1.1。在 1.1 的协议里面，默认是开启了 Keep-Alive 的，这样的话建立的连接就可以在多次请求中被复用了。</p>
<p>另外， <strong>HTTP 协议是”无状态”的协议，它无法记录客户端用户的状态</strong> 一般我们都是通过 Session 来记录客户端用户的状态。</p>
</blockquote>
<blockquote>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/%E7%8A%B6%E6%80%81%E7%A0%81.png" alt="http常见的状态码"></p>
<table>
<thead>
<tr>
<th align="center">状态码</th>
<th align="center">简要说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">200</td>
<td align="center">客户端请求成功</td>
</tr>
<tr>
<td align="center">301</td>
<td align="center">请求的网页已永久移动到新位置，后应使用新位置</td>
</tr>
<tr>
<td align="center">302</td>
<td align="center">临时性重定向，请求的资源临时分配了新位置，本次请求暂且使用新位置</td>
</tr>
<tr>
<td align="center">304</td>
<td align="center">自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。</td>
</tr>
<tr>
<td align="center">403</td>
<td align="center">请求被服务器拒绝</td>
</tr>
<tr>
<td align="center">404</td>
<td align="center">服务器无法找到请求的URL</td>
</tr>
</tbody></table>
</blockquote>
</li>
<li><p><strong>HTTP 和 HTTPS 什么区别</strong>？</p>
<blockquote>
<ol>
<li><p><strong>端口</strong> ：HTTP的URL由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。</p>
</li>
<li><p>安全性和资源消耗：</p>
<p>HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS是运行在SSL之上的HTTP协议，SSL运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。</p>
<ul>
<li>对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；</li>
<li>非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。</li>
</ul>
</li>
</ol>
</blockquote>
</li>
<li><p><strong>讲一下对称加密算法和非对称加密算法？</strong></p>
<blockquote>
<p> 对称密钥加密，加密和解密使用同一密钥。运算速度快；无法安全地将密钥传输给通信方。典型的对称加密算法有DES、AES等</p>
<p> 非对称密钥加密，加密和解密使用不同的密钥。通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。可以更安全地将公开密钥传输给通信发送方；运算速度慢。典型的非对称加密算法有RSA、DSA等</p>
<p> HTTPS 采用的加密方式: HTTPS 采用混合的加密机制。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。</p>
</blockquote>
</li>
<li><p><strong>HTTP2.0讲一下</strong></p>
<blockquote>
<ol>
<li><strong>二进制传输</strong>：HTTP/2 采用二进制格式传输数据，HTTP/2 将请求和响应数据分割为更小的帧，并且它们采用二进制编码。</li>
<li><strong>多路复用</strong>：在 HTTP/2 中引入了多路复用的技术。在 HTTP/2 中，采用了二进制分帧，使性能有了极大提升。</li>
<li><strong>Header压缩</strong>：HTTP/2 对首部采取了压缩策略，请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销。</li>
</ol>
</blockquote>
</li>
<li><p><strong>HTTP报文详解？详细说一下请求报文，以及HTTP和TCP的区别</strong></p>
<blockquote>
<p>HTTP有两种报文：请求报文和响应报文</p>
</blockquote>
<p><img src="https://ftp.bmp.ovh/imgs/2021/04/aca725fe03bae346.jpg" alt="img"></p>
<blockquote>
<p>HTTP请求报文主要包括请求行、请求头部以及请求的数据（实体）三部分</p>
<p><strong>请求行（HTTP请求报文的第一行）</strong></p>
<p>请求行由方法字段、URL字段和HTTP协议版本字段。其中，方法字段严格区分大小写，当前HTTP协议中的方法都是大写，方法字段如下介绍如下：</p>
<p><strong>请求头部：位于请求行的下面, 是一个个的key-value值</strong></p>
<p><strong>空行(CR+LF)：请求报文用空行表示header和请求数据的分隔</strong></p>
<p><strong>请求数据</strong>：GET方法没有携带数据， POST方法会携带一个body</p>
</blockquote>
<p><img src="https://ftp.bmp.ovh/imgs/2021/04/b170d455b30f3bef.jpg" alt="img"></p>
<blockquote>
<p>HTTP的响应报文包括：状态行，响应头部，相应的数据(响应体)</p>
<p><strong>状态行</strong>包括：HTTP版本号，状态码和状态值组成。</p>
<p><strong>响应头</strong>类似请求头，是一系列key-value值</p>
<p><strong>空白行：同上，响应报文也用空白行来分隔header和数据</strong></p>
<p><strong>响应体</strong>：响应的数据</p>
</blockquote>
</li>
<li><p><strong>TCP三次握手的过程，以及三次握手的原因？</strong></p>
<blockquote>
<p>假设 A 为客户端，B 为服务器端。</p>
<ul>
<li>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</li>
<li>A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。</li>
<li>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</li>
<li>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</li>
<li>B 收到 A 的确认后，连接建立。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>三次握手的目的是建立可靠的通信信道，三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</strong></p>
<p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p>
</blockquote>
</li>
<li><p><strong>TCP四次挥手的过程，以及四次挥手的原因？</strong></p>
<blockquote>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f87afe72-c2df-4c12-ac03-9b8d581a8af8.jpg" width="600"/> </div><br>

<p>假设 A 为客户端，B 为服务器端。</p>
<ul>
<li>A 发送连接释放报文，FIN=1。</li>
<li>B 收到之后发出确认，它发回一 个 ACK确认报文，确认序号为收到的序号加1。此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</li>
<li>当 B 不再需要连接时，发送连接释放报文，FIN=1。</li>
<li>A 收到后发出ACK 确认报文，并将确认序号设置为收到序号加1，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。</li>
<li>B 收到 A 的确认后释放连接。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>CLOSE-WAIT 状态问题：</strong></p>
<p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p>
<p><strong>TIME-WAIT 状态问题(这个问题问过很多次但总是答得不甚满意)：</strong></p>
<p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p>
<ul>
<li>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。MSL 是最大报文段寿命，等待 2MSL 可以保证 A 发送的最后一个确认报文被 B 接收，如果该报文丢失，B 会超时重传之前的 FIN+ACK 报文，保证 B 正常进入 CLOSED 状态。</li>
<li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。2MSL 后，本连接中的所有报文就都会从网络中消失，防止已失效请求造成异常。</li>
</ul>
<p>通信双方建立TCP连接后，主动关闭连接的一方就会进入TIME_WAIT状态。</p>
</blockquote>
</li>
<li><p><strong>TCP滑动窗口是干什么的？TCP的可靠性体现在哪里？拥塞控制如何实现的？</strong></p>
<blockquote>
<p><strong>滑动窗口</strong>：窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。</p>
<p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。接收窗口只会对窗口内最后一个按序到达的字节进行确认。如果发送窗口内的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向滑动接收窗口。</p>
</blockquote>
<blockquote>
<p><strong>流量控制如何实现</strong>：流量控制是为了控制发送方发送速率，保证接收方来得及接收。</p>
<p>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>
</blockquote>
<blockquote>
<p><strong>拥塞控制</strong>：网络中对资源的需求超过可用量的情况就叫拥塞，拥塞控制就是减少注入网络的数据，减轻路由器和链路的负担，这是一个全局性问题，涉及网络中的所有路由器和主机，而流量控制是一个端到端的问题。如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。</p>
<p>发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量。</p>
<ol>
<li><p>慢开始与拥塞避免</p>
<p>发送的最初执行慢开始，令拥塞窗口大小为1，发送方只能发送1个报文段；当收到确认后，将拥塞窗口大小加倍。设置一个慢开始门限，当 拥塞窗口的大小大于慢开始门限时，进入拥塞避免，每个轮次只将拥塞窗口加1。如果出现了超时，则令慢开始门限 = 拥塞窗口大小 / 2，然后重新执行慢开始。</p>
</li>
<li><p>快重传与快恢复</p>
<p>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令慢开始门限 = 拥塞窗口大小 / 2 ，拥塞窗口大小 = 慢开始门限 ，注意到此时直接进入拥塞避免。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/910f613f-514f-4534-87dd-9b4699d59d31.png" width="800"/> </div><br>
</li>
</ol>
</blockquote>
<blockquote>
<p>主要的考虑还是要区分包的丢失是由于链路故障还是乱序等其他因素引发。两次冗余ACK时很可能是乱序造成的！三次冗余ACK(三个重复确认)时很可能是丢包造成的！</p>
</blockquote>
<blockquote>
<p><strong>（主要）TCP 使用超时重传来实现可靠传输</strong>：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。</p>
<ol>
<li>应用数据被分割成 TCP 认为最适合发送的数据块。</li>
<li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li>
<li><strong>校验和：</strong> TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li>
<li>TCP 的接收端会丢弃重复的数据。</li>
<li><strong>流量控制：</strong> TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li>
<li><strong>拥塞控制：</strong> 当网络拥塞时，减少数据的发送。</li>
<li><strong>ARQ协议：</strong> 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li>
<li><strong>超时重传：</strong> 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li>
</ol>
</blockquote>
</li>
<li><p><strong>TCP和UDP有什么区别？及其适用的场景。</strong></p>
<blockquote>
<ul>
<li>用户数据报协议 UDP是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。</li>
<li>传输控制协议 TCP是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>TCP应用场景：<br>效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。举几个例子：文件传输、接受邮件、远程登录。</li>
<li>UDP应用场景：<br>适用于一次只传送少量数据、对可靠性要求不高的应用环境。举几个例子：QQ聊天、在线视频、网络语音电话、广播通信（广播、多播）。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>UDP为何快？</strong></p>
<p>1.不需要建立连接</p>
<p>2.对于收到的数据，不用给出确认</p>
<p>3.没有超时重发机制</p>
<p>4.没有流量控制和拥塞控制</p>
</blockquote>
</li>
<li><p><strong>Mac 地址和 ip 地址的区别？既然有了 Mac 地址，为什么还要 ip 地址呢？</strong></p>
<blockquote>
<p>MAC地址是烧录在网卡或者接口上的<strong>物理地址</strong>，具有<strong>全球唯一性</strong>，一般不能被改变。IP地址是网络中的主机或接口在网络中的<strong>逻辑地址</strong>，在<strong>同一个网络内具有唯一性</strong>。</p>
</blockquote>
</li>
<li><p><strong>当你打开一个电商网站，都需要经历哪些过程？分别用到了什么协议。</strong></p>
<blockquote>
<ol>
<li>浏览器查找域名的IP地址 （DNS：获取域名对应的IP）</li>
<li>浏览器向web服务器发送HTTP请求（cookies会随着请求发送给服务器）</li>
<li>服务器处理请求 （请求 处理请求 参数、cookies、生成一个HTML响应）</li>
<li>服务器返回HTTP报文，发回一个HTML响应。</li>
<li>浏览器解析渲染页面，浏览器开始显示HTML。</li>
<li>连接结束</li>
</ol>
</blockquote>
<blockquote>
<p>使用的协议:</p>
<p>DNS: 获取域名对应的IP</p>
<p>TCP: 与服务器建立TCP连接</p>
<p>IP: 建立TCP协议时，需要发送数据，发送数据在网络层上使用IP协议</p>
<p>OSPF：IP数据包在路由器之间，路由选择使用OSPF协议</p>
<p>ARP：路由器在与服务器进行通信的过程中，将IP地址装换成MAC地址</p>
<p>HTTP：客户端浏览器与Web服务器之间的应用层通信协议，在TCP建立完成后，使用HTTP协议访问网页</p>
</blockquote>
</li>
<li><p><strong>电子邮件的发送过程?</strong></p>
<blockquote>
<p>一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。</p>
<p>邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。</p>
</blockquote>
<blockquote>
<ol>
<li>用户A的邮箱是QQ邮箱，他要发往的邮箱是163邮箱，用户A写好一封邮件点击发送，即提交到了QQ邮箱服务器，使用的是SMTP协议。</li>
<li>QQ邮箱会对A发送邮件的收件地址进行解析，判断是否为内部邮箱的账号，如果也是QQ邮箱，会直接存储到自己的存储空间，如果不是则会发送到指定邮箱服务器，使用的也是SMTP协议。</li>
<li>163的邮箱服务器收到邮件后会再次判断该邮件是否为自己的邮件，如果是则存到自己的存储空间，等待POP3服务去读取邮件。</li>
<li>用户B收到消息后，打开客户端访问163服务器，调用POP3服务。</li>
<li>Pop3服务接到指令后，读取存储空间中发送给B的未读邮件服务。</li>
<li>将读取到的邮件返回给客户端软件。</li>
</ol>
</blockquote>
</li>
<li><p><strong>DNS解析过程，DNS劫持了解吗？</strong></p>
<blockquote>
<p>DNS完成的工作是：域名到IP地址的解析。将域名和IP地址相互映射的一个分布式数据库。</p>
</blockquote>
<blockquote>
<p>域名解析大概分为两步：</p>
<ul>
<li>第一步：向本地域名服务器发起查询请求，请求报文里面含有需要查询的域名；</li>
<li>第二步：本地域名服务器返回DNS响应，响应报文中含有DNS解析的IP地址；</li>
</ul>
<p>在DNS解析过程中使用的是迭代查询——本地域名服务器向根域名服务器发起查询，根域名服务器告诉本地域名服务器下一步该往哪个域名服务器走，一步步按照域名服务的查询路径找到域名对应的IP返回给请求发起方。</p>
</blockquote>
<blockquote>
<p>第一步：客户机提出域名解析请求，并将该请求发送给本地域名服务器。</p>
<p>第二步：当本地域名服务器收到请求后，就先查询本地缓存，如果有该纪录项，则本地域名服务器就直接把查询结果返回。</p>
<p>第三步：如果本地缓存中没该纪录，则本地域名服务器就直接把请求发给根域名服务器，然后根域名服务器再返回给本地域名服务器一个所查询域(根子域)主域名服务器地址。</p>
<p>第四步：本地服务器再向上一步返回的域名服务器发送请求，然后接受请求的服务器查询自己的缓存，如果没该纪录，则返回相关下级域名服务器地址。</p>
<p>第五步：重复第四步，直到找到正确纪录。</p>
<p>第六步：本地域名服务器把返回结果保存到缓存，以备下一次使用，同时还将结果返回给客户机。</p>
</blockquote>
<blockquote>
<p>（1）递归查询：本机向本地域名服务器发出一次查询请求，就静待最终的结果。如果本地域名服务器无法解析，自己会以DNS客户机的身份向其它域名服务器查询，直到得到最终的IP地址告诉本机<br>（2）迭代查询：本地域名服务器向根域名服务器查询，根域名服务器告诉它下一步到哪里去查询，然后它再去查，每次它都是以客户机的身份去各个服务器查询。</p>
</blockquote>
<blockquote>
<p>DNS在进行区域传输的时候使用TCP，普通的查询使用UDP。为什么查询是使用UDP呢？</p>
<p>域名解析时使用UDP协议：<br>客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过TCP三次握手，这样DNS服务器负载更低，响应更快。</p>
<p>区域传送时使用TCP，主要有一下两点考虑：<br>1.辅域名服务器会定时（一般时3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，则会执行一次区域传送，进行数据同步。区域传送将使用TCP而不是UDP，因为数据同步传送的数据量比一个请求和应答的数据量要多得多。<br>2.TCP是一种可靠的连接，保证了数据的准确性。</p>
</blockquote>
<blockquote>
<p>DNS劫持：在DNS服务器中，将www.****.com的域名对应的IP地址进行了变化。你解析出来的域名对应的IP，在劫持前后不一样。<br>HTTP劫持：你DNS解析的域名的IP地址不变。在和网站交互过程中的劫持了你的请求。在网站发给你信息前就给你返回了请求。</p>
</blockquote>
<blockquote>
<p>DNS在区域传输的时候使用TCP协议,其他时候使用UDP协议。</p>
</blockquote>
</li>
<li><p><strong>GET和POST有什么不一样？</strong></p>
<blockquote>
<p>GET和POST是HTTP请求的两种基本方法（记不住全部，只记这么点）</p>
<ol>
<li>最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数。</li>
<li>GET请求在URL中传送的参数是有长度限制的，而POST没有。</li>
<li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li>
</ol>
</blockquote>
</li>
<li><p><strong>session和cookie的问题？</strong></p>
<blockquote>
<p>Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式</p>
<p><strong>Cookie 一般用来保存用户信息</strong>，<strong>Session 的主要作用就是通过服务端记录用户的状态</strong></p>
<p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p>
</blockquote>
</li>
<li><p><strong>HTTP是不保存状态的协议,如何保存用户状态?</strong></p>
<blockquote>
<p> HTTP 是一种无状态协议。HTTP 协议自身不对请求和响应之间的通信状态进行保存。主要通过session机制来进行解决，Session 的主要作用就是通过服务端记录用户的状态。</p>
<p> 在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库redis保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。</p>
<p> <strong>Cookie 被禁用怎么办?</strong> 最常用的就是利用 URL 把 Session ID 直接附加在URL路径的后面。</p>
</blockquote>
</li>
<li><p><strong>Arp协议？</strong></p>
<blockquote>
<p>Arp协议能通过接收端的ip地址解析到mac地址。</p>
<p>如果发送端和目标端的主机都在同一个网段，发送端发送数据帧前检查是否拥有接收端的mac地址，如果没有，则启动arp，先检查缓存ip-mac表中是否有接收端的mac地址，如果有则直接拿来即用，如果没有则在本网段（局域网）广播arp包，本网段各计算机都收到arp请求，从发送来的数据中检查请求过来的ip地址与自己是否一致，如果不一致，则丢弃，如果ip一致，则单播返回mac地址给请求的计算机，发送端便获取到了接收端的mac地址，接收到接收端的mac地址它还会缓存一份，用于下次拿来即用。</p>
<p>如果请求端和目标端的主机不在同一个网段呢？arp广播的数据是被路由阻断的，不能跨到不同的网段进行广播的，因为这样广播会导致广播数据泛滥。如果不在同一个网段，则请求端拿到的目标端的mac地址其实是它网关的mac地址，将数据帧给到网关再进行下一跳转发，下一跳同样在自己的网段寻找到目标主机mac地址或再找到下一跳mac地址。</p>
</blockquote>
</li>
<li><p><strong>DDos攻击了解吗？</strong></p>
<blockquote>
<p>分布式拒绝服务，一般来说是指攻击者利用一些被控制的设备对目标网站在较短的时间内发起大量请求，大规模消耗目标网站的主机资源，让它无法正常服务。</p>
</blockquote>
</li>
<li><p><strong>SQL注入攻击？</strong></p>
<blockquote>
<p>针对程序员编写时的疏忽，将SQL语句传递到服务器解析并执行的一种攻击手段。</p>
</blockquote>
</li>
</ol>
<hr>
<h3 id="10-分布式"><a href="#10-分布式" class="headerlink" title="10. 分布式"></a>10. 分布式</h3><ol>
<li><p><strong>如何理解分布式？</strong></p>
<blockquote>
<p>多个能独立运行的结点组成。各个结点利用计算机网络进行信息传递，从而实现共同的“目标或者任务”。主要可以完成一些诸如分布式计算，分布式存储之类的工作。涉及到的主要问题就是保证分布式系统的一致性，分布式系统高可用的问题。</p>
</blockquote>
</li>
<li><p><strong>分布式锁的实现方式</strong></p>
<blockquote>
<p>在分布式场景下，需要同步的进程可能位于不同的节点上，那么就需要使用分布式锁。</p>
<p>分布式锁的实现方式主要有：数据库的唯一索引，Redis 的 SETNX 指令，Redis 的 RedLock 算法，Zookeeper 的有序节点。</p>
<p><strong>数据库的唯一索引</strong>：获得锁时向表中插入一条记录，释放锁时删除这条记录。</p>
<p><strong>Redis 的 SETNX 指令</strong>：使用 SETNX（set if not exist）指令插入一个键值对，如果 Key 已经存在，那么会返回 False，否则插入成功并返回 True。</p>
<p><strong>Redis 的 RedLock 算法</strong>：使用了多个 Redis 实例来实现分布式锁。1. 尝试从 N 个互相独立 Redis 实例获取锁；2. 计算获取锁消耗的时间，只有时间小于锁的过期时间，并且从大多数（N / 2 + 1）实例上获取了锁，才认为获取锁成功；3. 如果获取锁失败，就到每个实例上释放锁。</p>
<p><strong>Zookeeper 的有序节点</strong>：1. 创建一个锁目录 /lock；2. 当一个客户端需要获取锁时，在 /lock 下创建临时的且有序的子节点；3. 客户端获取 /lock 下的子节点列表，判断自己创建的子节点是否为当前子节点列表中序号最小的子节点，如果是则认为获得锁；否则监听自己的前一个子节点，获得子节点的变更通知后重复此步骤直至获得锁；4. 执行业务代码，完成后，删除对应的子节点。</p>
</blockquote>
<blockquote>
<p>锁无法释放问题，单点问题，不可重入问题，非阻塞问题，性能问题。</p>
<ol>
<li><p>基于数据库</p>
<p>(1) 锁无法释放，解锁失败的话其他进程无法获得该锁。</p>
<p>(2) 不可重入，已经获得锁的进程必须重新获得锁。</p>
<p>(3) 只能是非阻塞锁，插入失败就报错了，无法重试。</p>
</li>
<li><p>基于缓存（redis）</p>
<p>单点问题：很多缓存都是集群部署的。锁无法释放问题：可以解决redis可对记录设置过期时间，防止系统崩溃锁无法自动释放。非阻塞问题：while重复执行，消耗CPU资源。使用超时机制控制锁的释放不是十分靠谱。可重入：主机信息和线程信息保存起来，检查是不是当前锁的拥有者。</p>
</li>
<li><p>基于ZooKeeper</p>
<p>有效解决单点问题，不可重入问题（节点数据进行比对），非阻塞问题（绑定监听器），以及锁无法释放问题（客户端挂掉则删除节点），性能上不如用缓存进行实现。</p>
<blockquote>
<p> redis分布式锁，其实需要自己不断去尝试获取锁，比较消耗性能。</p>
<p>zk分布式锁，获取不到锁，注册个监听器即可，不需要不断主动尝试获取锁，性能开销较小。</p>
<p>另外一点就是，如果是redis获取锁的那个客户端bug了或者挂了，那么只能等待超时时间之后才能释放锁；而zk的话，因为创建的是临时znode，只要客户端挂了，znode就没了，此时就自动释放锁</p>
</blockquote>
</li>
</ol>
</blockquote>
</li>
<li><p><strong>讲一下负载均衡算法</strong></p>
<blockquote>
<p>负载均衡器会根据集群中每个节点的负载情况，将用户请求转发到合适的节点上。</p>
<ol>
<li>轮询：轮询算法把每个请求轮流发送到每个服务器上。</li>
<li>加权轮询：加权轮询是在轮询的基础上，根据服务器的性能差异，为服务器赋予一定的权值，性能高的服务器分配更高的权值。</li>
<li>最少连接：最少连接算法就是将请求发送给当前最少连接数的服务器上。</li>
<li>加权最少连接：在最少连接的基础上，根据服务器的性能为每台服务器分配权重，再根据权重计算出每台服务器能处理的连接数。</li>
<li>随机算法：把请求随机发送到服务器上。</li>
<li>源地址哈希法：通过对客户端 IP 计算哈希值之后，再对服务器数量取模得到目标服务器的序号。</li>
</ol>
</blockquote>
</li>
<li><p><strong>分布式事务解决方案？</strong></p>
<blockquote>
<p>分布式事务就是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。简单的说，就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。本质上来说，分布式事务就是为了保证不同数据库的数据一致性。</p>
<ol>
<li><p>两阶段提交（2PC）</p>
<p>两阶段提交（Two-phase Commit，2PC），通过引入协调者来协调参与者的行为，并最终决定这些参与者是否要真正执行事务。</p>
<ol>
<li>准备阶段: 协调者向所有参与者发送事务内容，并等待答复，参与者发回事务执行结果。</li>
<li>提交阶段: 如果事务在每个参与者上都执行成功，协调者发送通知让参与者提交事务；否则，协调者发送通知让参与者回滚事务。</li>
</ol>
<blockquote>
<p>XA 是一个两阶段提交协议，该协议分为以下两个阶段</p>
<ul>
<li>第一阶段：事务协调器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交.</li>
<li>第二阶段：事务协调器要求每个数据库提交数据。</li>
</ul>
</blockquote>
<p><strong>优点：</strong> 尽量保证了数据的强一致，适合对数据强一致要求很高的关键领域。（其实也不能100%保证强一致）</p>
<p><strong>缺点：</strong> 实现复杂，牺牲了可用性，对性能影响较大，不适合高并发高性能场景。</p>
</li>
<li><p>补偿事务（TCC）</p>
<p>TCC 其实就是采用的补偿机制，其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。它分为三个阶段：</p>
<ul>
<li>Try 阶段主要是对业务系统做检测（一致性）及资源预留（准隔离性）。</li>
<li>Confirm 阶段主要是对业务系统做确认提交，执行真正的业务。</li>
<li>Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。</li>
</ul>
<p><strong>优点：</strong> 跟2PC比起来，实现以及流程相对简单了一些，但数据的一致性比2PC也要差一些</p>
<p><strong>缺点：</strong> 缺点还是比较明显的，在2,3步中都有可能失败。TCC属于应用层的一种补偿方式，所以需要程序员在实现的时候多写很多补偿的代码，在一些场景中，一些业务流程可能用TCC不太好定义及处理。</p>
</li>
<li><p>消息事务</p>
<p>所谓的消息事务就是基于消息中间件的两阶段提交，本质上是对消息中间件的一种特殊利用，它是将本地事务和发消息放在了一个分布式事务里，保证要么本地操作成功成功并且对外发消息成功，要么两者都失败。</p>
<p>原理：</p>
<p><img src="https://images2017.cnblogs.com/blog/250417/201710/250417-20171016141237443-2074834323.png" alt="img"></p>
<p><img src="http://static.codeceo.com/images/2016/07/distri-trans-06.png" alt="img"></p>
<ol>
<li>在分布式事务操作的一方完成写业务数据的操作之后向本地消息表发送一个消息。</li>
<li>之后将本地消息表中的消息转发到 Kafka 等消息队列中，在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作。</li>
<li>如果转发成功则将消息从本地消息表中删除，否则继续重新转发。</li>
</ol>
<p>基于消息中间件的两阶段提交往往用在高并发场景下，将一个分布式事务拆成一个消息事务（A系统的本地操作+发消息）+B系统的本地操作，其中B系统的操作由消息驱动，只要消息事务成功，那么A操作一定成功，消息也一定发出来了，这时候B会收到消息去执行本地操作，如果本地操作失败，消息会重投，直到B操作成功，这样就变相地实现了A与B的分布式事务。</p>
<p>这种方案遵循BASE理论，采用的是最终一致性，笔者认为是这几种方案里面比较适合实际业务场景的，即不会出现像2PC那样复杂的实现(当调用链很长的时候，2PC的可用性是非常低的)，也不会像TCC那样可能出现确认或者回滚不了的情况。</p>
<p><strong>优点：</strong> 一种非常经典的实现，避免了分布式事务，实现了最终一致性。在 .NET中 有现成的解决方案。</p>
<p><strong>缺点：</strong> 消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。</p>
</li>
</ol>
</blockquote>
</li>
<li><p><strong>讲一下分布式和分布式一致性协议</strong></p>
<blockquote>
<p><strong>CAP</strong></p>
<p>分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容忍性（P：Partition Tolerance），最多只能同时满足其中两项。在分布式系统中，分区容忍性必不可少，因为需要总是假设网络是不可靠的。因此，CAP 理论实际上是要在可用性和一致性之间做权衡。</p>
<p>一致性（C：Consistency）：一致性指的是多个数据副本是否能保持一致的特性，在一致性的条件下，系统在执行数据更新操作之后能够从一致性状态转移到另一个一致性状态。</p>
<p>可用性（A：Availability）：可用性指分布式系统在面对各种异常时可以提供正常服务的能力。</p>
<p>分区容忍性（P：Partition Tolerance）：在分区容忍性条件下，分布式系统在遇到任何网络分区故障的时候，仍然需要能对外提供一致性和可用性的服务。</p>
</blockquote>
<blockquote>
<p><strong>BSAE</strong></p>
<p>BASE 是基本可用（Basically Available）、软状态（Soft State）和最终一致性（Eventually Consistent）三个短语的缩写。</p>
<p>BASE 理论是对 CAP 中一致性和可用性权衡的结果，它的核心思想是：<strong>即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</strong></p>
<p>基本可用（Basically Available）：指分布式系统在出现故障的时候，保证核心可用，允许损失部分可用性。</p>
<p>软状态（Soft State）：允许系统不同节点的数据副本之间进行同步的过程存在时延。</p>
<p>最终一致性（Eventually Consistent）：最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能达到一致的状态。</p>
</blockquote>
<blockquote>
<p><strong>Paxos</strong></p>
<p>Paxos算法需要解决的问题就是如何在一个可能发生上述异常的分布式系统中，快速且正确地在集群内部对<strong>某个数据的值</strong>达成一致</p>
<p>包括三个阶段：Prepare 阶段，Accept 阶段，Learn 阶段。</p>
<p>主要有三类节点：</p>
<ul>
<li>提议者（Proposer）：提议一个值；</li>
<li>接受者（Acceptor）：对每个提议进行投票；</li>
<li>告知者（Learner）：被告知投票的结果，不参与投票过程。</li>
</ul>
<p>Paxos算法分为<strong>两个阶段</strong>。具体如下：</p>
<ul>
<li><p><strong>阶段一：</strong></p>
<p>(a) Proposer选择一个<strong>提案编号N</strong>，然后向<strong>半数以上</strong>的Acceptor发送编号为N的<strong>Prepare请求</strong>。</p>
<p>(b) 如果一个Acceptor收到一个编号为N的Prepare请求，且N<strong>大于</strong>该Acceptor已经<strong>响应过的</strong>所有<strong>Prepare请求</strong>的编号，那么它就会将它已经<strong>接受过的编号最大的提案（如果有的话）</strong>作为响应反馈给Proposer，同时该Acceptor承诺<strong>不再接受</strong>任何<strong>编号小于N的提案</strong>。</p>
</li>
<li><p><strong>阶段二：</strong></p>
<p>(a) 如果Proposer收到<strong>半数以上</strong>Acceptor对其发出的编号为N的Prepare请求的<strong>响应</strong>，那么它就会发送一个针对<strong>[N,V]提案</strong>的<strong>Accept请求</strong>给<strong>半数以上</strong>的Acceptor。注意：V就是收到的<strong>响应</strong>中<strong>编号最大的提案的value</strong>，如果响应中<strong>不包含任何提案</strong>，那么V就由Proposer<strong>自己决定</strong>。</p>
<p>(b) 如果Acceptor收到一个针对编号为N的提案的Accept请求，只要该Acceptor<strong>没有</strong>对编号<strong>大于N</strong>的<strong>Prepare请求</strong>做出过<strong>响应</strong>，它就<strong>接受该提案</strong>。</p>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>Hadoop介绍</strong></p>
<blockquote>
<p>Hadoop一个能够允许大量数据在计算机集群中，通过使用简单的编程模型进行分布式处理的框架。</p>
<p>Hadoop最基础的几个模块有:</p>
<p><strong>Common</strong>: 支持其他模块的公用工具包。</p>
<p><strong>HDFS</strong>: 一个可高吞吐访问应用数据的分布式文件系统。</p>
<p><strong>YARN</strong>: 一个管理集群服务器资源和任务调度的框架。</p>
<p><strong>MapReduce</strong>: 基于Yarn对大数据集进行并行计算的系统。</p>
</blockquote>
</li>
<li><p><strong>MapReduce编程模型</strong></p>
<blockquote>
<p>简单在于其编程模型只包含map和reduce两个过程，map的主要输入是一对&lt;key , value&gt;值，经过map计算后输出一对&lt;key , value&gt;值；然后将相同key合并，形成&lt;key , value&gt;集合；再将这个&lt;key , value&gt;集合输入reduce，经过计算输出零个或多个&lt;key , value&gt;对。</p>
<p>每个map任务的计算结果都会写入到本地文件系统，等map任务快要计算完成的时候，MapReduce计算框架会启动shuffle过程，对map产生的每个&lt;key , value&gt;进行reduce分区选择，然后通过http通信发送给对应的reduce进程。reduce端对收到的&lt;key , value&gt;进行排序和合并，相同的key放在一起，组成一个&lt;key , value&gt;集合传递给reduce执行。</p>
</blockquote>
</li>
<li><p><strong>Flink的状态机制？</strong></p>
<blockquote>
<p>Flink 内置的很多算子，包括源 source，数据存储 sink 都是有状态State的。</p>
<p>在 Flink 中，状态始终与特定Task/Operator相关联。而Check point可以理解为把State数据持久化存储了。Flink 会以 Check point 的形式对各个任务的状态进行快照，用于保证故障恢复时的状态一致性。Flink 通过状态后端来管理状态和checkpoint的存储，状态后端可以有不同的配置选择。</p>
</blockquote>
</li>
<li><p><strong>Flink的容错机制？</strong></p>
<blockquote>
<p>流数据的一致性就是：成功处理故障并恢复之后得到的结果与没有发生任何故障得到的结果相比，前者具有正确性。也就是故障的发生是否影响得到的结果。</p>
<p>在流处理过程，一致性分为3个级别：</p>
<ul>
<li>at-most-once：至多一次。故障发生之后，计算结果可能丢失，就是无法保证结果的正确性；</li>
<li>at-least-once：至少一次。计算结果可能大于正确值，但绝不会小于正确值，就是计算程序发生故障后可能多算，但是绝不可能少算；</li>
<li>exactly-once：精确一次。系统保证发生故障后得到的计算结果的值和正确值一致；</li>
</ul>
<p>Flink的容错机制保证了exactly-once，也可以选择at-least-once。Flink的容错机制是通过对数据流不停的做快照（snapshot）实现的。Flink做快照的过程是基于“轻量级异步快照”的算法，其核心思想就是在计算过程中保存中间状态和在数据流中对应的位置，在系统故障恢复时，系统会从最新的一个checkpoint开始重新计算，对应的数据源也会在对应的位置“重放“。这里的“重放”可能会导致数据的二次输出。</p>
<p>当算子收到其中一个数据源的barriers，而未收到另一个数据源的barriers时，会将先到barriers的数据源中的数据先缓冲起来，等待另一个barriers，当收到两个barriers即接收到全部数据源的barrier时，会做checkpoint，保存barriers位置和状态，释放缓冲中的数据，释放一个对应的barriers。这里需要注意是，当缓存中数据没有被发射完时，是不会处理后续数据的，这样是为了保证数据的有序性。</p>
<p><strong>屏障（Barriers）</strong></p>
<p>在Flink做分布式快照过程中核心是Barriers的使用。这些Barriers是在数据接入到Flink之初就注入到数据流中，并随着数据流向每个算子。</p>
<ul>
<li>算子对Barriers是免疫的，即Barriers是不参与计算的；</li>
<li>Barriers和数据的相对位置是保持不变的，而且Barriers之间是线性递增的；</li>
</ul>
<p>Barriers将数据流分成了一个个数据集。当barriers流经算子时，会触发与checkpoint相关的行为，保存的barriers的位置和状态（中间计算结果）。</p>
<p><strong>状态（State）</strong></p>
<p>在一次snapshot中，算子会在接受到其数据源的<strong>所有</strong>barriers的以后snapshot它们的状态，然后在发射barriers到输出流中，直到最后所有的sink算子都完成snapshot才算完成一次snapshot。其中，在准备发射的barriers形成之前，state 形式是可以改变的，之后就不可以了。state的存贮方式是可以配置的，如HDFS，默认是在JobManager的内存中。</p>
<p><strong>异步快照（asynchronous state snapshot）</strong></p>
<p>上述描述中，需要<strong>等待</strong>算子接收到所有barriers后，开始做snapshot，存储对应的状态后，再进行下一次snapshot，其状态的存储是同步的，这样可能会造成因snapshot引起较大延时。可以让算子在存储快照时继续处理数据，让快照存储异步在后台运行。为此，算子必须能生成一个 state 对象，保证后续状态的修改不会改变这个 state 对象。异步状态快照，其可以让算子接受到barriers后开始在后台异步拷贝其状态，而不必等待所有的barriers的到来。一旦后台的拷贝完成，将会通知JobManager。只有当所有的sink接收到这个barriers，和所有的有状态的算子都确认完成状态的备份时，一次snapshot才算完成。</p>
</blockquote>
</li>
<li><p><strong>Flink的高可用？</strong></p>
<blockquote>
<p>本质也就是JobManager 高可用(HA)，JobManager协调每个flink任务部署。它负责任务调度和资源管理。 默认情况下，每个flink集群只有一个JobManager，这将导致一个单点故障：如果JobManager挂了，则不能提交新的任务，并且运行中的程序也会失败。 Flink利用 ZooKeeper在所有正在运行的 JobManager 实例之间进行分布式协调。</p>
<p>对于Standalone集群模式下的JobManager高可用通常的方案是：Flink集群的任一时刻只有一个leading JobManager，并且有多个standby JobManager。当leader失败后，standby通过选举出一个JobManager作为新的leader。这个方案可以保证没有单点故障的问题。</p>
<p>在运行高可用性 YARN 集群时，<strong>我们不会运行多个 JobManager (ApplicationMaster) 实例</strong>，而只运行一个，该JobManager实例失败时，YARN会将其重新启动。</p>
</blockquote>
</li>
<li><p><strong>Flink 程序在面对数据高峰期时如何处理？</strong></p>
<blockquote>
<p>使用 Kafka 把数据先放到消息队列里面作为数据源，再使用 Flink 进行消费，不过这样会影响到一点实时性。</p>
</blockquote>
</li>
<li><p><strong>请详细解释一下 Flink 的 Watermark 机制?</strong></p>
<blockquote>
<p>Watermark 本质是 Flink 中衡量 EventTime 进展的一个机制，主要用来处理乱序数据。Watermark是Flink为了处理EventTime 窗口计算提出的一种机制，本质上也是一种时间戳。</p>
<p>Flink中包括三种时间，Event time：事件产生的时间，它通常由事件的时间戳描述。Ingestion Time：事件进入Flink的时间。Processing Time：事件被处理时当前系统的时间。</p>
<p>目前Apache Flink 有两种生产Watermark的方式，Punctuated - 数据流中每一个递增的EventTime都会产生一个Watermark。Periodic - 周期性的(一定时间间隔或者达到一定的记录条数)产生一个Watermark。</p>
<p>输入数据是，根据Event time将其划分到不同的window中，如果window中有数据，则当Watermark时间 &gt;= Event time时，就符合Window的触发条件。</p>
</blockquote>
</li>
</ol>
<hr>
<h3 id="11-Spring"><a href="#11-Spring" class="headerlink" title="11. Spring"></a>11. Spring</h3><ol>
<li><p><strong>谈一谈Spring？</strong></p>
<blockquote>
<p>Spring 是一种轻量级开发框架，旨在提高开发人员的开发效率以及系统的可维护性。我们一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发。 核心容器中的Core 组件是Spring 所有组件的核心，Beans 组件和 Context 组件是实现IOC和依赖注入的基础，AOP组件用来实现面向切面编程。</p>
</blockquote>
</li>
<li><p><strong>Spring中的设计模式</strong></p>
<blockquote>
<p>简单工厂模式：Spring 中的 BeanFactory，根据传入一个唯一的标识来获得 Bean 实例。</p>
<p>工厂方法模式：Spring 的 FactoryBean 接口的 <code>getObject</code> 方法。</p>
<p>单例模式：Spring 的 ApplicationContext 创建的 Bean 实例都是单例对象。</p>
<p>代理模式：Spring 的 AOP。</p>
<p>适配器模式：Spring MVC 中的 HandlerAdapter，由于 handler 有很多种形式，包括 Controller、HttpRequestHandler、Servlet 等，但调用方式又是确定的，因此需要适配器来进行处理，根据适配规则调用 handle 方法。</p>
</blockquote>
</li>
<li><p><strong>Spring AOP 和 IOC 的底层实现。</strong></p>
<blockquote>
<p><strong>Spring AOP</strong></p>
<p>AOP是面向切面编程，将那些与业务无关的，却可以被所有业务所调用的功能封装起来，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，提高开发的效率。AOP 的实现原理就是代理模式。</p>
<p>代理模式的核心作用就是通过代理，控制对其他对象的访问，并对方法进行一定的增强。</p>
<p>JDK 动态代理是利用反射机制生成一个实现代理接口的匿名类。动态代理类技术核心 Proxy类和一个 InvocationHandler 接口。每个代理的实例都有一个与之关联的 InvocationHandler 实现类。通过为Proxy类指定ClassLoader对象和一组interface来创建动态代理。JDK 动态代理只能只能代理实现了接口的类。</p>
<p>CGLIB 采用了非常底层的字节码技术，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。</p>
<p>Spring AOP 中的代理使用逻辑了：如果目标对象实现了接口，默认情况下会采用 JDK 的动态代理实现 AOP；如果目标对象没有实现了接口，则采用 CGLIB 库。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAopProxyFactory</span> <span class="keyword">implements</span> <span class="title">AopProxyFactory</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"> 	<span class="meta">@Override</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">   		<span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || 						hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">     		Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">     		<span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">       			<span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: "</span> +</span><br><span class="line">           		<span class="string">"Either an interface or a target is required for proxy creation."</span>);</span><br><span class="line">     		&#125;</span><br><span class="line">       	<span class="comment">// 判断目标类是否是接口或者目标类是否Proxy类型，若是则使用JDK动态代理</span></span><br><span class="line">     		<span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">       			<span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">     		&#125;</span><br><span class="line">       	<span class="comment">// 配置了使用CGLIB进行动态代理或者目标类没有接口，那么使用CGLIB的方式创建代理对象</span></span><br><span class="line">     		<span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">   		&#125;</span><br><span class="line">   		<span class="keyword">else</span> &#123;</span><br><span class="line">       	<span class="comment">// 上面的三个方法没有一个为true，那使用JDK的提供的代理方式生成代理对象</span></span><br><span class="line">     		<span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">   		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">   <span class="comment">//其他方法略……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>Spring IOC</strong>:</p>
<p>IOC是控制反转，是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入DI。</p>
<ol>
<li>定义用来描述bean配置的Java类。</li>
<li>解析bean的配置，將bean的配置信息转换为BeanDefinition对象保存在内存中，Spring中采用ConcurrentHashMap进行对象存储。</li>
<li>遍历存放BeanDefinition的Map对象，逐条取出BeanDefinition对象，获取bean的配置信息，利用Java的反射机制实例化对象，將实例化后的对象保存在另外一个Map中。</li>
</ol>
<p>IoC 的思想就是两方之间不互相依赖，由第三方容器来管理相关资源。这样有什么好处呢？</p>
<ol>
<li>对象之间的耦合度或者说依赖程度降低；</li>
<li>资源变的容易管理；比如你用 Spring 容器提供的话很容易就可以实现一个单例。</li>
</ol>
</blockquote>
</li>
<li><p><strong>讲一讲Spring，Spring MVC，Spring Boot。（Spring Boot 了解不？和 Spring 啥区别？spring与springboot比较，SpringBoot的自动启动）</strong></p>
<blockquote>
<p><strong>Spring与Spring boot比较</strong></p>
<p>一、SpringBoot是能够创建出独立的Spring应用程序的</p>
<p>二、简化Spring配置</p>
<ul>
<li><p>Spring由于其繁琐的配置，一度被人成为“配置地狱”，各种XML、Annotation配置，让人眼花缭乱，而且如果出错了也很难找出原因。</p>
</li>
<li><p>Spring Boot项目就是为了解决配置繁琐的问题，最大化的实现convention over configuration(<strong>约定大于配置</strong>)。</p>
</li>
<li><ul>
<li>提供一系列的依赖包来把其它一些工作做成开箱即用其内置一个’Starter POM’，对项目构建进行了<strong>高度封装</strong>，最大化简化项目构建的配置。</li>
</ul>
</li>
</ul>
<p>三、嵌入式Tomcat，Jetty容器，无需部署WAR包</p>
</blockquote>
</li>
<li><p><strong>Spring Bean的生命周期。</strong></p>
<blockquote>
<p>Bean的生命周期可以表达为：Bean的定义——Bean的初始化——Bean的使用——Bean的销毁 。</p>
<p>当一个 bean 被实例化时，它可能需要执行一些初始化使它转换成可用状态。同样，当 bean 不再需要，并且从容器中移除时，可能需要做一些清除工作。</p>
<p>init-method 属性指定一个方法，在实例化 bean 时，立即调用该方法。同样，destroy-method 指定一个方法，只有从容器中移除 bean 之后，才能调用该方法。</p>
</blockquote>
<blockquote>
<ol>
<li><p>Spring容器 从XML 文件中读取bean的定义，并实例化bean。</p>
</li>
<li><p>Spring根据bean的定义填充所有的属性。</p>
</li>
<li><p>如果Bean实现了BeanNameAware 接口，Spring 传递bean 的ID 到 setBeanName方法。</p>
</li>
<li><p>如果Bean 实现了 BeanFactoryAware 接口， Spring传递beanfactory 给setBeanFactory 方法。</p>
</li>
<li><p>如果有任何与bean相关联的BeanPostProcessors，Spring会在postProcesserBeforeInitialization()方法内调用它们。</p>
</li>
<li><p>如果bean实现IntializingBean了，调用它的afterPropertySet方法，如果bean声明了初始化方法，调用此初始化方法。</p>
</li>
<li><p>如果有BeanPostProcessors 和bean关联，这些bean的postProcessAfterInitialization() 方法将被调用。</p>
</li>
<li><p>如果bean实现了 DisposableBean，它将调用destroy()方法。</p>
</li>
</ol>
</blockquote>
</li>
<li><p><strong>Spring Boot 的启动类源码有了解过吗？</strong></p>
</li>
<li><p><strong>Spring事务的实现原理？</strong></p>
<blockquote>
<p>Spring事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring是无法提供事务功能的。</p>
<p>事务的实现原理。如果说你加了一个 <code>@Transactional</code> 注解，此时 Spring 会使用 AOP 思想，对你的这个方法在执行之前，先去开启一个事务。执行完毕之后，根据你的方法是否报错，来决定回滚还是提交事务。</p>
</blockquote>
<blockquote>
<ol>
<li>配置文件开启注解驱动，在相关的类和方法上通过注解@Transactional标识。</li>
<li>spring 在启动的时候会去解析生成相关的bean，这时候会查看拥有相关注解的类和方法，并且为这些类和方法生成代理，并根据@Transaction的相关参数进行相关配置注入，这样就在代理中为我们把相关的事务处理掉了（开启正常提交事务，异常回滚事务）。</li>
<li>真正的数据库层的事务提交和回滚是通过bin log或者redo log实现的。</li>
</ol>
</blockquote>
</li>
<li><p><strong>用过哪些Spring注解，说一下@Autowired依赖注入的底层实现。（依赖注入的原理）</strong></p>
<blockquote>
<p>@Autowired 是按类型自动转配的。自动从spring的上下文找到合适的bean来注入，原理是利用反射机制为类的属性赋值的操作。</p>
<p>在容器启动，为对象赋值的时候，遇到@Autowired注解，会用后置处理器机制，来创建属性的实例，然后再利用反射机制，将实例化好的属性，赋值给对象上，这就是@Autowired的原理。</p>
<p>整个过程，解析bean–&gt;保存beanDefition到IOC容器–&gt;根据beanDefition实例化–&gt;根据BeanpostProcessor依赖注入。</p>
</blockquote>
<blockquote>
<p>@Configuration 和 @Bean：<strong>@Configuration</strong> 的注解类表示这个类可以使用 Spring IoC 容器作为 bean 定义的来源。<strong>@Bean</strong> 注解告诉 Spring，一个带有 @Bean 的注解方法将返回一个对象，该对象应该被注册为在 Spring 应用程序上下文中的 bean。</p>
<p>@Service，@Controller，@Repository分别标记类是Service层类，Controller层类，数据存储层的类，spring扫描注解配置时，会标记这些类要生成bean。@Component是一种泛指，标记类是组件，spring扫描注解配置时，会标记这些类要生成bean。</p>
<p>@Autowired和@Resource是用来修饰字段，构造函数，或者设置方法，并做注入的。而@Service，@Controller，@Repository，@Component则是用来修饰类。</p>
</blockquote>
</li>
<li><p><strong>Spring的三级缓存</strong></p>
<blockquote>
<p>Spring启动过程大致如下：<br>1.加载配置文件<br>2.解析配置文件转化beanDefination，获取到bean的所有属性、依赖及初始化用到的各类处理器等<br>3.创建beanFactory并初始化所有单例bean<br>4.注册所有的单例bean并返回可用的容器，一般为扩展的applicationContext。</p>
</blockquote>
<blockquote>
<ol>
<li><code>singletonObjects</code>：用于存放完全初始化好的 bean，<strong>从该缓存中取出的 bean 可以直接使用</strong></li>
<li><code>earlySingletonObjects</code>：提前曝光的单例对象的cache，存放原始的 bean 对象（尚未填充属性），用于解决循环依赖</li>
<li><code>singletonFactories</code>：单例对象工厂的cache，存放 bean 工厂对象，用于解决循环依赖</li>
</ol>
<p>所有单例的bean初始化完成后会存放在一个Map(<strong>singletonObjects</strong>)中。<strong>一级缓存之后的其他缓存(二三级缓存)就是为了解决循环依赖</strong>！先将没有填充属性的对象缓存起来，需要的时候先去用这个对象，不必等待一个对象完整的初始化好。而为什么是三级缓存不是二级缓存呢，这里笼统的来说还是方便 Spring 或者开发者们去拓展一些东西（比如后置处理器）。</p>
</blockquote>
</li>
<li><p><strong>SpringMVC运行过程？</strong></p>
<blockquote>
<p>客户端发送请求-&gt; 前端控制器 DispatcherServlet 接受客户端请求 -&gt; 找到处理器映射 HandlerMapping 解析请求对应的 Handler-&gt; HandlerAdapter 会根据 Handler 来调用真正的处理器开处理请求，并处理相应的业务逻辑 -&gt; 处理器返回一个模型视图 ModelAndView -&gt; 视图解析器进行解析 -&gt; 返回一个视图对象-&gt;前端控制器 DispatcherServlet 渲染数据（Moder）-&gt;将得到视图对象返回给用户</p>
<p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-10-11/49790288.jpg" alt="SpringMVCè¿è¡åç"></p>
<p><strong>流程说明（重要）：</strong></p>
<p>（1）客户端（浏览器）发送请求，直接请求到 DispatcherServlet。</p>
<p>（2）DispatcherServlet 根据请求信息调用 HandlerMapping，解析请求对应的 Handler。</p>
<p>（3）解析到对应的 Handler（也就是我们平常说的 Controller 控制器）后，开始由 HandlerAdapter 适配器处理。</p>
<p>（4）HandlerAdapter 会根据 Handler 来调用真正的处理器开处理请求，并处理相应的业务逻辑。</p>
<p>（5）处理器处理完业务后，会返回一个 ModelAndView 对象，Model 是返回的数据对象，View 是个逻辑上的 View。</p>
<p>（6）ViewResolver 会根据逻辑 View 查找实际的 View。</p>
<p>（7）DispaterServlet 把返回的 Model 传给 View（视图渲染）。</p>
<p>（8）把 View 返回给请求者（浏览器）</p>
</blockquote>
</li>
</ol>
<hr>
<h3 id="12-Docker"><a href="#12-Docker" class="headerlink" title="12. Docker"></a>12. Docker</h3><ol>
<li><p>介绍一下K8S、Docker技术，和传统虚拟机有什么不一样？</p>
<blockquote>
<p>Docker是一个开源的软件容器平台，开发者可以打包他们的应用及依赖到一个可移植的容器中，发布到流行的Linux机器上，也可实现虚拟化。</p>
<p>k8s是一个开源的容器集群管理系统，可以实现容器集群的自动化部署、自动扩容、维护等功能。</p>
</blockquote>
<blockquote>
<p>容器就是将软件打包成标准化单元，以用于开发、交付和部署。</p>
<p><strong>容器是一个应用层抽象，用于将代码和依赖资源打包在一起。 多个容器可以在同一台机器上运行，共享操作系统内核，但各自作为独立的进程在用户空间中运行</strong> 。</p>
<p><strong>虚拟机 (VM) 是一个物理硬件层抽象，传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程。</strong></p>
</blockquote>
<blockquote>
<p><strong>Docker 中有非常重要的三个基本概念</strong></p>
<ul>
<li><strong>镜像（Image）</strong>：<strong>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。</strong></li>
<li><strong>容器（Container）</strong>：<strong>容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等</strong> 。</li>
<li><strong>仓库（Repository）</strong>：<strong>镜像仓库是 Docker 用来集中存放镜像文件的地方类似于我们之前常用的代码仓库。</strong></li>
</ul>
</blockquote>
</li>
</ol>
<hr>
<h3 id="13-消息队列"><a href="#13-消息队列" class="headerlink" title="13. 消息队列"></a>13. <strong>消息队列</strong></h3><ol>
<li><p><strong>Kafka 是什么？主要应用场景有哪些？</strong></p>
<blockquote>
<p>Kafka 是一个分布式流式处理平台。</p>
<p>流平台具有三个关键功能：</p>
<ol>
<li><strong>消息队列</strong>：发布和订阅消息流，这个功能类似于消息队列，这也是 Kafka 也被归类为消息队列的原因。</li>
<li><strong>容错的持久方式存储记录消息流</strong>： Kafka 会把消息持久化到磁盘，有效避免了消息丢失的风险·。</li>
<li><strong>流式处理平台：</strong> 在消息发布的时候进行处理，Kafka 提供了一个完整的流式处理类库。</li>
</ol>
<p>Kafka 主要有两大应用场景：</p>
<ol>
<li><strong>消息队列</strong> ：建立实时流数据管道，以可靠地在系统或应用程序之间获取数据。</li>
<li><strong>数据处理：</strong> 构建实时的流数据处理程序来转换或处理数据流。</li>
</ol>
</blockquote>
</li>
<li><p><strong>kafka的消息模型</strong></p>
<blockquote>
<p>发布-订阅模型</p>
<p>发布订阅模型（Pub-Sub） 使用<strong>主题（Topic）</strong> 作为消息通信载体，类似于<strong>广播模式</strong>；发布者发布一条消息，该消息通过主题传递给所有的订阅者。</p>
<p><strong>在发布 - 订阅模型中，如果只有一个订阅者，那它和队列模型就基本是一样的了。所以说，发布 - 订阅模型在功能层面上是可以兼容队列模型的。</strong></p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/%E5%B9%BF%E6%92%AD%E6%A8%A1%E5%9E%8B21312.png" alt="img"></p>
</blockquote>
<blockquote>
<p>补充：</p>
<p>当生产者把数据丢进topic时，写在partition上，那partition是怎么将其持久化的呢？Kafka是将partition的数据写在<strong>磁盘</strong>的(消息日志)，不过Kafka只允许<strong>追加写入</strong>(顺序访问)，避免缓慢的随机 I/O 操作。Kafka也不是partition一有数据就立马将数据写到磁盘上，它会先<strong>缓存</strong>一部分，等到足够多数据量或等待一定的时间再批量写入(flush)。</p>
</blockquote>
</li>
</ol>
<hr>
<h3 id="14-经验智力题和经典算法题"><a href="#14-经验智力题和经典算法题" class="headerlink" title="14. 经验智力题和经典算法题"></a>14. 经验智力题和经典算法题</h3><ol>
<li><p><strong>有一个100万（N）数据，怎么快速的查找到前最大的100（n）个数？</strong></p>
<blockquote>
<ol>
<li><p>先取出前100个数，维护一个100个数的最小堆，遍历一遍剩余的元素。</p>
<p>（1）取前n个元素，建立一个小顶堆。时间复杂度为O(nlogn)，为堆排序的时间复杂度。</p>
<p>（2）顺序读取后续元素，每次读取一个元素，如果该元素比堆顶元素小，直接丢弃。 否则，如果大于堆顶元素，则用该元素替换堆顶元素，然后保持最小堆性质。时间复杂度为：O(N-n)*O(logn);</p>
<p>总的时间复杂度为O(Nlongn) 。</p>
</li>
<li><p>根据快速排序划分的思想（快速选择），将所有数划分成大于某个数和小于某个数的区间。每次在符合条件的区间再次进行划分，直到正好100个数。时间复杂度为O(N*n)</p>
</li>
<li><p>分块查找：将这100万的数字，平分为100份，从每一份中取出最大的100个数字；将这1万个数字组合在一起，找到最大的100个数。</p>
</li>
</ol>
</blockquote>
</li>
<li><p><strong>海量日志数据，提取出某日访问百度次数最多的K个IP。</strong>（海量数据找重复次数最多的个数）</p>
<blockquote>
<ol>
<li>按照IP地址的 Hash(IP) mod 1000，把海量IP日志分别存储到1000个小文件中。</li>
<li>对于每一个小文件，可以构建一个IP为key，出现次数为value的HashMap，同时记录前K个次数最多的IP地址；</li>
<li>如果n = 1，可以得到1000个小文件中的出现次数最多的IP，再依据常规的排序算法得到总体上出现次数最多的IP；</li>
<li>如果n &gt; 1,  将 1000 * K 条结果，存储到一个文件中，对其进行排序，得到最多的K个IP。</li>
<li>或最后借助堆这个数据结构，找出Top K。</li>
</ol>
</blockquote>
</li>
<li><p><strong>给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？</strong></p>
<blockquote>
<ol>
<li>遍历文件a，对每个url求取 hash(url) % 1000，然后根据所取得的值将url分别存储到1000个小文件。</li>
<li>遍历文件b，对每个url求取 hash(url) % 1000，然后根据所取得的值将url分别存储到1000个小文件。</li>
<li>求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。</li>
</ol>
</blockquote>
</li>
<li><p><strong>给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？</strong></p>
<blockquote>
<p>使用位图Bit-Map，读入40亿个数，设置相应的bit位，读入要查询的数，查看相应bit位是否为1，为1表示存在，为0表示不存在。</p>
</blockquote>
</li>
<li><p><strong>如何使用2G内存对10G数据进行排序——外部排序算法</strong></p>
</li>
<li><p><strong>部门工资最高的员工</strong></p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT Employee.Name AS Department, Department.Name AS Employee, Salary</span><br><span class="line">FROM Employee, Department</span><br><span class="line">WHERE Employee.DepartmentId = Department.Id</span><br><span class="line">    AND (DepartmentId, Salary) IN (</span><br><span class="line">        SELECT DepartmentId, MAX(Salary)</span><br><span class="line">        FROM Employee</span><br><span class="line">        GROUP BY DepartmentId)</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>一个深度为5的满二叉树的节点个数有多少个？</strong></p>
<blockquote>
<p>每一层有$2^{i-1}$个节点。</p>
<p> 满二叉树的总节点个数为$2^i - 1$</p>
</blockquote>
</li>
<li><p><strong>如何判断一个单链表是不是有环？</strong></p>
<blockquote>
<p>快慢指针实现。</p>
</blockquote>
</li>
<li><p><strong>a = 1， b = 4， 如何交换，不能使用第三个变量。</strong></p>
<blockquote>
<p>a = a + b</p>
<p>b = a - b</p>
<p>a = a - b</p>
</blockquote>
</li>
<li><p><strong>有两个杯子，一个杯子的容量是3L，一个杯子的容量是5L，如何得到4L的水</strong></p>
<blockquote>
<p>反过来想，首先4L的水肯定是在5L的杯子里面的到。4L的水可以通过3L + 1L得到，也可以通过5L - 1L得到。</p>
<p>（1）1L的水怎么得到呢？5L的杯子和3L的水可以凑出2L的空间。那么在把3L的水倒2L到5L杯子中，最后就只剩下1L的水了。</p>
<p>得到了1L的水，再加上3L的水便有了4L的水。</p>
<p>（2）用方程进行量化：3x + 5y = 4。用 3L 和 5L 的水桶装出 4L 水,可以, 3+3-5+3=4。也就是说3L的杯子需要装满三次，需要倒出一次5L的水。</p>
</blockquote>
</li>
<li><p><strong>红黑树和平衡二叉树？</strong></p>
<blockquote>
<p>排序二叉树虽然可以快速检索，但在最坏的情况下：如果插入的节点集本身就是有序的，要么是由小到大排列，要么是由大到小排列，那么最后得到的排序二叉树将变成链表：所有节点只有左节点（如果插入节点集本身是大到小排列）；或所有节点只有右节点（如果插入节点集本身是小到大排列）。在这种情况下，排序二叉树就变成了普通链表，其检索效率就会很差。</p>
<p>红黑树</p>
<ul>
<li>性质 1：节点非红即黑。</li>
<li>性质 2：根节点永远是黑色的。</li>
<li>性质 3：所有的叶节点都是空节点（即 null），并且是黑色的。</li>
<li>性质 4：每个红色节点的两个子节点都是黑色。（从每个叶子到根的路径上不会有两个连续的红色节点）</li>
<li>性质 5：从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点。</li>
</ul>
<p>红黑树最重要的性质：<strong>从根到叶子的最长的可能路径小于等于最短的可能路径的两倍长</strong>。</p>
<p>红黑树并不是真正意义上的平衡二叉树，但在实际应用中，红黑树的统计性能要高于平衡二叉树，但极端性能略差。(对于AVL树，任何一个节点的两个子树高度差不会超过1；对于红黑树，则是不会相差两倍以上)</p>
<p>对于给定的黑色高度为 N 的红黑树，从根到叶子节点的最短路径长度为 N-1，最长路径长度为 2 * (N-1)。对于红黑树，插入，删除，查找的复杂度都是O(log N)。任何不平衡都会在3次旋转之内解决。</p>
<p>红黑树通过上面这种限制来保证它大致是平衡的——因为红黑树的高度不会无限增高，这样保证红黑树在最坏情况下都是高效的，不会出现普通排序二叉树的情况。</p>
<p>由于红黑树只是一个特殊的排序二叉树，因此对红黑树上的只读操作与普通排序二叉树上的只读操作完全相同，只是红黑树保持了大致平衡，因此检索性能比排序二叉树要好很多。</p>
<p>但在红黑树上进行插入操作和删除操作会导致树不再符合红黑树的特征，因此插入操作和删除操作都需要进行一定的维护，以保证插入节点、删除节点后的树依然是红黑树。</p>
</blockquote>
<blockquote>
<p>平衡二叉树的最差情形：</p>
<p>由平衡二叉树的定义可知，左子树和右子树最多可以相差1层高度，那么多个在同一层的子树就可以依次以相差1层的方式来递减子树的高度，如下图所示是一个拥有4棵子树的树的层高最大差情形。也就是说，一颗高度为H的平衡二叉树，其内部子树高度差最多为[H / 2]。</p>
<p><img src="https://img-blog.csdn.net/20160422105942105?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
</blockquote>
<blockquote>
<p>红黑树的最差情形：</p>
<p>红黑树中红节点的父亲和孩子必须是黑节点，且从根到叶子节点经过的黑节点个数相同，因此<strong>红黑树最小深度是路径上只有黑节点，最大深度是路径上红黑节点相互间隔(重要)</strong>，<strong>因此最大深度 &lt;= 最小深度的两倍</strong>，最大深度是2 * log2（n+1）。</p>
<p><img src="https://img-blog.csdn.net/20160422110311666?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
</blockquote>
<blockquote>
<p>对于AVL树，任何一个节点的两个子树高度差不会超过1；对于红黑树，则是不会相差两倍以上</p>
<p>红黑树的插入删除元素的效率高于平衡二叉树，而查询时间差于平衡二叉树。红黑树的树高可能更高。</p>
</blockquote>
</li>
<li><p><strong>如何实现LRU算法？</strong></p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(1) 分析 Operations</span><br><span class="line">1. 首先最基本的操作就是能够从里面读信息；</span><br><span class="line">2. 那还得能加入新的信息，新的信息进来就是 most recently used 了；</span><br><span class="line">3. 在加新信息之前，还得看看有没有空位，如果没有空间了，得先把老的踢出去，那就需要能够找到那个老家伙并且删除它；</span><br><span class="line">4. 那如果加入的新信息是缓存里已经有的，那意思就是 key 已经有了，要更新 value，那就只需要调整一下这条信息的 priority，它已经从上一次被使用升级为最新使用的了。</span><br><span class="line">(2) 找寻数据结构</span><br><span class="line">1. 第一个操作很明显，我们需要一个能够快速查找的数据结构，非 HashMap 莫属，可是后面的操作 HashMap 就不行了。</span><br><span class="line">2. LinkedList，按照从老到新的顺序，删除、插入、移动，都可以是 O(1) 的！但是删除时还需要一个 previous pointer 才能删掉，所以我需要一个 Doubly List.</span><br><span class="line">数据结构： HashMap + DoublyList（双向链表）</span><br><span class="line">(3) 定义清楚数据结构的内容</span><br><span class="line">	选好了数据结构之后，还需要定义清楚每个数据结构具体存储的是什么，这两个数据结构是如何联系的，这才是核心问题。</span><br><span class="line">	1. 读信息，直接利用HashMap读取Answer，时间复杂度O（1）。</span><br><span class="line">	2. 加入一组新的数据，如果没有这个Key，加进来，添加到链表的首部；如果已经有这个Key，HashMap这里要更新一下Value，还需要吧该节点移动到链表的首部，因为最新被使用了。</span><br><span class="line">	为了达到更新链表的操作，需要记录节点的位置。因此HashMap中不是直接存放的Value，而是存放一个记录Value的节点指针。得到了节点自然也就能得到value。</span><br><span class="line">	之后我们更新、移动每个节点时，它的 reference 也不需要变，所以 HashMap也不用改动，动的只是当前节点的指针指向pre， next.</span><br><span class="line">    最后的数据机构如下：</span><br><span class="line">    HashMap                Doubly List</span><br><span class="line">    Key   =&gt;  Node   =&gt;    Value, pre, next</span><br><span class="line">    </span><br><span class="line">    Java 中的 LinkedHashMap 已经做了很好的实现。</span><br><span class="line">    </span><br><span class="line">(4) 6. 总结</span><br><span class="line">1. 第一个操作，get() API，直接读取并更新节点在链表中位置即可；</span><br><span class="line">2，第二个操作，put() API，画图的时候边讲边写，每一步都从 high level 到 detail 再到代码，把代码模块化。</span><br><span class="line">put() =&gt; 有 Key =&gt; 更新Value, 更新节点在链表中的位置</span><br><span class="line">	  =&gt; 无 Key =&gt; 有空位置么 =&gt; 有   =&gt; appendHead()                             </span><br><span class="line">	  						=&gt; 没有 =&gt; remove() + appendHead()</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCacheDoublyList</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">     * LRUCache obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment">     * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment">     * obj.put(key,value);</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// HashMap: &lt;key = Question, value = ListNode&gt;</span></span><br><span class="line">    <span class="comment">// LinkedList: &lt;Answer&gt;</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        Node pre;</span><br><span class="line">        Node next;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, Node&gt; hashMap;</span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="keyword">private</span> Node tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cap;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCacheDoublyList</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        hashMap = <span class="keyword">new</span> HashMap&lt;&gt;(capacity);</span><br><span class="line">        cap = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        Node node = hashMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> val = node.value;</span><br><span class="line">            remove(node);</span><br><span class="line">            appendHead(node);</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        Node node = hashMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            node = <span class="keyword">new</span> Node(key, value);</span><br><span class="line">            <span class="keyword">if</span> (hashMap.size() &gt;= cap) &#123;</span><br><span class="line">                <span class="comment">//为什么要在Node中记录key的原因是：删除HashMap中的reference</span></span><br><span class="line">                hashMap.remove(tail.key);</span><br><span class="line">                remove(tail);</span><br><span class="line">            &#125;</span><br><span class="line">            appendHead(node);</span><br><span class="line">            hashMap.put(key, node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.value = value;</span><br><span class="line">            remove(node);</span><br><span class="line">            appendHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Node curr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == tail) &#123;</span><br><span class="line">            head = tail = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curr == head) &#123;</span><br><span class="line">            head = curr.next;</span><br><span class="line">            head.pre = <span class="keyword">null</span>;</span><br><span class="line">            curr.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curr == tail) &#123;</span><br><span class="line">            tail = curr.pre;</span><br><span class="line">            tail.next = <span class="keyword">null</span>;</span><br><span class="line">            curr.pre = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            curr.pre.next = curr.next;</span><br><span class="line">            curr.next.pre = curr.pre;</span><br><span class="line">            curr.next = <span class="keyword">null</span>;</span><br><span class="line">            curr.pre = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendHead</span><span class="params">(Node curr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> &amp;&amp; tail == <span class="keyword">null</span>) &#123;</span><br><span class="line">            head = curr;</span><br><span class="line">            tail = curr;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head.pre = curr;</span><br><span class="line">            curr.next = head;</span><br><span class="line">            head = curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>手撕代码，二叉树的先序和中序重建二叉树，最后再输出后续遍历结果。</strong></p>
</li>
<li><p><strong>手撕代码，0～n-1中缺失的数字？</strong></p>
<blockquote>
<p>面试官没有提出要求时，需要询问是有序的还是无序的，如果是有序的话可以使用二分查找，时间复杂度O(logn)，如果是无序的数组的话，可以使用位运算或加和的方式解决问题，时间复杂度O(n)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] != mid) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注意这个位置为left，nums[left]为第一个 nums[left] ！= left的数，其前一个为所求答案正好是left</span></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            res ^= nums[i] ^ i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            res += i - nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        res = nums.length + res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>二叉搜索树的第k大节点?</strong></p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        	<span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        	Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        	<span class="keyword">while</span> (root != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            	<span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                	stack.addLast(root);</span><br><span class="line">                	root = root.right;</span><br><span class="line">            	&#125;</span><br><span class="line">            	TreeNode pop = stack.pollLast();</span><br><span class="line">            	<span class="keyword">if</span> (count == k) &#123;</span><br><span class="line">                	<span class="keyword">return</span> pop.val;</span><br><span class="line">            	&#125;</span><br><span class="line">            	count++;</span><br><span class="line">            	root = pop.left;</span><br><span class="line">        	&#125;</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>给定一个链表，删除链表的倒数第 N 个节点，并且返回链表的头结点。</strong></p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//我们可以使用两个指针而不是一个指针。第一个指针从列表的开头向前移动 n+1 步，而第二个指针将从列表的开头出发。现在，这两个指针被 n 个结点分开。我们通过同时移动两个指针向前来保持这个恒定的间隔，直到第一个指针到达最后一个结点。此时第二个指针将指向从最后一个结点数起的第 n 个结点。我们重新链接第二个指针所引用的结点的 next 指针指向该结点的下下个结点。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    ListNode first = dummy;</span><br><span class="line">    ListNode second = dummy;</span><br><span class="line">    <span class="comment">// Advances first pointer so that the gap between first and second is n nodes apart</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        first = first.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Move first to the end, maintaining the gap</span></span><br><span class="line">    <span class="keyword">while</span> (first != <span class="keyword">null</span>) &#123;</span><br><span class="line">        first = first.next;</span><br><span class="line">        second = second.next;</span><br><span class="line">    &#125;</span><br><span class="line">    second.next = second.next.next;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>微信抢红包设计</strong></p>
</li>
<li><p><strong>两根香，一根烧完1小时，如何测量15分钟</strong></p>
<blockquote>
<p>先将一根香的一端点燃，另一根香的两端全部点燃。当第二根香全部烧完时，此时已经过了半个小时。再将第一根香的另一端也点燃，那么此时第一根香剩下部分烧完的时间就是 15 min。</p>
</blockquote>
</li>
<li><p><strong>有 25 匹马和 5 条赛道，赛马过程无法进行计时，只能知道相对快慢。问最少需要几场赛马可以知道前 3 名。</strong></p>
<blockquote>
<p>先把 25 匹马分成 5 组，进行 5 场赛马，得到每组的排名。再将每组的第 1 名选出，进行 1 场赛马，按照这场的排名将 5 组先后标为 A、B、C、D、E。可以知道，A 组的第 1 名就是所有 25 匹马的第 1 名。而第 2、3 名只可能在 A 组的 2、3 名，B 组的第 1、2 名，和 C 组的第 1 名，总共 5 匹马，让这 5 匹马再进行 1 场赛马，前两名就是第 2、3 名。所以总共是 <strong>5+1+1=7</strong> 场赛马。</p>
</blockquote>
</li>
<li><p><strong>有 9 个球，其中 8 个球质量相同，有 1 个球比较重。要求用 2 次天平，找出比较重的那个球。</strong></p>
<blockquote>
<p>将这些球均分成 3 个一组共 3 组，选出 2 组称重，如果 1 组比较重，那么重球在比较重的那 1 组；如果 1 组重量相等，那么重球在另外 1 组。对比较重的那 1 组的 3 个球再分成 3 组，重复上面的步骤。</p>
</blockquote>
</li>
<li><p><strong>两个线程交替打印两个数组中的元素</strong></p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintArray</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] digit = <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>,<span class="string">'7'</span>,<span class="string">'8'</span>,<span class="string">'9'</span>&#125;;</span><br><span class="line">        <span class="keyword">char</span>[] letter = <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>,<span class="string">'F'</span>,<span class="string">'G'</span>,<span class="string">'H'</span>,<span class="string">'I'</span>&#125;;</span><br><span class="line">        ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        Condition condition1 = lock.newCondition();</span><br><span class="line">        Condition condition2 = lock.newCondition();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; digit.length; i++) &#123;</span><br><span class="line">                    System.out.println(digit[i]);</span><br><span class="line">                    condition2.signal();</span><br><span class="line">                    condition1.await();</span><br><span class="line">                &#125;</span><br><span class="line">                condition2.signal();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; letter.length; i++) &#123;</span><br><span class="line">                    System.out.println(letter[i]);</span><br><span class="line">                    condition1.signal();</span><br><span class="line">                    condition2.await();</span><br><span class="line">                &#125;</span><br><span class="line">                condition1.signal();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintArray</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">char</span>[] number = &#123;<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>,<span class="string">'7'</span>,<span class="string">'8'</span>,<span class="string">'9'</span>&#125;;</span><br><span class="line">        <span class="keyword">char</span>[] letter = &#123;<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>,<span class="string">'F'</span>,<span class="string">'G'</span>,<span class="string">'H'</span>,<span class="string">'I'</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">char</span> num : number)&#123;</span><br><span class="line">                    System.out.print(num + <span class="string">" "</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        obj.notify(); <span class="comment">//叫醒其他线程，这里就是t2</span></span><br><span class="line">                        obj.wait(); <span class="comment">//让自己阻塞，让出锁</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                obj.notify(); <span class="comment">//必须要有，因为两个线程的try里面的最后一步是阻塞，如果线程执行完了还在阻塞肯定不对，必须要唤醒，才能正确结束程序</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">char</span> let : letter)&#123;</span><br><span class="line">                    System.out.print(let + <span class="string">" "</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        obj.notify(); <span class="comment">//叫醒其他线程，这里是t1</span></span><br><span class="line">                        obj.wait(); <span class="comment">//让自己阻塞，让出锁</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                obj.notify(); <span class="comment">//同上</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>创建3个线程，t1、t2、t3，让让t1在t2之前执行，t2在t3之前执行</strong></p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Join</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125;, <span class="string">"1"</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t1.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125;, <span class="string">"2"</span>);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t2.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125;, <span class="string">"3"</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>三个线程交替打印ABC</strong></p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintAbcByOrder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Print p = <span class="keyword">new</span> Print();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                p.printA();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"A"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                p.printB();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"B"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                p.printC();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"C"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Print</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    Condition a = lock.newCondition();</span><br><span class="line">    Condition b = lock.newCondition();</span><br><span class="line">    Condition c = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> statue = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (statue != <span class="number">1</span>) &#123;</span><br><span class="line">                a.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"A"</span>);</span><br><span class="line">            statue = <span class="number">2</span>;</span><br><span class="line">            b.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (statue != <span class="number">2</span>) &#123;</span><br><span class="line">                b.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"B"</span>);</span><br><span class="line">            statue = <span class="number">3</span>;</span><br><span class="line">            c.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (statue != <span class="number">3</span>) &#123;</span><br><span class="line">                c.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"C"</span>);</span><br><span class="line">            statue = <span class="number">1</span>;</span><br><span class="line">            a.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>生产者消费者模式</strong></p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerAndComsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Repository repository = <span class="keyword">new</span> Repository();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Producer(repository), <span class="string">"t1"</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Producer(repository), <span class="string">"t2"</span>);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Producer(repository), <span class="string">"t3"</span>);</span><br><span class="line">        Thread t4 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer(repository), <span class="string">"t4"</span>);</span><br><span class="line">        Thread t5 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer(repository), <span class="string">"t5"</span>);</span><br><span class="line">        Thread t6 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer(repository), <span class="string">"t6"</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">        t4.start();</span><br><span class="line">        t5.start();</span><br><span class="line">        t6.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Repository</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> capacity = <span class="number">10</span>;</span><br><span class="line">    LinkedList&lt;Object&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">            <span class="keyword">if</span> (queue.size() == capacity) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    queue.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            queue.offer(<span class="keyword">new</span> Object());</span><br><span class="line">            queue.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">            <span class="keyword">if</span> (queue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    queue.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            queue.poll();</span><br><span class="line">            queue.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    Repository repository;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(Repository repository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.repository = repository;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                repository.produce();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    Repository repository;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Repository repository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.repository = repository;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                repository.consume();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>随机数产生转换（1<del>5到1</del>7）</strong></p>
<blockquote>
<p>题目<br>给定一个随机数生成器，这个生成器能均匀生成1到5（1,5）的随机数，如何使用这个生成器生成均匀分布的1到7（1,7）的数?</p>
<p>思路<br>方法一：生成两个（1,5）的随机数，这样一共是25种情况，注意这两个数是有顺序的，从这25种情况中，取前21种，每三种代表（1,7）中的一个数字，如果取到的是这21种以外的情况，丢掉重新取。</p>
<p>方法二：生成三个（1,5）的随机数，分别表示一个二进制位，其中1和2映射为0，3跳过，4和5映射为1。这样产生的三位二进制数，即1-8这8个数字都是等概率的。如果产生的是8，那么丢弃即可。</p>
<p>方法三：生成两个（1,5）的随机数，产生一个两位的五进制数，5 * (random5() – 1) + random5()。这个公式能够等概率产生1-25，即第一个随机数代表：0,5,10,15,20，地位代表1,2,3,4,5。这样对这个数字（1-25的数字），采用方法一的方法，只用1-21，分7分，代表1-7,22-25这4个数字扔掉。</p>
</blockquote>
</li>
<li><p><strong>二叉树的最小深度和二叉树的最大深度？</strong></p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉树的最小深度</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            min = Math.min(min, minDepth(root.left));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            min = Math.min(min, minDepth(root.right));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉树的最大深度</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = maxDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = maxDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> left &gt; right ? left + <span class="number">1</span> : right + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>实现sqrt()</strong></p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span> || x == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = x;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (x / mid == mid) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x / mid &gt; mid) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>已知 sqrt (2)约等于 1.414，要求不用数学库，求 sqrt (2)精确到小数点后 10 位。</strong></p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">sqrt2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">double</span> low = <span class="number">1.4</span>, high = <span class="number">1.5</span>;</span><br><span class="line">    	<span class="keyword">double</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">    	<span class="keyword">while</span> (high - low &gt; EPSILON) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (mid * mid &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            	high = mid;</span><br><span class="line">        	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            	low = mid;</span><br><span class="line">        	&#125;</span><br><span class="line">        	mid = (high + low) / <span class="number">2</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> mid;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>二叉树的前中后序遍历的非递归实现。</strong></p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从当前节点开始遍历：（当入栈时访问节点内容，则为前序遍历；出栈时访问，则为中序遍历）</span></span><br><span class="line"><span class="comment">     * 1. 若当前节点存在，就存入栈中，并访问左子树；</span></span><br><span class="line"><span class="comment">     * 2. 直到当前节点不存在，就出栈，并通过栈顶节点访问右子树；</span></span><br><span class="line"><span class="comment">     * 3. 不断重复12，直到当前节点不存在且栈空。</span></span><br><span class="line"><span class="comment">     * 只需要在入栈、出栈的时候，分别进行节点访问输出，即可分别得到前序、中序的非递归遍历代码！</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; ans)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.offerLast(cur);</span><br><span class="line">                ans.add(cur.val);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = stack.pollLast();</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; ans)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.offerLast(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = stack.pollLast();</span><br><span class="line">            ans.add(cur.val);</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从当前节点开始遍历：</span></span><br><span class="line"><span class="comment">     * 1. 若当前节点存在，就存入栈中，第一次访问，然后访问其左子树；</span></span><br><span class="line"><span class="comment">     * 2. 直到当前节点不存在，需要回退，这里有两种情况：</span></span><br><span class="line"><span class="comment">     *   1）从左子树回退，通过栈顶节点访问其右子树（取栈顶节点用，但不出栈）</span></span><br><span class="line"><span class="comment">     *   2）从右子树回退，这时需出栈，并取出栈节点做访问输出。（需要注意的是，输出完毕需要置当前节点为空，以便继续回退。具体可参考代码中的 cur = NULL）</span></span><br><span class="line"><span class="comment">     * 3. 不断重复12，直到当前节点不存在且栈空。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; ans)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.offerLast(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = stack.peekLast();</span><br><span class="line">            <span class="keyword">if</span> (cur.right == <span class="keyword">null</span> || cur.right == pre) &#123;</span><br><span class="line">                ans.add(cur.val);</span><br><span class="line">                stack.pollLast();</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offerLast(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; levelAns = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = queue.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                TreeNode cur = queue.pollFirst();</span><br><span class="line">                levelAns.add(cur.val);</span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offerLast(cur.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offerLast(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(levelAns);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>实现一个只包含+，-，*，/的数学运算</strong></p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自己后来写的，将就看吧。模拟操作数栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(calculate(<span class="string">"1+2*3*3/5+4/2"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; numStack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        LinkedList&lt;Character&gt; opStack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str.charAt(i) &gt;= <span class="string">'0'</span> &amp;&amp; str.charAt(i) &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!opStack.isEmpty() &amp;&amp; (opStack.peekLast() == <span class="string">'*'</span> || opStack.peekLast() == <span class="string">'/'</span>)) &#123;</span><br><span class="line">                    <span class="keyword">int</span> a = numStack.pollLast();</span><br><span class="line">                    <span class="keyword">int</span> b = str.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">                    <span class="keyword">if</span> (opStack.peekLast() == <span class="string">'*'</span>) &#123;</span><br><span class="line">                        numStack.offerLast(a * b);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        numStack.offerLast(a / b);</span><br><span class="line">                    &#125;</span><br><span class="line">                    opStack.pollLast();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    numStack.offerLast(str.charAt(i) - <span class="string">'0'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                opStack.offerLast(str.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!opStack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">char</span> opt = opStack.pollFirst();</span><br><span class="line">            <span class="keyword">int</span> a = numStack.pollFirst();</span><br><span class="line">            <span class="keyword">int</span> b = numStack.pollFirst();</span><br><span class="line">            <span class="keyword">if</span> (opt == <span class="string">'+'</span>) &#123;</span><br><span class="line">                numStack.offerFirst(a + b);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                numStack.offerFirst(a - b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numStack.pollLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>字典树的实现。</strong></p>
<blockquote>
<p>Trie的核心思想是空间换时间。<strong>利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TrieNode root;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (word == <span class="keyword">null</span> || word.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TrieNode cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> a = word.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (cur.getContent().get(a) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                TrieNode p = <span class="keyword">new</span> TrieNode();</span><br><span class="line">                cur.getContent().put(a, p);</span><br><span class="line">                cur = p;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.getContent().get(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.setEnd(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (word == <span class="keyword">null</span> || word.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TrieNode cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> a = word.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> ((cur = cur.getContent().get(a)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.isEnd();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prefix == <span class="keyword">null</span> || prefix.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TrieNode cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> a = prefix.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> ((cur = cur.getContent().get(a)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> isEnd;</span><br><span class="line">        <span class="keyword">private</span> HashMap&lt;Character, TrieNode&gt; content; <span class="comment">//可以用数组，也可以用Hash表</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            isEnd = <span class="keyword">false</span>;</span><br><span class="line">            content = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> isEnd;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnd</span><span class="params">(<span class="keyword">boolean</span> end)</span> </span>&#123;</span><br><span class="line">            isEnd = end;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> HashMap&lt;Character, TrieNode&gt; <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> content;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(HashMap&lt;Character, TrieNode&gt; content)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.content = content;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
<hr>
<h3 id="15-高频算法题"><a href="#15-高频算法题" class="headerlink" title="15. 高频算法题"></a>15. 高频算法题</h3><blockquote>
<ol>
<li><p>快排</p>
</li>
<li><p>前缀树</p>
</li>
<li><p>判断链表有环</p>
</li>
<li><p>求环的入口</p>
</li>
<li><p>最大公因数</p>
</li>
<li><p>两个链表找交点</p>
</li>
<li><p>topK</p>
</li>
<li><p>LRU</p>
</li>
<li><p>两个栈实现一个队列</p>
</li>
<li><p>树层次遍历第一层从左往右，第二层从右向左</p>
</li>
<li><p>最长公共子序列</p>
</li>
<li><p>最长上升子序列</p>
</li>
<li><p>最大子段和</p>
</li>
<li><p>股票买卖系列</p>
</li>
<li><p>合并k个链表</p>
</li>
<li><p>k个一组反转链表</p>
</li>
<li><p>接雨水</p>
</li>
<li><p>零钱兑换</p>
</li>
<li><p>正则表达式匹配</p>
</li>
<li><p>最长连续序列</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//给定一个未排序的整数数组，找出最长连续序列的长度。</span></span><br><span class="line"><span class="comment">//为什么用这个呢？因为这个时间复杂度是O(n)，空间复杂度是O(n)，典型的时间换空间问题。为什么不用直接排序再找连续序列呢？因为直接排序的时间复杂度是O(nlogn)。我他嘛已经两次倒在这个问题上了，每次给的都是时间复杂度最优的算法，但面试官问问为啥要弄得这么复杂干嘛，直接排个序不就完了嘛？？？既然这样，非要说个时间复杂度的比较才行，我还是太菜了，一下子没反应过来是要对方法进行比较。一次字节，一次阿里。看来是注定无缘了吧。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">  		<span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">      			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  		&#125;</span><br><span class="line">  		Set&lt;Integer&gt; numSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">  		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">      			numSet.add(nums[i]);</span><br><span class="line">  		&#125;</span><br><span class="line">  		<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">      			<span class="keyword">int</span> num = nums[i];</span><br><span class="line">      			<span class="keyword">if</span> (numSet.contains(num)) &#123;</span><br><span class="line">          			<span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">          			<span class="keyword">int</span> left = num - <span class="number">1</span>;</span><br><span class="line">          			<span class="keyword">int</span> right = num + <span class="number">1</span>;</span><br><span class="line">          			numSet.remove(num);</span><br><span class="line">          			<span class="keyword">while</span> (numSet.contains(left)) &#123;</span><br><span class="line">              			numSet.remove(left);</span><br><span class="line">              			left--;</span><br><span class="line">              			count++;</span><br><span class="line">          			&#125;</span><br><span class="line">          			<span class="keyword">while</span> (numSet.contains(right)) &#123;</span><br><span class="line">              			numSet.remove(right);</span><br><span class="line">              			right++;</span><br><span class="line">              			count++;</span><br><span class="line">          			&#125;</span><br><span class="line">          			ans = Math.max(ans, count);</span><br><span class="line">      			&#125;  </span><br><span class="line">  		&#125;</span><br><span class="line">  		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
</blockquote>
<hr>
<h3 id="16-其他"><a href="#16-其他" class="headerlink" title="16. 其他"></a>16. 其他</h3><ol>
<li><p><strong>工作想 base 在哪里？为什么？</strong></p>
</li>
<li><p><strong>平时有什么兴趣爱好？</strong></p>
</li>
<li><p><strong>自己未来有什么规划？</strong></p>
</li>
<li><p><strong>平时是如何学习新技术的？（官网/书籍/博客/视频）</strong></p>
</li>
<li><p><strong>一般遇到问题如何解决？（Google 和 Stackoverflow）</strong></p>
</li>
<li><p><strong>介不介意加班？</strong></p>
</li>
<li><p><strong>印象最深的事情是什么？</strong></p>
</li>
<li><p><strong>运维开发是做什么的？</strong></p>
<blockquote>
<p>运维工程师的工作核心主要是保障产品上线后的稳定运行，对在此期间出现的各种问题进行快速解决，并在日常工作中不断优化系统架构和部署的合理性，以提升系统服务。可能会开发一些日志数据的统计工具对系统的相关运行情况进行监控和分析。</p>
</blockquote>
</li>
<li><p><strong>你有什么问题想问我？（重要）</strong></p>
<blockquote>
<p>通用回答：</p>
<p>（1）这是哪个部门，这个部门正在做什么，如果我进来我会接触到什么。</p>
<p>（2）您认为我在哪些方面可以提高自己。</p>
<blockquote>
<ol>
<li>面对 HR 或者其他 Level 比较低的面试官时，你可以问：</li>
</ol>
<p>能不能谈谈你作为一个公司老员工对公司的感受?</p>
<p>能不能问一下，你当时因为什么原因选择加入这家公司的呢或者说这家公司有哪些地方吸引你?</p>
<p>有什么地方你觉得还不太好或者可以继续完善吗？</p>
<p>我觉得我这次表现的不是太好，您有什么建议或者评价给我吗？</p>
<p>接下来我会有一段空档期，有什么值得注意或者建议学习的吗？</p>
</blockquote>
<blockquote>
<ol start="2">
<li>面对部门领导时，你可以问：</li>
</ol>
<p>部门的主要人员分配以及对应的主要工作能简单介绍一下吗？</p>
<p>未来如果我要加入这个团队，你对我的期望是什么？</p>
<p>公司对新入职的员工的培养机制是什么样的呢？</p>
<p>以您来看，这个岗位未来在公司内部的发展如何？</p>
<p>团队现在面临的最大挑战是什么？</p>
<ol start="3">
<li>面对 Level 比较高的(比如总裁，老板)时，你可以问：</li>
</ol>
<p>贵公司的发展目标和方向是什么？</p>
<p>与同行业的竞争者相比，贵公司的核心竞争优势在什么地方？</p>
<p>公司现在面临的最大挑战是什么？   </p>
</blockquote>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>面经总结</category>
        <category>八股文</category>
      </categories>
      <tags>
        <tag>面经总结</tag>
        <tag>八股文</tag>
      </tags>
  </entry>
  <entry>
    <title>每日leetcode</title>
    <url>/posts/1ed4c5ff.html</url>
    <content><![CDATA[<h1 id="leetcode-1016-子串能表示从-1-到-N-数字的二进制串"><a href="#leetcode-1016-子串能表示从-1-到-N-数字的二进制串" class="headerlink" title="leetcode 1016. 子串能表示从 1 到 N 数字的二进制串"></a>leetcode 1016. 子串能表示从 1 到 N 数字的二进制串</h1><p>给定一个二进制字符串 S（一个仅由若干 ‘0’ 和 ‘1’ 构成的字符串）和一个正整数 N，如果对于从 1 到 N 的每个整数 X，其二进制表示都是 S 的子串，就返回 true，否则返回 false。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：S = <span class="string">"0110"</span>, N = <span class="number">3</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：S = <span class="string">"0110"</span>, N = <span class="number">4</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure><a id="more"></a>


<ul>
<li>提示：</li>
</ul>
<ol>
<li>1 &lt;= S.length &lt;= 1000</li>
<li>1 &lt;= N &lt;= 10^9</li>
</ol>
<p>思路：暴力即可，因为要在S中找的是子串，不是子序列，S的长度最大为1000，可表示的数字有限。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">queryString</span><span class="params">(<span class="built_in">string</span> S, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = i;</span><br><span class="line">            <span class="built_in">string</span> t = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">while</span>(x)&#123;</span><br><span class="line">                <span class="keyword">if</span>(x &amp; <span class="number">1</span>) t+=<span class="string">'1'</span>;</span><br><span class="line">                <span class="keyword">else</span> t+=<span class="string">'0'</span>;</span><br><span class="line">                x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            reverse(t.<span class="built_in">begin</span>(), t.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">if</span>(S.<span class="built_in">find</span>(t) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="1306-跳跃游戏-III"><a href="#1306-跳跃游戏-III" class="headerlink" title="1306. 跳跃游戏 III"></a>1306. 跳跃游戏 III</h1><p>这里有一个非负整数数组 $arr$，你最开始位于该数组的起始下标 $start$ 处。当你位于下标 $i$ 处时，你可以跳到 $i + arr[i]$ 或者 $i - arr[i]$。</p>
<p>请你判断自己是否能够跳到对应元素值为 0 的 任一 下标处。</p>
<p>注意，不管是什么情况下，你都无法跳到数组之外。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：arr = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>], start = <span class="number">5</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：</span><br><span class="line">到达值为 <span class="number">0</span> 的下标 <span class="number">3</span> 有以下可能方案：</span><br><span class="line">下标 <span class="number">5</span> -&gt; 下标 <span class="number">4</span> -&gt; 下标 <span class="number">1</span> -&gt; 下标 <span class="number">3</span></span><br><span class="line">下标 <span class="number">5</span> -&gt; 下标 <span class="number">6</span> -&gt; 下标 <span class="number">4</span> -&gt; 下标 <span class="number">1</span> -&gt; 下标 <span class="number">3</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：arr = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>], start = <span class="number">0</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：</span><br><span class="line">到达值为 <span class="number">0</span> 的下标 <span class="number">3</span> 有以下可能方案：</span><br><span class="line">下标 <span class="number">0</span> -&gt; 下标 <span class="number">4</span> -&gt; 下标 <span class="number">1</span> -&gt; 下标 <span class="number">3</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：arr = [<span class="number">3</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>], start = <span class="number">2</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：无法到达值为 <span class="number">0</span> 的下标 <span class="number">1</span> 处。</span><br></pre></td></tr></table></figure>

<ul>
<li>提示：</li>
</ul>
<ol>
<li>$1 &lt;= arr.length &lt;= 5 * 10^4$</li>
<li>$0 &lt;= arr[i] &lt; arr.length$</li>
<li>$0 &lt;= start &lt; arr.length$</li>
</ol>
<p>思路：按照能到的位置bfs即可，设置一个标记数组标记已经访问过的位置。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canReach</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">bool</span> vis[n+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        q.push(start);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">auto</span> p = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(vis[p]) <span class="keyword">continue</span>;</span><br><span class="line">            vis[p]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr[p]==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(p-arr[p] &gt;= <span class="number">0</span> &amp;&amp; !vis[p-arr[p]]) q.push(p-arr[p]);</span><br><span class="line">            <span class="keyword">if</span>(p+arr[p] &lt; n &amp;&amp; !vis[p+arr[p]]) q.push(p+arr[p]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="1371-每个元音包含偶数次的最长子字符串"><a href="#1371-每个元音包含偶数次的最长子字符串" class="headerlink" title="1371. 每个元音包含偶数次的最长子字符串"></a>1371. 每个元音包含偶数次的最长子字符串</h1><p>给你一个字符串 s ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 ‘a’，’e’，’i’，’o’，’u’ ，在子字符串中都恰好出现了偶数次。</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"eleetminicoworoep"</span></span><br><span class="line">输出：<span class="number">13</span></span><br><span class="line">解释：最长子字符串是 <span class="string">"leetminicowor"</span> ，它包含 e，i，o 各 <span class="number">2</span> 个，以及 <span class="number">0</span> 个 a，u 。</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"leetcodeisgreat"</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：最长子字符串是 <span class="string">"leetc"</span> ，其中包含 <span class="number">2</span> 个 e 。</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"bcbcbc"</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：这个示例中，字符串 <span class="string">"bcbcbc"</span> 本身就是最长的，因为所有的元音 a，e，i，o，u 都出现了 <span class="number">0</span> 次。</span><br></pre></td></tr></table></figure>

<ul>
<li>提示：</li>
</ul>
<ol>
<li>$1 &lt;= s.length &lt;= 5 x 10^5$</li>
<li>$s 只包含小写英文字母。$</li>
</ol>
<p>思路：因为此题要找的是元音出现偶数次的最长子串，根据异或的性质可知，我们可以用一个int来标记所有出现的元音，所有元音第一次出现时对应二进制位标记为1，以后再出现时将其对应二进制位与其二进制位异或即可判断出现的所有元音的奇偶情况。<br>举例：amntyyaw,通过标记位标记位表示为：1 1 1 1 1 1 0 0<br>如果当前元音标记int为0，说明0-i的字串是满足要求的，因为如果当前字串中有元音出现奇数次那么标记位中一定有1存在。<br>如果当前元音标记int不为0，假设为x，那么从x首次出现的后一位到以x结尾这段字串是符合要求的，理由显而易见。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTheLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>(), res = <span class="number">0</span>, bitmask = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> hash[<span class="number">32</span>];</span><br><span class="line">        <span class="built_in">fill</span>(hash,hash + <span class="number">32</span>,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'a'</span>)</span><br><span class="line">                bitmask = !i ? <span class="number">1</span>&lt;&lt;<span class="number">0</span> : bitmask ^ (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">'e'</span>)</span><br><span class="line">                bitmask = !i ? <span class="number">1</span>&lt;&lt;<span class="number">1</span> : bitmask ^ (<span class="number">1</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">'i'</span>)</span><br><span class="line">                bitmask = !i ? <span class="number">1</span>&lt;&lt;<span class="number">2</span> : bitmask ^ (<span class="number">1</span>&lt;&lt;<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">'o'</span>)</span><br><span class="line">                bitmask = !i ? <span class="number">1</span>&lt;&lt;<span class="number">3</span> : bitmask ^ (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">'u'</span>)</span><br><span class="line">                bitmask = !i ? <span class="number">1</span>&lt;&lt;<span class="number">4</span> : bitmask ^ (<span class="number">1</span>&lt;&lt;<span class="number">4</span>);</span><br><span class="line">            <span class="keyword">else</span> bitmask = !i ? <span class="number">0</span> : bitmask;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!bitmask) res = <span class="built_in">max</span>(res,i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(hash[bitmask] == <span class="number">-1</span>) hash[bitmask] = i;</span><br><span class="line">            res = <span class="built_in">max</span>(res, i - hash[bitmask]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>模拟</category>
        <category>bfs</category>
        <category>位运算</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>模拟</tag>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>每日leetcode 318. 最大单词长度乘积 712. 两个字符串的最小ACSCII删除和 24. 两两交换链表中的节点 1238. 循环码排列 413. 等差数列划分 983. 最低票价</title>
    <url>/posts/1e44c8fg.html</url>
    <content><![CDATA[<h1 id="leetcode-318-最大单词长度乘积"><a href="#leetcode-318-最大单词长度乘积" class="headerlink" title="leetcode 318. 最大单词长度乘积"></a>leetcode 318. 最大单词长度乘积</h1><p>给定一个字符串数组$words$，找到$length(word[i]) * length(word[j])$的最大值，并且这两个单词不含有公共字母。你可以认为每个单词只包含小写字母。如果不存在这样的两个单词，返回 0。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: [<span class="string">"abcw"</span>,<span class="string">"baz"</span>,<span class="string">"foo"</span>,<span class="string">"bar"</span>,<span class="string">"xtfn"</span>,<span class="string">"abcdef"</span>]</span><br><span class="line">输出: <span class="number">16</span></span><br><span class="line">解释: 这两个单词为 <span class="string">"abcw"</span>, <span class="string">"xtfn"</span>。</span><br></pre></td></tr></table></figure><a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: [<span class="string">"a"</span>,<span class="string">"ab"</span>,<span class="string">"abc"</span>,<span class="string">"d"</span>,<span class="string">"cd"</span>,<span class="string">"bcd"</span>,<span class="string">"abcd"</span>]</span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line">解释: 这两个单词为 <span class="string">"ab"</span>, <span class="string">"cd"</span>。</span><br><span class="line">示例 <span class="number">3</span>:</span><br><span class="line"></span><br><span class="line">输入: [<span class="string">"a"</span>,<span class="string">"aa"</span>,<span class="string">"aaa"</span>,<span class="string">"aaaa"</span>]</span><br><span class="line">输出: <span class="number">0</span></span><br><span class="line">解释: 不存在这样的两个单词。</span><br></pre></td></tr></table></figure>
<ul>
<li>来源：力扣（LeetCode）</li>
<li>链接：<a href="https://leetcode-cn.com/problems/maximum-product-of-word-lengths" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-product-of-word-lengths</a></li>
</ul>
<p>思路：思路：简单水题，用一个int统计从下标0开始到当前字符出现的字符,例如abc对应的二进制位为0，1，2即$2^0+2^1+2^2$,这样就可以用与运算判断两个字符串是否有相同的字符，如果有相同字符则按位与的结果不为0，否则为0，后面根据这个条件找出最大字符串长度乘积即可。</p>
<ul>
<li>时间复杂度：$O(n^2)$</li>
<li>空间复杂度：$O(n^2)$</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = words.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; nums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c:words)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=<span class="number">0</span>,t = c.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;w:c)&#123;</span><br><span class="line">                <span class="keyword">int</span> a = w-<span class="string">'a'</span>;</span><br><span class="line">                v|=<span class="number">1</span>&lt;&lt;a;</span><br><span class="line">            &#125;</span><br><span class="line">            nums.push_back(&#123;v,t&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((nums[i][<span class="number">0</span>] &amp; nums[j][<span class="number">0</span>]) == <span class="number">0</span>)&#123;</span><br><span class="line">                    res = <span class="built_in">max</span>(res,nums[i][<span class="number">1</span>] * nums[j][<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="leetcode-712-两个字符串的最小ASCII删除和"><a href="#leetcode-712-两个字符串的最小ASCII删除和" class="headerlink" title="leetcode-712. 两个字符串的最小ASCII删除和"></a>leetcode-712. 两个字符串的最小ASCII删除和</h1><p>给定两个字符串s1, s2，找到使两个字符串相等所需删除字符的ASCII值的最小和。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: s1 = <span class="string">"sea"</span>, s2 = <span class="string">"eat"</span></span><br><span class="line">输出: <span class="number">231</span></span><br><span class="line">解释: 在 <span class="string">"sea"</span> 中删除 <span class="string">"s"</span> 并将 <span class="string">"s"</span> 的值(<span class="number">115</span>)加入总和。</span><br><span class="line">在 <span class="string">"eat"</span> 中删除 <span class="string">"t"</span> 并将 <span class="number">116</span> 加入总和。</span><br><span class="line">结束时，两个字符串相等，<span class="number">115</span> + <span class="number">116</span> = <span class="number">231</span> 就是符合条件的最小和。</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: s1 = <span class="string">"delete"</span>, s2 = <span class="string">"leet"</span></span><br><span class="line">输出: <span class="number">403</span></span><br><span class="line">解释: 在 <span class="string">"delete"</span> 中删除 <span class="string">"dee"</span> 字符串变成 <span class="string">"let"</span>，</span><br><span class="line">将 <span class="number">100</span>[d]+<span class="number">101</span>[e]+<span class="number">101</span>[e] 加入总和。在 <span class="string">"leet"</span> 中删除 <span class="string">"e"</span> 将 <span class="number">101</span>[e] 加入总和。</span><br><span class="line">结束时，两个字符串都等于 <span class="string">"let"</span>，结果即为 <span class="number">100</span>+<span class="number">101</span>+<span class="number">101</span>+<span class="number">101</span> = <span class="number">403</span> 。</span><br><span class="line">如果改为将两个字符串转换为 <span class="string">"lee"</span> 或 <span class="string">"eet"</span>，我们会得到 <span class="number">433</span> 或 <span class="number">417</span> 的结果，比答案更大。</span><br></pre></td></tr></table></figure>
<p>注意:</p>
<ol>
<li>0 &lt; s1.length, s2.length &lt;= 1000。</li>
<li>所有字符串中的字符ASCII值在[97, 122]之间。</li>
</ol>
<ul>
<li><p>来源：力扣（LeetCode）</p>
</li>
<li><p>链接：<a href="https://leetcode-cn.com/problems/minimum-ascii-delete-sum-for-two-strings" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-ascii-delete-sum-for-two-strings</a><br>思路: 这题与编辑距离差不多，状态表示：$f[i][j]$表示使s的前i个字符和t的前j个字符相等所需删除字符的ASCII值最小和，显然<br>如果$s[i]==t[j]$<br>则$f[i][j]=f[i-1][j-1]$<br>否则，<br>$f[i][j] = min(f[i-1][j] + s[i-1] - ‘a’, f[i][j-1] + t[j-1] - ‘a’) + 97$,<br>即，使s的前i-1个字符和t的前j个字符相等所需删除字符的ASCII值最小和与使s的前i个字符和t的前j-1个字符相等所需删除字符的ASCII值最小和的最小值，前者需要删除s[i]，后者删除t[j]。<br>初始状态为$f[i][0]$和$f[0][j]$。</p>
</li>
<li><p>时间复杂度：$O(n*m)$</p>
</li>
<li><p>空间复杂度：$O(n*m)$</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumDeleteSum</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>(), m = t.<span class="built_in">size</span>(), f[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) f[i][<span class="number">0</span>] += f[i<span class="number">-1</span>][<span class="number">0</span>] + s[i<span class="number">-1</span>] - <span class="string">'a'</span> + <span class="number">97</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) f[<span class="number">0</span>][i] += f[<span class="number">0</span>][i<span class="number">-1</span>] + t[i<span class="number">-1</span>] - <span class="string">'a'</span> + <span class="number">97</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>] == t[j<span class="number">-1</span>]) f[i][j] = f[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span> f[i][j] = <span class="built_in">min</span>(f[i<span class="number">-1</span>][j] + s[i<span class="number">-1</span>] - <span class="string">'a'</span>, f[i][j<span class="number">-1</span>] + t[j<span class="number">-1</span>] - <span class="string">'a'</span>) + <span class="number">97</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="leetcode-24-两两交换链表中的节点"><a href="#leetcode-24-两两交换链表中的节点" class="headerlink" title="leetcode 24. 两两交换链表中的节点"></a>leetcode 24. 两两交换链表中的节点</h1><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：head = [<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<ol>
<li>链表中节点的数目在范围 [0, 100] 内</li>
<li>0 &lt;= Node.val &lt;= 100</li>
</ol>
<ul>
<li>来源：力扣（LeetCode）</li>
<li>链接：<a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs" target="_blank" rel="noopener">https://leetcode-cn.com/problems/swap-nodes-in-pairs</a></li>
</ul>
<p>思路：简单模拟即可，将原链表拆成两部分，下标为奇数的为一部分，偶数为一部分，交叉拼接即可。</p>
<ul>
<li>时间复杂度：$O(n)$</li>
<li>空间复杂度：$O(1)$</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *oddhead=<span class="keyword">new</span> ListNode(<span class="number">-1</span>), *evenhead=<span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode *r=head, *s=oddhead, *t=evenhead;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">auto</span> p = head,sr = p, tr = p;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            r = p-&gt;next;</span><br><span class="line">            p-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">if</span>(cnt &amp; <span class="number">1</span>) s-&gt;next = p, s = s-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> t-&gt;next = p, t = t-&gt;next;</span><br><span class="line">            p = r;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        s = oddhead-&gt;next, t = evenhead-&gt;next;</span><br><span class="line">        ListNode *res= <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        p = res;</span><br><span class="line">        <span class="keyword">while</span>(s &amp;&amp; t)&#123;</span><br><span class="line">            sr = s-&gt;next, tr = t-&gt;next;</span><br><span class="line">            s-&gt;next = <span class="literal">nullptr</span>, t-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            p-&gt;next = t;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            p-&gt;next = s;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            s = sr, t = tr;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;next = s;</span><br><span class="line">        <span class="keyword">return</span> res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="leetcode-1238-循环码排列"><a href="#leetcode-1238-循环码排列" class="headerlink" title="leetcode 1238. 循环码排列"></a>leetcode 1238. 循环码排列</h1><p>给你两个整数 n 和 start。你的任务是返回任意 (0,1,2,,…,2^n-1) 的排列 p，并且满足：</p>
<p>$p[0] = start$<br>$p[i] 和 p[i+1]$的二进制表示形式只有一位不同<br>$p[0] 和 p[2^n -1]$的二进制表示形式也只有一位不同</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：n = <span class="number">2</span>, start = <span class="number">3</span></span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">解释：这个排列的二进制表示是 (<span class="number">11</span>,<span class="number">10</span>,<span class="number">00</span>,<span class="number">01</span>)</span><br><span class="line">     所有的相邻元素都有一位是不同的，另一个有效的排列是 [<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输出：n = <span class="number">3</span>, start = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">解释：这个排列的二进制表示是 (<span class="number">010</span>,<span class="number">110</span>,<span class="number">111</span>,<span class="number">101</span>,<span class="number">100</span>,<span class="number">000</span>,<span class="number">001</span>,<span class="number">011</span>)</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<ol>
<li>$1 &lt;= n &lt;= 16$</li>
<li>$0 &lt;= start &lt; 2^n$</li>
</ol>
<ul>
<li>来源：力扣（LeetCode）</li>
<li>链接：<a href="https://leetcode-cn.com/problems/circular-permutation-in-binary-representation" target="_blank" rel="noopener">https://leetcode-cn.com/problems/circular-permutation-in-binary-representation</a></li>
</ul>
<p>思路：格雷码变种，将0开头的格雷码编码平移到start开头即可。</p>
<ul>
<li>时间复杂度：$O(n)$</li>
<li>空间复杂度：$O(n)$<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; circularPermutation(<span class="keyword">int</span> n, <span class="keyword">int</span> s) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        res.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>,k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &amp; <span class="number">1</span>) res.push_back(res[i<span class="number">-1</span>] ^ <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> res.push_back(res[i<span class="number">-1</span>] ^ <span class="number">2</span>*(res[i<span class="number">-1</span>] &amp; -res[i<span class="number">-1</span>]));</span><br><span class="line">            <span class="keyword">if</span>(res[i] == s) start = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">while</span>(k&lt;(<span class="number">1</span>&lt;&lt;n)) ans.push_back(res[start++ % (<span class="number">1</span>&lt;&lt;n)]),k++;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="leetcode-413-等差数列划分"><a href="#leetcode-413-等差数列划分" class="headerlink" title="leetcode 413. 等差数列划分"></a>leetcode 413. 等差数列划分</h1><p>如果一个数列至少有三个元素，并且任意两个相邻元素之差相同，则称该数列为等差数列。<br>例如，以下数列为等差数列:</p>
<p>1, 3, 5, 7, 9<br>7, 7, 7, 7<br>3, -1, -5, -9<br>以下数列不是等差数列。</p>
<p>1, 1, 2, 5, 7</p>
<p>数组 A 包含 N 个数，且索引从0开始。数组 A 的一个子数组划分为数组 (P, Q)，P 与 Q 是整数且满足 0&lt;=P&lt;Q&lt;N 。</p>
<p>如果满足以下条件，则称子数组(P, Q)为等差数组：</p>
<p>元素 A[P], A[p + 1], …, A[Q - 1], A[Q] 是等差的。并且 P + 1 &lt; Q 。</p>
<p>函数要返回数组 A 中所有为等差数组的子数组个数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">A = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">返回: <span class="number">3</span>, A 中有三个子等差数组: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] 以及自身 [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]。</span><br></pre></td></tr></table></figure>
<ul>
<li>来源：力扣（LeetCode）</li>
<li>链接：<a href="https://leetcode-cn.com/problems/arithmetic-slices" target="_blank" rel="noopener">https://leetcode-cn.com/problems/arithmetic-slices</a></li>
</ul>
<p>思路：双指针，简单数学题。思考过程如下：<br>对于一个长度大于等于3的等差数列，有多少个子数组(长度大于等于3)也是等差数列呢？以1,2,3,4,5举例：<br>对于1开头有3个，分别是1,2,3; 1,2,3,4; 1,2,3,4,5;<br>对于2开头有2个，分别是2,3,4; 2,3,4,5;<br>对于3开头有1个，分别是3,4,5;<br>所以一个长度为n(n&gt;=3)的等差数列的长度大于等于3的子数组有(n-1)*(n-2)/2个。</p>
<ul>
<li>时间复杂度：$O(n)$</li>
<li>空间复杂度：$O(1)$<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.<span class="built_in">size</span>(), i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= n) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> diff = A[j] - A[i];</span><br><span class="line">            <span class="keyword">while</span>(j&lt;n &amp;&amp; A[j] - A[j<span class="number">-1</span>] == diff) j++;</span><br><span class="line">            <span class="keyword">if</span>(j-i&gt;=<span class="number">3</span>)&#123;</span><br><span class="line">                res+=(j-i<span class="number">-1</span>)*(j-i<span class="number">-2</span>)/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i = j<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="leetcode-983-最低票价"><a href="#leetcode-983-最低票价" class="headerlink" title="leetcode 983. 最低票价"></a>leetcode 983. 最低票价</h1><p>在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 days 的数组给出。每一项是一个从 1 到 365 的整数。</p>
<p>火车票有三种不同的销售方式：</p>
<p>一张为期一天的通行证售价为 costs[0] 美元；<br>一张为期七天的通行证售价为 costs[1] 美元；<br>一张为期三十天的通行证售价为 costs[2] 美元。<br>通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张为期 7 天的通行证，那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。</p>
<p>返回你想要完成在给定的列表 days 中列出的每一天的旅行所需要的最低消费。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：days = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">20</span>], costs = [<span class="number">2</span>,<span class="number">7</span>,<span class="number">15</span>]</span><br><span class="line">输出：<span class="number">11</span></span><br><span class="line">解释：</span><br><span class="line">例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划：</span><br><span class="line">在第 <span class="number">1</span> 天，你花了 costs[<span class="number">0</span>] = $<span class="number">2</span> 买了一张为期 <span class="number">1</span> 天的通行证，它将在第 <span class="number">1</span> 天生效。</span><br><span class="line">在第 <span class="number">3</span> 天，你花了 costs[<span class="number">1</span>] = $<span class="number">7</span> 买了一张为期 <span class="number">7</span> 天的通行证，它将在第 <span class="number">3</span>, <span class="number">4</span>, ..., <span class="number">9</span> 天生效。</span><br><span class="line">在第 <span class="number">20</span> 天，你花了 costs[<span class="number">0</span>] = $<span class="number">2</span> 买了一张为期 <span class="number">1</span> 天的通行证，它将在第 <span class="number">20</span> 天生效。</span><br><span class="line">你总共花了 $<span class="number">11</span>，并完成了你计划的每一天旅行。</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：days = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">30</span>,<span class="number">31</span>], costs = [<span class="number">2</span>,<span class="number">7</span>,<span class="number">15</span>]</span><br><span class="line">输出：<span class="number">17</span></span><br><span class="line">解释：</span><br><span class="line">例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划：</span><br><span class="line">在第 <span class="number">1</span> 天，你花了 costs[<span class="number">2</span>] = $<span class="number">15</span> 买了一张为期 <span class="number">30</span> 天的通行证，它将在第 <span class="number">1</span>, <span class="number">2</span>, ..., <span class="number">30</span> 天生效。</span><br><span class="line">在第 <span class="number">31</span> 天，你花了 costs[<span class="number">0</span>] = $<span class="number">2</span> 买了一张为期 <span class="number">1</span> 天的通行证，它将在第 <span class="number">31</span> 天生效。</span><br><span class="line">你总共花了 $<span class="number">17</span>，并完成了你计划的每一天旅行。</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<ol>
<li>1 &lt;= days.length &lt;= 365</li>
<li>1 &lt;= days[i] &lt;= 365</li>
<li>days 按顺序严格递增</li>
<li>costs.length == 3</li>
<li>1 &lt;= costs[i] &lt;= 1000</li>
</ol>
<ul>
<li>来源：力扣（LeetCode）</li>
<li>链接：<a href="https://leetcode-cn.com/problems/minimum-cost-for-tickets" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-cost-for-tickets</a></li>
</ul>
<p>思路:状态表示：f[i]表示完成前i个旅程所需要的最低票价，为了方便，下标从1开始。状态很好想，对于第i个旅程，可由前面与他间隔不超过30天的旅途买票过来。即$f[i] = min(f[i],f[j-1] + cost)$，cost根据间隔的天数确定。</p>
<ul>
<li>时间复杂度：$O(30*n)$</li>
<li>空间复杂度：$O(n)$<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mincostTickets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; days, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; costs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = days.<span class="built_in">size</span>(), mincost = <span class="built_in">min</span>(costs[<span class="number">0</span>],<span class="built_in">min</span>(costs[<span class="number">1</span>],costs[<span class="number">2</span>]));</span><br><span class="line">        <span class="keyword">int</span> f[n+<span class="number">1</span>];</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            f[i] = f[i<span class="number">-1</span>] + mincost;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i<span class="number">-1</span>;j&gt;=<span class="number">1</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(days[i<span class="number">-1</span>] - days[j<span class="number">-1</span>] &lt; <span class="number">7</span>) f[i] = <span class="built_in">min</span>(f[i],f[j<span class="number">-1</span>] + costs[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span>(days[i<span class="number">-1</span>] - days[j<span class="number">-1</span>] &lt; <span class="number">30</span>) f[i] = <span class="built_in">min</span>(f[i],f[j<span class="number">-1</span>] + costs[<span class="number">2</span>]);</span><br><span class="line">                <span class="keyword">if</span>(days[i<span class="number">-1</span>] - days[j<span class="number">-1</span>] &gt;= <span class="number">30</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>动态规划</category>
        <category>模拟</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>每日三题 leetcode 435 无重叠区间 leetcode 452 用最少的箭引爆气球 leetcode 1110 删点成林</title>
    <url>/posts/ebfb6392.html</url>
    <content><![CDATA[<h1 id="leetcode-435-无重叠区间"><a href="#leetcode-435-无重叠区间" class="headerlink" title="leetcode 435 无重叠区间"></a>leetcode 435 无重叠区间</h1><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p><p>注意:</p><p>可以认为区间的终点总是大于它的起点。区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: [ [<span class="number">1</span>,<span class="number">2</span>], [<span class="number">2</span>,<span class="number">3</span>], [<span class="number">3</span>,<span class="number">4</span>], [<span class="number">1</span>,<span class="number">3</span>] ]</span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">解释: 移除 [<span class="number">1</span>,<span class="number">3</span>] 后，剩下的区间没有重叠。</span><br></pre></td></tr></table></figure><a id="more"></a>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: [ [<span class="number">1</span>,<span class="number">2</span>], [<span class="number">1</span>,<span class="number">2</span>], [<span class="number">1</span>,<span class="number">2</span>] ]</span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">解释: 你需要移除两个 [<span class="number">1</span>,<span class="number">2</span>] 来使剩下的区间没有重叠。</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">3</span>:</span><br><span class="line"></span><br><span class="line">输入: [ [<span class="number">1</span>,<span class="number">2</span>], [<span class="number">2</span>,<span class="number">3</span>] ]</span><br><span class="line">输出: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</span><br></pre></td></tr></table></figure>
<ul>
<li>来源：力扣（LeetCode）</li>
<li>链接：<a href="https://leetcode-cn.com/problems/non-overlapping-intervals" target="_blank" rel="noopener">https://leetcode-cn.com/problems/non-overlapping-intervals</a></li>
</ul>
<p>思路：经典区间贪心，考虑一下几种情况：<br><img src="/images/pasted-6.png" alt="覆盖"></p>
<p><img src="/images/pasted-7.png" alt="相交"></p>
<p>覆盖时显然要选[x2,y2]因为这段可以容纳的无重叠区间更宽，而相交时，对于虚线右边来说是没有跟它相交的，只要找到右端点不与x2重叠的x3即可，上一段的左端点更新为新的左端点x3。所以将所有区间按照左端点从大到小排列后贪心找出不重叠的区间即可,因为要找到移除的区间所以用总区间个数减去不重叠的区间个数即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = intervals.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        sort(intervals.<span class="built_in">begin</span>(),intervals.<span class="built_in">end</span>(),[&amp;](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;p1,<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;p2)&#123;</span><br><span class="line">            <span class="keyword">return</span> p1[<span class="number">0</span>] == p2[<span class="number">0</span>] ? p1[<span class="number">1</span>] &lt; p2[<span class="number">1</span>] : p1[<span class="number">0</span>] &gt; p2[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>, last = intervals[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(last &gt;= intervals[i][<span class="number">1</span>])&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                last = intervals[i][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n - ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="leetcode-452-用最少的箭引爆气球"><a href="#leetcode-452-用最少的箭引爆气球" class="headerlink" title="leetcode 452 用最少的箭引爆气球"></a>leetcode 452 用最少的箭引爆气球</h1><p>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p>
<p>给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：points = [[<span class="number">10</span>,<span class="number">16</span>],[<span class="number">2</span>,<span class="number">8</span>],[<span class="number">1</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">12</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：对于该样例，x = <span class="number">6</span> 可以射爆 [<span class="number">2</span>,<span class="number">8</span>],[<span class="number">1</span>,<span class="number">6</span>] 两个气球，以及 x = <span class="number">11</span> 射爆另外两个气球</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：points = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>]]</span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：points = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">5</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">4</span>：</span><br><span class="line"></span><br><span class="line">输入：points = [[<span class="number">1</span>,<span class="number">2</span>]]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">5</span>：</span><br><span class="line"></span><br><span class="line">输入：points = [[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ol>
<li>$0 &lt;= points.length &lt;= 10^4$</li>
<li>$points[i].length == 2$</li>
<li>$-2^{31} &lt;= xstart &lt; xend &lt;= 2^{31} - 1$</li>
</ol>
<ul>
<li>来源：力扣（LeetCode）</li>
<li>链接：<a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons</a></li>
</ul>
<p>思路：跟上题思路差不多，只不过当上一个区间的左端点与当前区间右端点重合时不需要更新答案，因为可以在重合的边界处同时引爆。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = intervals.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        sort(intervals.<span class="built_in">begin</span>(),intervals.<span class="built_in">end</span>(),[&amp;](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;p1,<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;p2)&#123;</span><br><span class="line">            <span class="keyword">return</span> p1[<span class="number">0</span>] == p2[<span class="number">0</span>] ? p1[<span class="number">1</span>] &lt; p2[<span class="number">1</span>] : p1[<span class="number">0</span>] &gt; p2[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>, last = intervals[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(last &gt; intervals[i][<span class="number">1</span>])&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                last = intervals[i][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="leetcode-1110-删点成林"><a href="#leetcode-1110-删点成林" class="headerlink" title="leetcode 1110 删点成林"></a>leetcode 1110 删点成林</h1><p>给出二叉树的根节点 root，树上每个节点都有一个不同的值。</p>
<p>如果节点值在 to_delete 中出现，我们就把该节点从树上删去，最后得到一个森林（一些不相交的树构成的集合）。</p>
<p>返回森林中的每棵树。你可以按任意顺序组织答案。</p>
<p><img src="/images/pasted-8.png" alt="树"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>], to_delete = [<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">2</span>,null,<span class="number">4</span>],[<span class="number">6</span>],[<span class="number">7</span>]]</span><br></pre></td></tr></table></figure>
<ul>
<li>来源：力扣（LeetCode）</li>
<li>链接：<a href="https://leetcode-cn.com/problems/delete-nodes-and-return-forest" target="_blank" rel="noopener">https://leetcode-cn.com/problems/delete-nodes-and-return-forest</a></li>
</ul>
<p>思路：因为先序遍历可以先访问根节点，所以可以在做先序遍历的时候添加答案，但是这样会有问题，假如当前节点不用删除，先序访问到当前节点时要加入答案中，但是如果该节点的祖先节点中如果已经加入答案中了，这个节点就重复加入了，所以在递归的时候要引入一个标记位来标记当前节点能不能被加入答案中，1表示可以加，0表示不可加，如果一个节点要被删除，那么它的子节点就有加入答案数组中的机会了，所以要重置标记为1，再删掉这个点，因为每个节点值都不同，所以可以用一个哈希表来记录节点是否删除。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> hash[<span class="number">1001</span>];</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt;res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; delNodes(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; to_delete) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> &amp;c:to_delete) hash[c] = <span class="number">1</span>;</span><br><span class="line">        dfs(root,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* &amp;root,<span class="keyword">bool</span> flag)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> ;</span><br><span class="line">        TreeNode* &amp;l=root-&gt;left, *&amp;r = root-&gt;right;</span><br><span class="line">        <span class="keyword">if</span>(hash[root-&gt;val]) flag = <span class="number">1</span>, root = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">if</span>(flag) res.push_back(root), flag=<span class="number">0</span>;</span><br><span class="line">        dfs(l,flag);</span><br><span class="line">        dfs(r,flag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>每日三题</category>
        <category>贪心</category>
        <category>dfs</category>
      </categories>
      <tags>
        <tag>dfs</tag>
        <tag>贪心</tag>
        <tag>每日三题</tag>
      </tags>
  </entry>
  <entry>
    <title>每日三题 leetcode 242 有效的字母异位词 leetCode 79 单词搜索, leetcode 842 将数组拆分成斐波那契序列</title>
    <url>/posts/29e908e7.html</url>
    <content><![CDATA[<h1 id="leetcode-242-有效的字母异位词"><a href="#leetcode-242-有效的字母异位词" class="headerlink" title="leetcode 242. 有效的字母异位词"></a>leetcode 242. 有效的字母异位词</h1><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: s = <span class="string">"anagram"</span>, t = <span class="string">"nagaram"</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: s = <span class="string">"rat"</span>, t = <span class="string">"car"</span></span><br><span class="line">输出: <span class="literal">false</span></span><br><span class="line">说明:</span><br><span class="line">你可以假设字符串只包含小写字母。</span><br></pre></td></tr></table></figure><a id="more"></a>


<ul>
<li>来源：力扣（LeetCode）</li>
<li>链接：<a href="https://leetcode-cn.com/problems/valid-anagram" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-anagram</a><br>思路：简单水题咋做都行，直接将出现过的字母统计出现次数最后对比出现的次数是否相等就行。</li>
<li>时间复杂度：$O(n+m)$</li>
<li>空间复杂度：$O(1)$</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;h1(<span class="number">26</span>),h2(<span class="number">26</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c:s) h1[c-<span class="string">'a'</span>]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c:t) h2[c-<span class="string">'a'</span>]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(h1[i] != h2[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="leetcode-79-单词搜索"><a href="#leetcode-79-单词搜索" class="headerlink" title="leetcode 79. 单词搜索"></a>leetcode 79. 单词搜索</h1><p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line">board =</span><br><span class="line">[</span><br><span class="line">  [<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'E'</span>],</span><br><span class="line">  [<span class="string">'S'</span>,<span class="string">'F'</span>,<span class="string">'C'</span>,<span class="string">'S'</span>],</span><br><span class="line">  [<span class="string">'A'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">给定 <span class="keyword">word</span> = <span class="string">"ABCCED"</span>, 返回 <span class="literal">true</span></span><br><span class="line">给定 <span class="keyword">word</span> = <span class="string">"SEE"</span>, 返回 <span class="literal">true</span></span><br><span class="line">给定 <span class="keyword">word</span> = <span class="string">"ABCB"</span>, 返回 <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ol>
<li>board 和 word 中只包含大写和小写英文字母。</li>
<li>1 &lt;= board.length &lt;= 200</li>
<li>1 &lt;= board[i].length &lt;= 200</li>
<li>1 &lt;= word.length &lt;= 10^3</li>
</ol>
<ul>
<li>来源：力扣（LeetCode）</li>
<li>链接：<a href="https://leetcode-cn.com/problems/word-search" target="_blank" rel="noopener">https://leetcode-cn.com/problems/word-search</a></li>
</ul>
<p>思路：根据当前指向的字母去找即可，简单回溯。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n,m,len;</span><br><span class="line">    <span class="keyword">bool</span> vis[<span class="number">201</span>][<span class="number">201</span>];</span><br><span class="line">    <span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">        n = board.<span class="built_in">size</span>(), m = board[<span class="number">0</span>].<span class="built_in">size</span>(), len = <span class="keyword">word</span>.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="keyword">word</span>[<span class="number">0</span>])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dfs(board,<span class="keyword">word</span>,<span class="number">0</span>,i,j)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> &amp;<span class="keyword">word</span>,<span class="keyword">int</span> pos,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == len<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        vis[x][y] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> newx = x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> newy = y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(newx&lt;<span class="number">0</span> || newx&gt;=n || newy&lt;<span class="number">0</span> || newy&gt;=m) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(vis[newx][newy]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(pos&lt;len<span class="number">-1</span> &amp;&amp; <span class="keyword">word</span>[pos+<span class="number">1</span>] == board[newx][newy])&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(board,<span class="keyword">word</span>,pos+<span class="number">1</span>,newx,newy)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[x][y] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="leetcode-842-将数组拆分成斐波那契序列"><a href="#leetcode-842-将数组拆分成斐波那契序列" class="headerlink" title="leetcode 842. 将数组拆分成斐波那契序列"></a>leetcode 842. 将数组拆分成斐波那契序列</h1><p>给定一个数字字符串 S，比如 S = “123456579”，我们可以将它分成斐波那契式的序列 [123, 456, 579]。形式上，斐波那契式序列是一个非负整数列表 F，且满足：</p>
<ol>
<li>0 &lt;= F[i] &lt;= 2^31 - 1，（也就是说，每个整数都符合 32 位有符号整数类型）；</li>
<li>F.length &gt;= 3；</li>
<li>对于所有的0 &lt;= i &lt; F.length - 2，都有 F[i] + F[i+1] = F[i+2] 成立。</li>
</ol>
<p>另外，请注意，将字符串拆分成小块时，每个块的数字一定不要以零开头，除非这个块是数字 0 本身。返回从 S 拆分出来的任意一组斐波那契式的序列块，如果不能拆分则返回 []。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line">输入：<span class="string">"123456579"</span></span><br><span class="line">输出：[<span class="number">123</span>,<span class="number">456</span>,<span class="number">579</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">2</span>：</span><br><span class="line">输入: <span class="string">"11235813"</span></span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">13</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">3</span>：</span><br><span class="line">输入: <span class="string">"112358130"</span></span><br><span class="line">输出: []</span><br><span class="line">解释: 这项任务无法完成。</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">4</span>：</span><br><span class="line">输入：<span class="string">"0123"</span></span><br><span class="line">输出：[]</span><br><span class="line">解释：每个块的数字不能以零开头，因此 <span class="string">"01"</span>，<span class="string">"2"</span>，<span class="string">"3"</span> 不是有效答案。</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">5</span>：</span><br><span class="line">输入: <span class="string">"1101111"</span></span><br><span class="line">输出: [<span class="number">110</span>, <span class="number">1</span>, <span class="number">111</span>]</span><br><span class="line">解释: 输出 [<span class="number">11</span>,<span class="number">0</span>,<span class="number">11</span>,<span class="number">11</span>] 也同样被接受。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ol>
<li>1 &lt;= S.length &lt;= 200</li>
<li>字符串 S 中只含有数字。</li>
</ol>
<ul>
<li>来源：力扣（LeetCode）</li>
<li>链接：<a href="https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence" target="_blank" rel="noopener">https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence</a><br>思路：简单回溯，按照每一个要添加的数字有多少位递归即可，当前答案中没有两个数则直接加入，否则要添加的数要等于前两项之和，因为每个数不能超过int所以每个数最多10位,要注意一下0开头的数长度只能为1，即0本身。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n,cursize=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; splitIntoFibonacci(<span class="built_in">string</span> s) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cur;</span><br><span class="line">        n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(dfs(s,cur,<span class="number">0</span>)) <span class="keyword">return</span> cur;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> &amp;s,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;cur,<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == n &amp;&amp; cursize &gt;= <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">1</span>;len &lt;= <span class="number">10</span> &amp;&amp; pos+len &lt;= n;len++)&#123;</span><br><span class="line">            <span class="built_in">string</span> t = s.substr(pos,len);</span><br><span class="line">            num = num*<span class="number">10</span> + s[pos+len<span class="number">-1</span>] - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">if</span>(num &lt;= INT_MAX &amp;&amp; (cursize &lt; <span class="number">2</span> || (<span class="keyword">long</span>)cur[cursize<span class="number">-1</span>] + (<span class="keyword">long</span>)cur[cursize<span class="number">-2</span>] == num))&#123;</span><br><span class="line">                cur.push_back(num), cursize++;</span><br><span class="line">                <span class="keyword">if</span>(dfs(s,cur,pos+len)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                cur.pop_back(), cursize--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[pos] == <span class="string">'0'</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>每日三题</category>
        <category>回溯</category>
        <category>哈希</category>
      </categories>
      <tags>
        <tag>回溯</tag>
        <tag>每日三题</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>每日三题 leetcode137 加油站 leetcode 739 每日温度 leetcode 1029 两地调度</title>
    <url>/posts/c4d3e8b1.html</url>
    <content><![CDATA[<h1 id="leetcode-134-加油站"><a href="#leetcode-134-加油站" class="headerlink" title="leetcode 134 加油站"></a>leetcode 134 加油站</h1><blockquote>
<p>在一条环路上有 $N$ 个加油站，其中第$i$个加油站有汽油 $gas[i]$ 升。你有一辆油箱容量无限的的汽车，从第 $i$ 个加油站开往第 $i+1$ 个加油站需要消耗汽油 $cost[i]$ 升。你从其中的一个加油站出发，开始时油箱为空。如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 $-1$。</p>
</blockquote><a id="more"></a>
<ul>
<li>说明: 如果题目有解，该答案即为唯一答案。输入数组均为非空数组，且长度相同。输入数组中的元素均为非负数。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: </span><br><span class="line">gas  = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">cost = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">从 <span class="number">3</span> 号加油站(索引为 <span class="number">3</span> 处)出发，可获得 <span class="number">4</span> 升汽油。此时油箱有 = <span class="number">0</span> + <span class="number">4</span> = <span class="number">4</span> 升汽油</span><br><span class="line">开往 <span class="number">4</span> 号加油站，此时油箱有 <span class="number">4</span> - <span class="number">1</span> + <span class="number">5</span> = <span class="number">8</span> 升汽油</span><br><span class="line">开往 <span class="number">0</span> 号加油站，此时油箱有 <span class="number">8</span> - <span class="number">2</span> + <span class="number">1</span> = <span class="number">7</span> 升汽油</span><br><span class="line">开往 <span class="number">1</span> 号加油站，此时油箱有 <span class="number">7</span> - <span class="number">3</span> + <span class="number">2</span> = <span class="number">6</span> 升汽油</span><br><span class="line">开往 <span class="number">2</span> 号加油站，此时油箱有 <span class="number">6</span> - <span class="number">4</span> + <span class="number">3</span> = <span class="number">5</span> 升汽油</span><br><span class="line">开往 <span class="number">3</span> 号加油站，你需要消耗 <span class="number">5</span> 升汽油，正好足够你返回到 <span class="number">3</span> 号加油站。</span><br><span class="line">因此，<span class="number">3</span> 可为起始索引。</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: </span><br><span class="line">gas  = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">cost = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">输出: <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">你不能从 <span class="number">0</span> 号或 <span class="number">1</span> 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。</span><br><span class="line">我们从 <span class="number">2</span> 号加油站出发，可以获得 <span class="number">4</span> 升汽油。 此时油箱有 = <span class="number">0</span> + <span class="number">4</span> = <span class="number">4</span> 升汽油</span><br><span class="line">开往 <span class="number">0</span> 号加油站，此时油箱有 <span class="number">4</span> - <span class="number">3</span> + <span class="number">2</span> = <span class="number">3</span> 升汽油</span><br><span class="line">开往 <span class="number">1</span> 号加油站，此时油箱有 <span class="number">3</span> - <span class="number">3</span> + <span class="number">3</span> = <span class="number">3</span> 升汽油</span><br><span class="line">你无法返回 <span class="number">2</span> 号加油站，因为返程需要消耗 <span class="number">4</span> 升汽油，但是你的油箱只有 <span class="number">3</span> 升汽油。</span><br><span class="line">因此，无论怎样，你都不可能绕环路行驶一周。</span><br></pre></td></tr></table></figure>

<ul>
<li>来源：力扣（LeetCode）</li>
<li>链接：<a href="https://leetcode-cn.com/problems/gas-station" target="_blank" rel="noopener">https://leetcode-cn.com/problems/gas-station</a></li>
</ul>
<p>思路：每个站的实际消耗为$gas[i]-cost[i]$，要回到出发地，所以可以将数组扩大一倍，指针start指向起点，end指向终点，cur记录当前油箱有多少油，当$cur&lt;0$说明到不了end这个站，移动start指针直到$cur&gt;=0$。如果$end-start+1==n$说明可以从start出发并且回到start。</p>
<ul>
<li>时间复杂度：$O(2*n)$</li>
<li>空间复杂度：$O(n)$<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; gas, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=gas.<span class="built_in">size</span>(),start=<span class="number">0</span>,<span class="built_in">end</span>=<span class="number">0</span>,cur=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) sum[i] = gas[i] - cost[i];</span><br><span class="line">        <span class="keyword">while</span>(start&lt;n &amp;&amp; <span class="built_in">end</span>&lt;<span class="number">2</span>*n)&#123;</span><br><span class="line">            cur+=sum[<span class="built_in">end</span>%n];</span><br><span class="line">            <span class="keyword">if</span>(cur&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(start&lt;n &amp;&amp; cur&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    cur-=sum[start];</span><br><span class="line">                    start++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">end</span> - start + <span class="number">1</span> == n) <span class="keyword">return</span> start;</span><br><span class="line">            <span class="built_in">end</span>++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="leetcode-739-每日温度"><a href="#leetcode-739-每日温度" class="headerlink" title="leetcode 739 每日温度"></a>leetcode 739 每日温度</h1><blockquote>
<p>请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">例如，给定一个列表temperatures = [<span class="number">73</span>, <span class="number">74</span>, <span class="number">75</span>, <span class="number">71</span>, <span class="number">69</span>, <span class="number">72</span>, <span class="number">76</span>, <span class="number">73</span>]，</span><br><span class="line">你的输出应该是[<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]。</span><br></pre></td></tr></table></figure>
<ul>
<li><p>提示：气温列表长度的范围是[1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</p>
</li>
<li><p>来源：力扣（LeetCode）</p>
</li>
<li><p>链接：<a href="https://leetcode-cn.com/problems/daily-temperatures" target="_blank" rel="noopener">https://leetcode-cn.com/problems/daily-temperatures</a></p>
</li>
</ul>
<p>思路：单调栈模板水题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dailyTemperatures(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; T) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = T.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!s.empty() &amp;&amp; T[s.top()] &lt;= T[i]) s.pop();</span><br><span class="line">            <span class="keyword">if</span>(s.empty()) right[i] = n;</span><br><span class="line">            <span class="keyword">else</span> right[i] = s.top();</span><br><span class="line">            s.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(right[i] == n) right[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> right[i] -= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="leetcode-1029-两地调度"><a href="#leetcode-1029-两地调度" class="headerlink" title="leetcode 1029 两地调度"></a>leetcode 1029 两地调度</h1><blockquote>
<p>计划面试 $2N$ 人。第 $i$ 人飞往 A 市的费用为 $costs[i][0]$飞往 B 市的费用为 $costs[i][1]$将每个人都飞到某座城市的最低费用，要求每个城市都有 $N$ 人抵达。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：[[<span class="number">10</span>,<span class="number">20</span>],[<span class="number">30</span>,<span class="number">200</span>],[<span class="number">400</span>,<span class="number">50</span>],[<span class="number">30</span>,<span class="number">20</span>]]</span><br><span class="line">输出：<span class="number">110</span></span><br><span class="line">解释：</span><br><span class="line">第一个人去 A 市，费用为 <span class="number">10</span>。</span><br><span class="line">第二个人去 A 市，费用为 <span class="number">30</span>。</span><br><span class="line">第三个人去 B 市，费用为 <span class="number">50</span>。</span><br><span class="line">第四个人去 B 市，费用为 <span class="number">20</span>。</span><br><span class="line"></span><br><span class="line">最低总费用为 <span class="number">10</span> + <span class="number">30</span> + <span class="number">50</span> + <span class="number">20</span> = <span class="number">110</span>，每个城市都有一半的人在面试。</span><br></pre></td></tr></table></figure>

<ul>
<li>来源：力扣（LeetCode）</li>
<li>链接：<a href="https://leetcode-cn.com/problems/two-city-scheduling" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-city-scheduling</a></li>
</ul>
<p>思路：贪心，按照每个人去两个城市的花费的差的绝对值从大到小排序，差越大说明如果这个人没去花费小的那个城市的话代价更大，因此按照代价选城市，例如[10,20][30,200]这两个，代价差从小到大排好序之后是170，10,如果第二个人去B那他比去A要多花170的花费。A记录去A市的人数，B记录去B市的人数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">twoCitySchedCost</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; costs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = costs.<span class="built_in">size</span>(), A = <span class="number">0</span>, B = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dis(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i) dis[i] = &#123;<span class="built_in">abs</span>(costs[i][<span class="number">1</span>] - costs[i][<span class="number">0</span>]),i&#125;;</span><br><span class="line">        sort(dis.rbegin(),dis.rend());</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;c:dis) &#123;</span><br><span class="line">            <span class="keyword">if</span>(costs[c[<span class="number">1</span>]][<span class="number">0</span>] &lt; costs[c[<span class="number">1</span>]][<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(A &lt; n&gt;&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                    ++A;</span><br><span class="line">                    res+=costs[c[<span class="number">1</span>]][<span class="number">0</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span> res+=costs[c[<span class="number">1</span>]][<span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(B &lt; n&gt;&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                    ++B;</span><br><span class="line">                    res+=costs[c[<span class="number">1</span>]][<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> res+=costs[c[<span class="number">1</span>]][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>贪心</category>
        <category>双指针</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一题 leetcode 968</title>
    <url>/posts/ba8b838c.html</url>
    <content><![CDATA[<blockquote>
<p>给定一个二叉树，我们在树的节点上安装摄像头。节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。计算监控树的所有节点所需的最小摄像头数量。</p>
</blockquote>
<a id="more"></a>

<p><img src="http://cdn.u1.huluxia.com/g4/M01/54/D0/rBAAdl9p6kKAeYMRAAAylHStyAU132.png" alt="example1"><br><img src="http://cdn.u1.huluxia.com/g4/M01/54/D0/rBAAdl9p6naAM37zAABH0kPTnew561.png" alt="example2"></p>
<p>给定树的节点数的范围是 [1, 1000]。</p>
<ul>
<li>来源：力扣（LeetCode）</li>
<li>链接：<a href="https://leetcode-cn.com/problems/binary-tree-cameras/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-cameras/</a></li>
</ul>
<p>思路：将每个节点的状态表示成三个数：0，1，2。0表示该节点未被覆盖，1表示该节点放置摄像头，2表示该节点被覆盖。那么空节点应该被设置成什么转态呢？为了让放置的摄像头的数量最少，应该不让叶节点防止摄像头，也就是在叶节点的父节点放置摄像头，空节点不能放摄像头所以不能是1,如果设成1说明叶节点可以放置摄像头，不符合，所以空节点的状态应该被设成2。所以有以下几个情况：<br>使用后序遍历：<br>1.左右孩子都被覆盖：<br>l=2 &amp; r=2<br>说明该节点出于未覆盖状态。<br>2.左右孩子至少有一个没覆盖：<br>l=0 &amp; r=0<br>l=0 &amp; r=1<br>l=0 &amp; r=2<br>l=1 &amp; r=0<br>l=2 &amp; r=0<br>3.左右孩子至少有一个摄像头：<br>l=1 &amp; r=0<br>l=1 &amp; r=1<br>l=1 &amp; r=2<br>l=0 &amp; r=1<br>l=2 &amp; r=1<br>说明该节点被孩子节点的摄像头覆盖了<br>最后如果根节点如果没被覆盖要再加上一个摄像头。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//0表示节点未被覆盖</span></span><br><span class="line">    <span class="comment">//1表示节点放置摄像头</span></span><br><span class="line">    <span class="comment">//2表示节点被覆盖</span></span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCameraCover</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dfs(root)==<span class="number">0</span>)res++;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> l=dfs(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> r=dfs(root-&gt;right);</span><br><span class="line">        <span class="comment">//左右都被覆盖</span></span><br><span class="line">        <span class="keyword">if</span>(l==<span class="number">2</span> &amp;&amp; r==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//左右至少一个没覆盖</span></span><br><span class="line">        <span class="keyword">if</span>(l==<span class="number">0</span> || r==<span class="number">0</span>)&#123;</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左右至少一个摄像头</span></span><br><span class="line">        <span class="keyword">if</span>(l==<span class="number">1</span> || r==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>动态规划</category>
        <category>dfs</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>leetcode</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode石子游戏专题 van♂游戏</title>
    <url>/posts/c6d1141d.html</url>
    <content><![CDATA[<h2 id="leetcode-877-石子游戏"><a href="#leetcode-877-石子游戏" class="headerlink" title="leetcode 877 石子游戏"></a>leetcode 877 石子游戏</h2><p>亚历克斯和李用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子 piles[i] 。</p>
<p>游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。</p>
<p>亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。</p>
<p>假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 true ，当李赢得比赛时返回 false 。</p>
<a id="more"></a>

 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：[<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：</span><br><span class="line">亚历克斯先开始，只能拿前 <span class="number">5</span> 颗或后 <span class="number">5</span> 颗石子 。</span><br><span class="line">假设他取了前 <span class="number">5</span> 颗，这一行就变成了 [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] 。</span><br><span class="line">如果李拿走前 <span class="number">3</span> 颗，那么剩下的是 [<span class="number">4</span>,<span class="number">5</span>]，亚历克斯拿走后 <span class="number">5</span> 颗赢得 <span class="number">10</span> 分。</span><br><span class="line">如果李拿走后 <span class="number">5</span> 颗，那么剩下的是 [<span class="number">3</span>,<span class="number">4</span>]，亚历克斯拿走后 <span class="number">4</span> 颗赢得 <span class="number">9</span> 分。</span><br><span class="line">这表明，取前 <span class="number">5</span> 颗石子对亚历克斯来说是一个胜利的举动，所以我们返回 <span class="literal">true</span> 。</span><br></pre></td></tr></table></figure>
<ul>
<li><p>$2 &lt;= piles.length &lt;= 500$</p>
</li>
<li><p>$piles.length 是偶数。$</p>
</li>
<li><p>$1 &lt;= piles[i] &lt;= 500$</p>
</li>
<li><p>$sum(piles) 是奇数。$</p>
</li>
<li><p>来源：力扣（LeetCode）</p>
</li>
<li><p>链接：<a href="https://leetcode-cn.com/problems/build-array-where-you-can-find-the-maximum-exactly-k-comparisons" target="_blank" rel="noopener">https://leetcode-cn.com/problems/build-array-where-you-can-find-the-maximum-exactly-k-comparisons</a></p>
</li>
</ul>
<p>思路：典型的区间dp,根据区间长度划分状态，f[i][j]表示取完了除i-j区间之后玩家可得最高分数,如果当前轮到A那么应当在取区间首尾中的最大值，否则只能得到首尾中的最小值。当前轮到谁可以这样确定，因为每轮只能取一次，所以每次剩下的石堆数量要么是奇数，要么是偶数，所以可以根据这个特性来判断是谁取数。<br>有动态转移方程：轮到自己时$dp[i][j]=max(dp[i+1][j]+nums[i],dp[i][j-1]+nums[j]);$<br>轮到对方时，$dp[i][j]=min(dp[i+1][j],dp[i][j-1];$<br>最后判断先手玩家得分是否大于另一个玩家。<br>时间复杂度: $O(n^2)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">stoneGame</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;f(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">if</span>(n &amp; <span class="number">1</span>)<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)f[i][i] = nums[i];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> ; i&lt;=n; i++)&#123;<span class="comment">//枚举区间长度</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j+i<span class="number">-1</span>&lt;n;j++)&#123;<span class="comment">//f[i][j]表示取完了除i-j区间之后 玩家可得最高分数</span></span><br><span class="line">                <span class="keyword">int</span> l = j, r = i+j<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span>((n-(r-l+<span class="number">1</span>))%<span class="number">2</span>==<span class="number">0</span>)f[l][r] = <span class="built_in">max</span>(f[l+<span class="number">1</span>][r] + nums[l],f[l][r<span class="number">-1</span>]+nums[r]);</span><br><span class="line">                <span class="keyword">else</span> f[l][r] = <span class="built_in">min</span>(f[l+<span class="number">1</span>][r],f[l][r<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i=<span class="number">0</span>;i&lt;n;i++)sum+=nums[i];</span><br><span class="line">        <span class="keyword">if</span>(f[<span class="number">0</span>][n<span class="number">-1</span>]&gt;=sum-f[<span class="number">0</span>][n<span class="number">-1</span>])<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-1140-石子游戏-II"><a href="#leetcode-1140-石子游戏-II" class="headerlink" title="leetcode 1140 石子游戏 II"></a>leetcode 1140 石子游戏 II</h2><p>亚历克斯和李继续他们的石子游戏。许多堆石子 排成一行，每堆都有正整数颗石子 piles[i]。游戏以谁手中的石子最多来决出胜负。</p>
<p>亚历克斯和李轮流进行，亚历克斯先开始。最初，M = 1。</p>
<p>在每个玩家的回合中，该玩家可以拿走剩下的 前 X 堆的所有石子，其中 1 &lt;= X &lt;= 2M。然后，令 M = max(M, X)。</p>
<p>游戏一直持续到所有石子都被拿走。</p>
<p>假设亚历克斯和李都发挥出最佳水平，返回亚历克斯可以得到的最大数量的石头。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：piles = [<span class="number">2</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">10</span></span><br><span class="line">解释：</span><br><span class="line">如果亚历克斯在开始时拿走一堆石子，李拿走两堆，接着亚历克斯也拿走两堆。在这种情况下，亚历克斯可以拿到 <span class="number">2</span> + <span class="number">4</span> + <span class="number">4</span> = <span class="number">10</span> 颗石子。 </span><br><span class="line">如果亚历克斯在开始时拿走两堆石子，那么李就可以拿走剩下全部三堆石子。在这种情况下，亚历克斯可以拿到 <span class="number">2</span> + <span class="number">7</span> = <span class="number">9</span> 颗石子。</span><br><span class="line">所以我们返回更大的 <span class="number">10</span>。</span><br></pre></td></tr></table></figure>
<ul>
<li><p>$1 &lt;= piles.length &lt;= 100$</p>
</li>
<li><p>$1 &lt;= piles[i] &lt;= 10 ^ 4$</p>
</li>
<li><p>来源：力扣（LeetCode）</p>
</li>
<li><p>链接：<a href="https://leetcode-cn.com/problems/stone-game-iii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/stone-game-iii</a></p>
</li>
</ul>
<p>思路：只能理解记忆化搜索的思路，没理解dp的思路。memo[i][j]表示从下标i开始取数时,取x(1&lt;=x&lt;=j)堆石子能得到的最多的石子数。所以显然可以记忆化搜索。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> presum[<span class="number">101</span>];</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;memo;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">stoneGameII</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; piles)</span> </span>&#123;</span><br><span class="line">        n = piles.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)presum[i]=presum[i<span class="number">-1</span>]+piles[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">return</span> dfs(piles,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">( <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; piles,<span class="keyword">int</span> start,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(memo.<span class="built_in">find</span>(start)!=memo.<span class="built_in">end</span>() &amp;&amp; memo[start].<span class="built_in">find</span>(m)!=memo[start].<span class="built_in">end</span>())<span class="keyword">return</span> memo[start][m];</span><br><span class="line">        <span class="keyword">if</span>(start&gt;=n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max_stone=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*m;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> nm = <span class="built_in">max</span>(i,m);</span><br><span class="line">            <span class="keyword">int</span> next_max=dfs(piles,start+i,nm);<span class="comment">//对方取得的最大石子数</span></span><br><span class="line">            <span class="comment">//利用前缀和更新自己能获得的最大石子数</span></span><br><span class="line">            max_stone = <span class="built_in">max</span>(max_stone,presum[n] - presum[start]-next_max);</span><br><span class="line">        &#125;</span><br><span class="line">        memo[start][m]=max_stone;</span><br><span class="line">        <span class="keyword">return</span> max_stone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="leetcode-1406-石子游戏-III"><a href="#leetcode-1406-石子游戏-III" class="headerlink" title="leetcode 1406 石子游戏 III"></a>leetcode 1406 石子游戏 III</h2><p>Alice 和 Bob 用几堆石子在做游戏。几堆石子排成一行，每堆石子都对应一个得分，由数组 stoneValue 给出。</p>
<p>Alice 和 Bob 轮流取石子，Alice 总是先开始。在每个玩家的回合中，该玩家可以拿走剩下石子中的的前 1、2 或 3 堆石子 。比赛一直持续到所有石头都被拿走。</p>
<p>每个玩家的最终得分为他所拿到的每堆石子的对应得分之和。每个玩家的初始分数都是 0 。比赛的目标是决出最高分，得分最高的选手将会赢得比赛，比赛也可能会出现平局。</p>
<p>假设 Alice 和 Bob 都采取 最优策略 。如果 Alice 赢了就返回 “Alice” ，Bob 赢了就返回 “Bob”，平局（分数相同）返回 “Tie” 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="string">"Bob"</span></span><br><span class="line">解释：Alice 总是会输，她的最佳选择是拿走前三堆，得分变成 <span class="number">6</span> 。但是 Bob 的得分为 <span class="number">7</span>，Bob 获胜。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">-9</span>]</span><br><span class="line">输出：<span class="string">"Alice"</span></span><br><span class="line">解释：Alice 要想获胜就必须在第一个回合拿走前三堆石子，给 Bob 留下负分。</span><br><span class="line">如果 Alice 只拿走第一堆，那么她的得分为 <span class="number">1</span>，接下来 Bob 拿走第二、三堆，得分为 <span class="number">5</span> 。之后 Alice 只能拿到分数 <span class="number">-9</span> 的石子堆，输掉比赛。</span><br><span class="line">如果 Alice 拿走前两堆，那么她的得分为 <span class="number">3</span>，接下来 Bob 拿走第三堆，得分为 <span class="number">3</span> 。之后 Alice 只能拿到分数 <span class="number">-9</span> 的石子堆，同样会输掉比赛。</span><br><span class="line">注意，他们都应该采取 最优策略 ，所以在这里 Alice 将选择能够使她获胜的方案。</span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>]</span><br><span class="line">输出：<span class="string">"Tie"</span></span><br><span class="line">解释：Alice 无法赢得比赛。如果她决定选择前三堆，她可以以平局结束比赛，否则她就会输。</span><br><span class="line">示例 <span class="number">4</span>：</span><br><span class="line"></span><br><span class="line">输入：values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-3</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="string">"Alice"</span></span><br><span class="line">示例 <span class="number">5</span>：</span><br><span class="line"></span><br><span class="line">输入：values = [<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-3</span>]</span><br><span class="line">输出：<span class="string">"Tie"</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>$1 &lt;= values.length &lt;= 50000$</p>
</li>
<li><p>$-1000 &lt;= values[i] &lt;= 1000$</p>
</li>
<li><p>来源：力扣（LeetCode）</p>
</li>
<li><p>链接：<a href="https://leetcode-cn.com/problems/stone-game-iii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/stone-game-iii</a></p>
</li>
</ul>
<p>思路：f[i]表示从下标i开始取数，先手比后手多的分数。</p>
<ol>
<li>初始值，f(n)=0，其余待定。</li>
<li>转移时，对于 f(i) 有三种决策，取第 i 堆，取第 i 和 i+1 堆，以及取第 i，i+1 和 i+2 堆，对应的转移分别为 $max(s(i)−f(i+1),s(i)+s(i+1)−f(i+2),s(i)+s(i+1)+s(i+2)−f(i+3)$。</li>
<li>最终，如果 f(0)=0，则平局；如果 f(0)&gt;0 则 Alice 胜，否则 Bob 胜。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">stoneGameIII</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stoneValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = stoneValue.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f(n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        f[n] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            f[i] = stoneValue[i] - f[i + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (i &lt; n - <span class="number">1</span>)</span><br><span class="line">                f[i] = <span class="built_in">max</span>(f[i], stoneValue[i] + stoneValue[i + <span class="number">1</span>] - f[i + <span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &lt; n - <span class="number">2</span>)</span><br><span class="line">                f[i] = <span class="built_in">max</span>(f[i], stoneValue[i] + stoneValue[i + <span class="number">1</span>] + stoneValue[i + <span class="number">2</span>] </span><br><span class="line">                                    - f[i + <span class="number">3</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (f[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Tie"</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (f[<span class="number">0</span>] &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Alice"</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">"Bob"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode周赛压轴专题</title>
    <url>/posts/8e79d167.html</url>
    <content><![CDATA[<p>最近周赛的压轴题都是dp，总结一下</p>
<a id="more"></a>
<h2 id="leetcode-1425-带限制的子序列和"><a href="#leetcode-1425-带限制的子序列和" class="headerlink" title="leetcode 1425 带限制的子序列和"></a>leetcode 1425 带限制的子序列和</h2><p>给你一个整数数组 nums 和一个整数 k ，请你返回 非空 子序列元素和的最大值，子序列需要满足：子序列中每两个 相邻 的整数 nums[i] 和 nums[j] ，它们在原数组中的下标 i 和 j 满足 i &lt; j 且 j - i &lt;= k 。</p>
<p>数组的子序列定义为：将数组中的若干个数字删除（可以删除 0 个数字），剩下的数字按照原本的顺序排布。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">10</span>,<span class="number">2</span>,<span class="number">-10</span>,<span class="number">5</span>,<span class="number">20</span>], k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">37</span></span><br><span class="line">解释：子序列为 [<span class="number">10</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">20</span>] 。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-3</span>], k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：子序列必须是非空的，所以我们选择最大的数字。</span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">10</span>,<span class="number">-2</span>,<span class="number">-10</span>,<span class="number">-5</span>,<span class="number">20</span>], k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">23</span></span><br><span class="line">解释：子序列为 [<span class="number">10</span>, <span class="number">-2</span>, <span class="number">-5</span>, <span class="number">20</span>] 。</span><br></pre></td></tr></table></figure>

<p>$1 &lt;= k &lt;= nums.length &lt;= 10^5$<br>$-10^4 &lt;= nums[i] &lt;= 10^4$</p>
<ul>
<li>来源：力扣（LeetCode）</li>
<li>链接：<a href="https://leetcode-cn.com/problems/constrained-subsequence-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/constrained-subsequence-sum</a></li>
</ul>
<p>思路：朴素dp做法就是$dp[i]=nums[i]+max(0,dp[i-k],dp[i-k+1],…dp[i-1)$,dp[i]表示包含nums[i]的满足条件的子序列的最大和,复杂度是$n^2$的，可以使用滑动窗口最大值优化，维护一个大小为k的滑动窗口，有状态转移方程：<br>$dp[i]=max(nums[i],dp[q.front()] + nums[i])$其中dp[q.front()]是滑动窗口中的最大值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">constrainedSubsetSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>(),res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(n);</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">        q.push_back(<span class="number">0</span>);</span><br><span class="line">        res=dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i]=<span class="built_in">max</span>(nums[i],dp[q.front()] + nums[i]);</span><br><span class="line">            res = <span class="built_in">max</span>(res,dp[i]);</span><br><span class="line">            <span class="keyword">while</span>(!q.empty() &amp;&amp; q.front() &lt;= i-k)q.pop_front();</span><br><span class="line">            <span class="keyword">while</span>(!q.empty() &amp;&amp; dp[q.back()] &lt;= dp[i])q.pop_back();</span><br><span class="line">            q.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-1420-生成数组"><a href="#leetcode-1420-生成数组" class="headerlink" title="leetcode 1420 生成数组"></a>leetcode 1420 生成数组</h2><p>给你三个整数 n、m 和 k 。下图描述的算法用于找出正整数数组中最大的元素。<br><img src="https://ftp.bmp.ovh/imgs/2020/05/a0710bef8cb2f459.png" alt=""><br>请你生成一个具有下述属性的数组 arr ：</p>
<p>arr 中有 n 个整数。</p>
<ul>
<li>1 &lt;= arr[i] &lt;= m 其中 (0 &lt;= i &lt; n) 。</li>
<li>将上面提到的算法应用于 arr ，search_cost 的值等于 k 。</li>
<li>返回上述条件下生成数组 arr 的 方法数 ，由于答案可能会很大，所以 必须 对 $10^9 + 7$ 取余。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：n = <span class="number">2</span>, m = <span class="number">3</span>, k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：可能的数组分别为 [<span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">1</span>], [<span class="number">3</span>, <span class="number">2</span>] [<span class="number">3</span>, <span class="number">3</span>]</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：n = <span class="number">5</span>, m = <span class="number">2</span>, k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：没有数组可以满足上述条件</span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：n = <span class="number">9</span>, m = <span class="number">1</span>, k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：可能的数组只有 [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">示例 <span class="number">4</span>：</span><br><span class="line"></span><br><span class="line">输入：n = <span class="number">50</span>, m = <span class="number">100</span>, k = <span class="number">25</span></span><br><span class="line">输出：<span class="number">34549172</span></span><br><span class="line">解释：不要忘了对 <span class="number">1000000007</span> 取余</span><br><span class="line">示例 <span class="number">5</span>：</span><br><span class="line"></span><br><span class="line">输入：n = <span class="number">37</span>, m = <span class="number">17</span>, k = <span class="number">7</span></span><br><span class="line">输出：<span class="number">418930126</span></span><br></pre></td></tr></table></figure>

<p>1 &lt;= n &lt;= 50<br>1 &lt;= m &lt;= 100<br>0 &lt;= k &lt;= n</p>
<p>思路：<br>方法一：朴素dp,dp[i][j][k]表示构建i位数用到的最大数为j的消耗为k的方案数。按照用到的数来进行状态划分。如果上一轮已经用了最大数j，消耗为k，那么这一轮不会生成更大的数，此时是从上一轮中消耗k转移来的,本轮可选共j种可能(1..j),如果上一轮没用最大数j(即用到j-1)，消耗为k,那么当前轮使用最大数j会让消耗加1,所以是从上一轮中消耗k-1转移来的。所以有转移方程:<br>$dp[i][j][k] = dp[i-1][j][k]* j + sum(dp[i-1][1..j-1][k-1])$<br>时间复杂度: $O(km^2n)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000000</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">51</span>][<span class="number">101</span>][<span class="number">51</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numOfArrays</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> M, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;i++)dp[<span class="number">1</span>][i][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=M;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=K;k++)&#123;</span><br><span class="line">                    dp[i][j][k] = (dp[i][j][k] + (<span class="keyword">long</span>)dp[i<span class="number">-1</span>][j][k] * j)%mod;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">1</span>;u&lt;j;u++)&#123;</span><br><span class="line">                        dp[i][j][k]=(dp[i][j][k] + dp[i<span class="number">-1</span>][u][k<span class="number">-1</span>])%mod;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;i++)res=(res+dp[N][i][K])%mod;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>方法二：使用前缀和优化，可以发现其实对于如果从k-1转移过来，加上的方案数是连续的和，所以可以用前缀和来优化。时间复杂度:$O(kmn)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000000</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">51</span>][<span class="number">101</span>][<span class="number">51</span>];</span><br><span class="line">    <span class="keyword">int</span> pre[<span class="number">51</span>][<span class="number">101</span>][<span class="number">51</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numOfArrays</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> M, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;i++)&#123;</span><br><span class="line">            dp[<span class="number">1</span>][i][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">            pre[<span class="number">1</span>][i][<span class="number">1</span>] = pre[<span class="number">1</span>][i<span class="number">-1</span>][<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=M;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=K;k++)&#123;</span><br><span class="line">                    dp[i][j][k] = (dp[i][j][k] + (<span class="keyword">long</span>)dp[i<span class="number">-1</span>][j][k]* j + pre[i<span class="number">-1</span>][j<span class="number">-1</span>][k<span class="number">-1</span>])%mod;</span><br><span class="line">                    pre[i][j][k] = (dp[i][j][k] + pre[i][j<span class="number">-1</span>][k])%mod;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i==N)res=(dp[N][j][K]+res)%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-1416-恢复数组"><a href="#leetcode-1416-恢复数组" class="headerlink" title="leetcode 1416 恢复数组"></a>leetcode 1416 恢复数组</h2><p>某个程序本来应该输出一个整数数组。但是这个程序忘记输出空格了以致输出了一个数字字符串，我们所知道的信息只有：数组中所有整数都在 [1, k] 之间，且数组中的数字都没有前导 0 。</p>
<p>给你字符串 s 和整数 k 。可能会有多种不同的数组恢复结果。</p>
<p>按照上述程序，请你返回所有可能输出字符串 s 的数组方案数。</p>
<p>由于数组方案数可能会很大，请你返回它对 $10^9 + 7$ 取余 后的结果。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">"1317"</span>, k = <span class="number">2000</span></span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：可行的数组方案为 [<span class="number">1317</span>]，[<span class="number">131</span>,<span class="number">7</span>]，[<span class="number">13</span>,<span class="number">17</span>]，[<span class="number">1</span>,<span class="number">317</span>]，[<span class="number">13</span>,<span class="number">1</span>,<span class="number">7</span>]，[<span class="number">1</span>,<span class="number">31</span>,<span class="number">7</span>]，[<span class="number">1</span>,<span class="number">3</span>,<span class="number">17</span>]，[<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">7</span>]</span><br><span class="line">示例 <span class="number">4</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"2020"</span>, k = <span class="number">30</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：唯一可能的数组方案是 [<span class="number">20</span>,<span class="number">20</span>] 。 [<span class="number">2020</span>] 不是可行的数组方案，原因是 <span class="number">2020</span> &gt; <span class="number">30</span> 。 [<span class="number">2</span>,<span class="number">020</span>] 也不是可行的数组方案，因为 <span class="number">020</span> 含有前导 <span class="number">0</span> 。</span><br><span class="line">示例 <span class="number">5</span>：</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"1234567890"</span>, k = <span class="number">90</span></span><br><span class="line">输出：<span class="number">34</span></span><br></pre></td></tr></table></figure>


<ol>
<li>$1 &lt;= s.length &lt;= 10^5.$</li>
<li>s 只包含数字且不包含前导 0 。</li>
<li>$1 &lt;= k &lt;= 10^9.$</li>
</ol>
<p>思路：(动态规划) $O(nlog_{10}k)$<br>设状态 f(i) 表示前 i 个数字的合法划分方案，这里的下标从 1 开始。<br>初始值 f(0)=1，其余为 0。<br>转移时，如果子串 [j + 1, i] 转换为数字后在范围 [1, k] 中，则转移 f(i)=f(i)+f(j)。<br>最终答案为 f(n)。<br>时间复杂度<br>状态数为 O(n)，转移时，j 不会小于 $i−log_{10}k−1$，所以总时间复杂度为 $O(nlog_{10}k)$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000000</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfArrays</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(n+<span class="number">1</span>);</span><br><span class="line">       dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">           <span class="keyword">long</span> cur=<span class="number">0</span>,p=<span class="number">1</span>;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>&amp;&amp;p&lt;=<span class="number">1e9</span>;j--,p*=<span class="number">10</span>)&#123;</span><br><span class="line">               cur += (s[j]-<span class="string">'0'</span>)*p;</span><br><span class="line">               <span class="keyword">if</span>(cur&lt;=k &amp;&amp; s[j]!=<span class="string">'0'</span>)dp[i]=(dp[i] + dp[j])%mod;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-trie树专题</title>
    <url>/posts/e8b1e390.html</url>
    <content><![CDATA[<p>trie树，又称单词查找树，前缀树，字典树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计，自动补全等。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。</p>
<a id="more"></a>

<p>看下trie树大概长什么样<br><img src="https://ae01.alicdn.com/kf/H81a9999ad51b4d2c97e06f29d3fce80dI.jpg" alt="trie树"><br>其实就是一种简单的数据结构。</p>
<p>下面从题目开始入手。</p>
<p><img src="https://ae01.alicdn.com/kf/Hac96a93c5bd445a592f4334f2b45a2289.png" alt="upload successful"></p>
<p>思路：用结构体表示节点，is_end表示是否是单词的结尾，child数组表示后继节点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">        <span class="keyword">bool</span> is_end;</span><br><span class="line">        Node *child[<span class="number">26</span>];</span><br><span class="line">        </span><br><span class="line">        Node()&#123;</span><br><span class="line">            is_end = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)child[i]=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;*root;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    Trie() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> Node();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:<span class="keyword">word</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = c-<span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(!p-&gt;child[a])&#123;</span><br><span class="line">                Node *newnode = <span class="keyword">new</span> Node();</span><br><span class="line">                p-&gt;child[a] = newnode;</span><br><span class="line">            &#125;</span><br><span class="line">            p=p-&gt;child[a];</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;is_end = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:<span class="keyword">word</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = c - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(!p-&gt;child[a])<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p=p-&gt;child[a];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;is_end;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:prefix)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = c - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(!p-&gt;child[a])<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p=p-&gt;child[a];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie* obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj-&gt;insert(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(word);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj-&gt;startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>trie树</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数据结构</tag>
        <tag>trie树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 第24场双周赛</title>
    <url>/posts/9ae66173.html</url>
    <content><![CDATA[<p>哎 每次都只能做出来前前前前面三道，左后一道永远卡住，永远排名几百</p>
<a id="more"></a>

<p><img src="https://ae01.alicdn.com/kf/H4112df3d2d77493b97293c8154a4748dJ.png" alt="upload successful"></p>
<p>思路：签到题暴力即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minStartValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = i;</span><br><span class="line">            <span class="keyword">bool</span> flag=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                sum+=nums[j];</span><br><span class="line">                <span class="keyword">if</span>(sum&lt;<span class="number">1</span>)&#123;</span><br><span class="line">                    flag=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag)<span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://ae01.alicdn.com/kf/H2a1488db2159447fbe1ffe80f3a1fab6V.png" alt="upload successful"></p>
<p>思路：看到题的第一反应就是完全背包模型，但是k非常大，抱着侥幸心理交了一发，果然超时了，后面想到其实可以用贪心的思路解，每次用不超过k的斐波那契数去凑k，然后k减去这个数，一直持续到k为0即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMinFibonacciNumbers</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;num(<span class="number">46</span>);</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        num[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        num[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;<span class="number">46</span>;i++)&#123;</span><br><span class="line">            num[i]=num[i<span class="number">-1</span>]+num[i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(k)&#123;</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>,r=<span class="number">45</span>;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(num[mid]&lt;=k)l = mid;</span><br><span class="line">                <span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            k-=num[r];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://ae01.alicdn.com/kf/Hc119ecf747fb40ab903dafa964f103437.png" alt="upload successful"></p>
<p>思路：看到题第一反应就是找规律，先是个数，长度为1的开心串有3个，长度为2的开心串有6个，长度为3的开心串有12个，所以显然长度为k的开心串个数是长度为k-1的开心串的个数的两倍。然后题目要求按字典序找到长度为n的第k个开心串，显然是递推的过程，长度为1时，有 a, b, c三种，长度为2时是在长度为1的基础上增加的，对于a来说可以加两个字母 b,c,对b来说可以加两个字母 a,c,对c来说可以加a,b所以长度为2时有6种按字典序分别为<br>ab,ac,ba,bc,ca,cb，长度为3时，是在长度为2的基础上加的，构造过程相同，只需要判断上一个长度(当前长度为3时上个长度为2)的字符串的最后一位是什么就能判断要在上个长度字符串的后面加什么字符构造长度加1的开心串。要注意无解的情况</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getHappyString</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(<span class="number">11</span>),sum(<span class="number">11</span>);</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">3</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">10</span>;i++)dp[i] = dp[i<span class="number">-1</span>]*<span class="number">2</span>;<span class="comment">//记录长度为i的开心串个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">11</span>;i++)sum[i] = sum[i<span class="number">-1</span>] + dp[i];</span><br><span class="line">        <span class="keyword">if</span>(k&gt;dp[n])<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        res.push_back(<span class="string">"a"</span>);</span><br><span class="line">        res.push_back(<span class="string">"b"</span>);</span><br><span class="line">        res.push_back(<span class="string">"c"</span>);</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;<span class="number">12</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(cnt&lt;sum[i<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(res[cnt][i<span class="number">-2</span>] == <span class="string">'a'</span>)&#123;</span><br><span class="line">                    res.push_back(res[cnt] + <span class="string">'b'</span>);</span><br><span class="line">                    res.push_back(res[cnt] + <span class="string">'c'</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(res[cnt][i<span class="number">-2</span>] == <span class="string">'b'</span>)&#123;</span><br><span class="line">                    res.push_back(res[cnt] + <span class="string">'a'</span>);</span><br><span class="line">                    res.push_back(res[cnt] + <span class="string">'c'</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    res.push_back(res[cnt] + <span class="string">'a'</span>);</span><br><span class="line">                    res.push_back(res[cnt] + <span class="string">'b'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[sum[n<span class="number">-1</span>]+k<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 55  跳跃游戏, 45 跳跃游戏II</title>
    <url>/posts/25a913d8.html</url>
    <content><![CDATA[<h1 id="leetcode-55-跳跃游戏"><a href="#leetcode-55-跳跃游戏" class="headerlink" title="leetcode 55 跳跃游戏"></a>leetcode 55 跳跃游戏</h1><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个位置。</p>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释: 我们可以先跳 <span class="number">1</span> 步，从位置 <span class="number">0</span> 到达 位置 <span class="number">1</span>, 然后再从位置 <span class="number">1</span> 跳 <span class="number">3</span> 步到达最后一个位置。</span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="literal">false</span></span><br><span class="line">解释: 无论怎样，你总会到达索引为 <span class="number">3</span> 的位置。但该位置的最大跳跃长度是 <span class="number">0</span> ， 所以你永远不可能到达最后一个位置。</span><br></pre></td></tr></table></figure>

<ul>
<li>来源：力扣（LeetCode）</li>
<li>链接：<a href="https://leetcode-cn.com/problems/jump-game" target="_blank" rel="noopener">https://leetcode-cn.com/problems/jump-game</a></li>
</ul>
<p>思路：贪心，记录每个位置最多能跳到哪个位置，不断更新能到的最大位置，如果在点i处能到的最大位置k&lt;i，说明到不了终点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>(),k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;k)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            k = <span class="built_in">max</span>(k,i+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="leetcode-45-跳跃游戏II"><a href="#leetcode-45-跳跃游戏II" class="headerlink" title="leetcode 45 跳跃游戏II"></a>leetcode 45 跳跃游戏II</h1><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">解释: 跳到最后一个位置的最小跳跃数是 <span class="number">2</span>。</span><br><span class="line">     从下标为 <span class="number">0</span> 跳到下标为 <span class="number">1</span> 的位置，跳 <span class="number">1</span> 步，然后跳 <span class="number">3</span> 步到达数组的最后一个位置。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>说明:假设你总是可以到达数组的最后一个位置。</p>
</li>
<li><p>来源：力扣（LeetCode）</p>
</li>
<li><p>链接：<a href="https://leetcode-cn.com/problems/jump-game-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/jump-game-ii</a></p>
</li>
</ul>
<p>思路：延续上题的思路贪心，在贪心的时候记录每个点是由前面哪个最小的能到达该点转移来的(即第一次能到达该点的点)，这样就能找到从起点到终点的一条路径</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>(),k=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;path(n,<span class="number">0x3f3f3f3f</span>);<span class="comment">//记录路径</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(k&gt;=n<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(k&lt;i+nums[i])&#123;</span><br><span class="line">                k = i + nums[i];<span class="comment">//更新能到达的最大距离</span></span><br><span class="line">                <span class="keyword">if</span>(k&gt;=n<span class="number">-1</span>)&#123;</span><br><span class="line">                    path[n<span class="number">-1</span>]=i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=<span class="built_in">min</span>(k,n<span class="number">-1</span>);j++)path[j]=<span class="built_in">min</span>(path[j],i);<span class="comment">//记录第一个到达j这个位置的下标</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=path[n<span class="number">-1</span>];i!=<span class="number">0x3f3f3f3f</span>;i=path[i])&#123;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 678 有效的括号字符串</title>
    <url>/posts/e35fce41.html</url>
    <content><![CDATA[<p>给定一个只包含三种字符的字符串：（ ，） 和 *，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：</p>
<p>任何左括号 ( 必须有相应的右括号 )。<br>任何右括号 ) 必须有相应的左括号 ( 。<br>左括号 ( 必须在对应的右括号之前 )。</p>
<ul>
<li>可以被视为单个右括号 ) ，或单个左括号 ( ，或一个空字符串。<br>一个空字符串也被视为有效字符串。<br>字符串大小将在 [1，100] 范围内。<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: <span class="string">"()"</span></span><br><span class="line">输出: True</span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: <span class="string">"(*)"</span></span><br><span class="line">输出: True</span><br><span class="line">示例 <span class="number">3</span>:</span><br><span class="line"></span><br><span class="line">输入: <span class="string">"(*))"</span></span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>来源：力扣（LeetCode）</li>
<li>链接：<a href="https://leetcode-cn.com/problems/valid-parenthesis-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-parenthesis-string</a></li>
</ul>
<p>思路：<br>做法1：<br>数据范围不大可以考虑暴力做法：<br>利用前缀和判断当前序列是否合法(前缀和左括号+1，右括号-1，合法有如下性质：过程中如果出现负数则肯定不合法，过程中前缀和全&gt;=0且整个前缀和==0说明合法)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkValidString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> dfs(s,<span class="number">0</span>,n,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> &amp;s,<span class="keyword">int</span> start,<span class="keyword">int</span> &amp;n,<span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(start==n &amp;&amp; sum==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[start]==<span class="string">'('</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(s,i+<span class="number">1</span>,n,sum+<span class="number">1</span>))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[start]==<span class="string">')'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(s,i+<span class="number">1</span>,n,sum<span class="number">-1</span>))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(s,i+<span class="number">1</span>,n,sum+<span class="number">1</span>))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(dfs(s,i+<span class="number">1</span>,n,sum<span class="number">-1</span>))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(dfs(s,i+<span class="number">1</span>,n,sum))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>做法2：<br>正反向遍历字符串各一次，正向遍历时左括号+星号的出现次数要一直小于等于右括号出现次数。<br>反向遍历时右括号+星号的次数要一直小于等于左括号，否则不能合法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkValidString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> l1=<span class="number">0</span>,r1=<span class="number">0</span>,s1=<span class="number">0</span>,l2=<span class="number">0</span>,r2=<span class="number">0</span>,s2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=n<span class="number">-1</span>;i&lt;n;j--,i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'('</span>)l1++;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">')'</span>)r1++;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'*'</span>)s1++;</span><br><span class="line">            <span class="keyword">if</span>(s[j]==<span class="string">'('</span>)l2++;</span><br><span class="line">            <span class="keyword">if</span>(s[j]==<span class="string">')'</span>)r2++;</span><br><span class="line">            <span class="keyword">if</span>(s[j]==<span class="string">'*'</span>)s2++;</span><br><span class="line">            <span class="keyword">if</span>(r1&gt;l1+s1 || l2&gt;r2+s2)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>dfs</category>
        <category>模拟</category>
      </categories>
      <tags>
        <tag>dfs</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 649 Dota2 参议员</title>
    <url>/posts/43feac7d.html</url>
    <content><![CDATA[<p>Dota2 的世界里有两个阵营：Radiant(天辉)和 Dire(夜魇)</p>
<p>Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的一项：</p>
<ul>
<li><p>禁止一名参议员的权利：<br>  参议员可以让另一位参议员在这一轮和随后的几轮中丧失所有的权利。</p>
</li>
<li><p>宣布胜利：<br>  如果参议员发现有权利投票的参议员都是同一个阵营的，他可以宣布胜利并决定在游戏中的有关变化。</p>
<a id="more"></a>
<p>给定一个字符串代表每个参议员的阵营。字母 “R” 和 “D” 分别代表了 Radiant（天辉）和 Dire（夜魇）。然后，如果有 n 个参议员，给定字符串的大小将是 n。</p>
</li>
</ul>
<p>以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。</p>
<p>假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 Dota2 游戏中决定改变。输出应该是 Radiant 或 Dire。</p>
<ul>
<li>注意: 给定字符串的长度在 [1, 10,000] 之间.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: <span class="string">"RD"</span></span><br><span class="line">输出: <span class="string">"Radiant"</span></span><br><span class="line">解释:  第一个参议员来自  Radiant 阵营并且他可以使用第一项权利让第二个参议员失去权力，因此第二个参议员将被跳过因为他没有任何权利。然后在第二轮的时候，第一个参议员可以宣布胜利，因为他是唯一一个有投票权的人</span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: <span class="string">"RDD"</span></span><br><span class="line">输出: <span class="string">"Dire"</span></span><br><span class="line">解释:</span><br><span class="line">第一轮中,第一个来自 Radiant 阵营的参议员可以使用第一项权利禁止第二个参议员的权利</span><br><span class="line">第二个来自 Dire 阵营的参议员会被跳过因为他的权利被禁止</span><br><span class="line">第三个来自 Dire 阵营的参议员可以使用他的第一项权利禁止第一个参议员的权利</span><br><span class="line">因此在第二轮只剩下第三个参议员拥有投票的权利,于是他可以宣布胜利</span><br></pre></td></tr></table></figure>

<ul>
<li>来源：力扣（LeetCode）</li>
<li>链接：<a href="https://leetcode-cn.com/problems/dota2-senate" target="_blank" rel="noopener">https://leetcode-cn.com/problems/dota2-senate</a></li>
</ul>
<p>思路：用队列来模拟这个过程，用1表示Radiant方，0表示Dire方。队列当前访问的元素是x时，不用立刻选一个对方的参议员淘汰掉，而要在遍历到对方的参议员是淘汰他。所以过程如下：<br>遍历到x,<br>如果ban[x^1]&gt;0(表示对方可以淘汰的人数)，那么这轮x不能行使任何权利，且被淘汰,将ban[x^1]减1 ,people[x]减1。<br>否则对方不能淘汰我方，则我方可以淘汰对方人数+1，所以有ban[x]++,将x进队(可参与下一轮)<br>最后哪方还有人哪方胜利</p>
<ul>
<li>时间复杂度O(N)</li>
<li>空间复杂度O(N)<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">predictPartyVictory</span><span class="params">(<span class="built_in">string</span> senate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = senate.<span class="built_in">size</span>(),people[<span class="number">2</span>]=&#123;<span class="number">0</span>&#125;,ban[<span class="number">2</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = senate[i] == <span class="string">'R'</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            q.push(x);</span><br><span class="line">            people[x]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(people[<span class="number">0</span>] &amp;&amp; people[<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">int</span> x = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(ban[x^<span class="number">1</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                ban[x^<span class="number">1</span>]--;</span><br><span class="line">                people[x]--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ban[x]++;</span><br><span class="line">                q.push(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> people[<span class="number">0</span>] &gt; <span class="number">0</span> ? <span class="string">"Dire"</span> : <span class="string">"Radiant"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 面试题16.03 交点</title>
    <url>/posts/936ff75f.html</url>
    <content><![CDATA[<p>给定两条线段（表示为起点$start = {X1, Y1}$和终点 $end = {X2, Y2}$ ），如果它们有交点，请计算其交点，没有交点则返回空值。</p>
<p>要求浮点型误差不超过$10^{-6}$。若有多个交点（线段重叠）则返回 X 值最小的点，X 坐标相同则返回 Y 值最小的点。</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">line1 = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;</span><br><span class="line">line2 = &#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;</span><br><span class="line">输出： &#123;<span class="number">0.5</span>, <span class="number">0</span>&#125;</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">line1 = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">3</span>, <span class="number">3</span>&#125;</span><br><span class="line">line2 = &#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">2</span>&#125;</span><br><span class="line">输出： &#123;<span class="number">1</span>, <span class="number">1</span>&#125;</span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">line1 = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;</span><br><span class="line">line2 = &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">2</span>, <span class="number">1</span>&#125;</span><br><span class="line">输出： &#123;&#125;，两条线段没有交点</span><br></pre></td></tr></table></figure>

<ul>
<li>来源：力扣（LeetCode）</li>
<li>链接：<a href="https://leetcode-cn.com/problems/intersection-lcci" target="_blank" rel="noopener">https://leetcode-cn.com/problems/intersection-lcci</a></li>
</ul>
<p>思路：使用点斜式解方程，斜率不存在时单独考虑。</p>
<p>斜率不存在时</p>
<ul>
<li>(1)都不存在<br>判断是否重叠，是则返回答案，否则返回空</li>
<li>(2)$line1$不存在$line2$存在<br>求出交点判断交点是否在线段范围内</li>
<li>(3)$line1$存在$line2$不存在<br>同(2)</li>
</ul>
<p>由$y=kx+b$，斜率存在时有$k=(y_1-y_2)/(x_1-x_2)$,$b=y_1-k*x_1$<br>所以每两个点确定一个方程，当两条线段斜率都存在时:<br>两直线方程为：</p>
<p>$y=k_1*x+b_1$</p>
<p>$y=k_2*x+b_2$</p>
<p>若两线的平行</p>
<ul>
<li>(1)不重叠,则无交点</li>
<li>(2)重叠，返回重叠的线段中x坐标的最小的点，x相同时返回y坐标最小的点。</li>
</ul>
<p>否则联立方程得一交点，解之得$x=(b_2-b_1)/(k_1-k_2)$,$y=k1*x+b1$<br>判断此交点是否在线段范围内即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; intersection(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; start1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; end1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; start2, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; end2) &#123;</span><br><span class="line">        <span class="keyword">if</span>(start1[<span class="number">0</span>] &gt; end1[<span class="number">0</span>])swap(start1,end1);<span class="comment">//将点按照x的大小放</span></span><br><span class="line">        <span class="keyword">if</span>(start2[<span class="number">0</span>] &gt; end2[<span class="number">0</span>])swap(start2,end2);</span><br><span class="line">        <span class="keyword">bool</span> flag1=<span class="number">0</span>,flag2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(start1[<span class="number">0</span>] - end1[<span class="number">0</span>] == <span class="number">0</span>)flag1=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(start2[<span class="number">0</span>] - end2[<span class="number">0</span>] == <span class="number">0</span>)flag2=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(flag1 &amp;&amp; flag2)&#123; <span class="comment">//都垂直x</span></span><br><span class="line">            <span class="keyword">if</span>(start1[<span class="number">0</span>] != start2[<span class="number">0</span>])<span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//返回最小y的点</span></span><br><span class="line">                <span class="keyword">int</span> x1[<span class="number">2</span>]=&#123;<span class="built_in">min</span>(start1[<span class="number">1</span>],end1[<span class="number">1</span>]),<span class="built_in">max</span>(start1[<span class="number">1</span>],end1[<span class="number">1</span>])&#125;;</span><br><span class="line">                <span class="keyword">int</span> x2[<span class="number">2</span>]=&#123;<span class="built_in">min</span>(start2[<span class="number">1</span>],end2[<span class="number">1</span>]),<span class="built_in">max</span>(start2[<span class="number">1</span>],end2[<span class="number">1</span>])&#125;;</span><br><span class="line">                <span class="keyword">int</span> ly = <span class="built_in">max</span>(x1[<span class="number">0</span>],x2[<span class="number">0</span>]),ry=<span class="built_in">min</span>(x1[<span class="number">1</span>],x2[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span>(ly&gt;ry)<span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">                <span class="keyword">return</span> &#123;(<span class="keyword">double</span>)start1[<span class="number">0</span>],(<span class="keyword">double</span>)ly&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(flag1 &amp;&amp; !flag2)&#123;<span class="comment">//第一条垂直x第二条不垂直x</span></span><br><span class="line">            <span class="keyword">return</span> check(start1,end1,start2,end2);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!flag1 &amp;&amp; flag2)&#123;<span class="comment">//第一条不垂直x第二条垂直x</span></span><br><span class="line">            <span class="keyword">return</span> check(start2,end2,start1,end1);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  <span class="comment">//都不垂直x</span></span><br><span class="line">            <span class="keyword">double</span> k1 = (<span class="keyword">double</span>)(end1[<span class="number">1</span>] - start1[<span class="number">1</span>]) / (end1[<span class="number">0</span>] - start1[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">double</span> b1 = start1[<span class="number">1</span>] - k1 * start1[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">double</span> k2 = (<span class="keyword">double</span>)(end2[<span class="number">1</span>] - start2[<span class="number">1</span>])/(end2[<span class="number">0</span>] - start2[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">double</span> b2 = start2[<span class="number">1</span>] - k2 * start2[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span>(k1 == k2)&#123; <span class="comment">//平行</span></span><br><span class="line">                <span class="keyword">if</span>(b1==b2)&#123; <span class="comment">//重叠 返回x最小 x相同返回y最小</span></span><br><span class="line">                    <span class="keyword">int</span> lx = <span class="built_in">max</span>(start1[<span class="number">0</span>],start2[<span class="number">0</span>]),rx=<span class="built_in">min</span>(end1[<span class="number">0</span>],end2[<span class="number">0</span>]);</span><br><span class="line">                    <span class="keyword">if</span>(lx&gt;rx)<span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">                    <span class="keyword">if</span>(lx&gt;start1[<span class="number">0</span>])<span class="keyword">return</span> &#123;(<span class="keyword">double</span>)start2[<span class="number">0</span>],(<span class="keyword">double</span>)start2[<span class="number">1</span>]&#125;;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">return</span> &#123;(<span class="keyword">double</span>)start1[<span class="number">0</span>],(<span class="keyword">double</span>)start1[<span class="number">1</span>]&#125;;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">double</span> interx = (b2-b1)/(k1-k2),intery=k1*interx + b1;</span><br><span class="line">                <span class="keyword">int</span> x1=<span class="built_in">min</span>(start1[<span class="number">0</span>],end1[<span class="number">0</span>]),x2=<span class="built_in">max</span>(start1[<span class="number">0</span>],end1[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">int</span> x3=<span class="built_in">min</span>(start2[<span class="number">0</span>],end2[<span class="number">0</span>]),x4=<span class="built_in">max</span>(start2[<span class="number">0</span>],end2[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">if</span>(interx&gt;=x1 &amp;&amp; interx&lt;=x2 &amp;&amp; interx&gt;=x3 &amp;&amp; interx&lt;=x4)&#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;interx,intery&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; check(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; start1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; end1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; start2, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; end2)&#123;</span><br><span class="line">        <span class="keyword">double</span> k2 = (<span class="keyword">double</span>)(end2[<span class="number">1</span>] - start2[<span class="number">1</span>])/(end2[<span class="number">0</span>] - start2[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">double</span> b2 = start2[<span class="number">1</span>] - k2 * start2[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">double</span> interx = start1[<span class="number">0</span>],intery = k2*interx + b2;</span><br><span class="line">        <span class="keyword">if</span>(intery&gt;=<span class="built_in">min</span>(start1[<span class="number">1</span>],end1[<span class="number">1</span>]) &amp;&amp; intery &lt;= <span class="built_in">max</span>(start1[<span class="number">1</span>],end1[<span class="number">1</span>]))<span class="keyword">return</span> &#123;interx,intery&#125;;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 355 设计推特</title>
    <url>/posts/61e85a35.html</url>
    <content><![CDATA[<p>设计一个简化版的推特(Twitter)，可以让用户实现发送推文，关注/取消关注其他用户，能够看见关注人（包括自己）的最近十条推文。你的设计需要支持以下的几个功能：</p>
<p>postTweet(userId, tweetId): 创建一条新的推文<br>getNewsFeed(userId): 检索最近的十条推文。每个推文都必须是由此用户关注的人或者是用户自己发出的。推文必须按照时间顺序由最近的开始排序。<br>follow(followerId, followeeId): 关注一个用户<br>unfollow(followerId, followeeId): 取消关注一个用户</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">Twitter twitter = <span class="keyword">new</span> Twitter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户1发送了一条新推文 (用户id = 1, 推文id = 5).</span></span><br><span class="line">twitter.postTweet(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户1的获取推文应当返回一个列表，其中包含一个id为5的推文.</span></span><br><span class="line">twitter.getNewsFeed(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户1关注了用户2.</span></span><br><span class="line">twitter.follow(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户2发送了一个新推文 (推文id = 6).</span></span><br><span class="line">twitter.postTweet(<span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户1的获取推文应当返回一个列表，其中包含两个推文，id分别为 -&gt; [6, 5].</span></span><br><span class="line"><span class="comment">// 推文id6应当在推文id5之前，因为它是在5之后发送的.</span></span><br><span class="line">twitter.getNewsFeed(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户1取消关注了用户2.</span></span><br><span class="line">twitter.unfollow(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户1的获取推文应当返回一个列表，其中包含一个id为5的推文.</span></span><br><span class="line"><span class="comment">// 因为用户1已经不再关注用户2.</span></span><br><span class="line">twitter.getNewsFeed(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>来源：力扣（LeetCode）</li>
<li>链接：<a href="https://leetcode-cn.com/problems/design-twitter" target="_blank" rel="noopener">https://leetcode-cn.com/problems/design-twitter</a></li>
</ul>
<blockquote>
<p>思路：比较恶心的设计模拟题。</p>
</blockquote>
<ul>
<li>使用一个哈希表来存用户订阅的人，一个存用户发的tiwtter</li>
</ul>
<ol>
<li>postTweet(int userId, int tweetId) 将userId的twitter插到新的推特后面，即使用头插法。</li>
<li>getNewsFeed(int userId) 将用户userId的关注用户和自己的推特都用一个指针指向，每次在答案<br>中插入最新发的twitter。</li>
<li>follow(int followerId, int followeeId) 如果要订阅的是自己或者已经订阅了则不用订阅，否则<br>在用户的订阅列表中加入要订阅的用户。</li>
<li>unfollow(int followerId, int followeeId)如果要取消订阅没定阅过的人则不用操作，否则将要<br>取消订阅的用户从订阅列表中删去。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Twitter</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">twitter</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> postTime;</span><br><span class="line">        <span class="keyword">int</span> tweetId;</span><br><span class="line">        <span class="keyword">int</span> userId;</span><br><span class="line">        twitter *next;</span><br><span class="line">        twitter(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z) : postTime(x), tweetId(y),userId(z), next(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> posttime=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;userfollow;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,twitter*&gt;twitterlist;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    Twitter() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Compose a new tweet. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postTweet</span><span class="params">(<span class="keyword">int</span> userId, <span class="keyword">int</span> tweetId)</span> </span>&#123;</span><br><span class="line">        twitter *newtwitter = <span class="keyword">new</span> twitter(posttime,tweetId,userId);</span><br><span class="line">        newtwitter-&gt;next = twitterlist[userId];</span><br><span class="line">        twitterlist[userId] = newtwitter;</span><br><span class="line">        posttime++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getNewsFeed(<span class="keyword">int</span> userId) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;<span class="built_in">list</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ifollow = userfollow[userId];</span><br><span class="line">        ifollow.push_back(userId);</span><br><span class="line">        <span class="keyword">int</span> n = ifollow.<span class="built_in">size</span>(),i=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;twitter*&gt;<span class="built_in">point</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">point</span>[i]=twitterlist[ifollow[i]];</span><br><span class="line">        <span class="keyword">while</span>(i&lt;<span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">point</span>[i]==<span class="literal">NULL</span>)cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt==ifollow.<span class="built_in">size</span>())<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> pt=<span class="number">-1</span>,tid=<span class="number">0x3f3f3f3f</span>,index=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">point</span>[i])<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(pt &lt; <span class="built_in">point</span>[i]-&gt;postTime)&#123;</span><br><span class="line">                    index=i;</span><br><span class="line">                    pt = <span class="built_in">point</span>[i]-&gt;postTime;</span><br><span class="line">                    tid = <span class="built_in">point</span>[i]-&gt;tweetId;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pt!=<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="built_in">point</span>[index]=<span class="built_in">point</span>[index]-&gt;next;</span><br><span class="line">                <span class="built_in">list</span>.push_back(tid);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Follower follows a followee. If the operation is invalid, it should be a no-op. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">follow</span><span class="params">(<span class="keyword">int</span> followerId, <span class="keyword">int</span> followeeId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(followerId == followeeId)<span class="keyword">return</span> ;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;t = userfollow[followerId];</span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=t.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t[i]==followeeId)&#123;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)<span class="keyword">return</span> ;</span><br><span class="line">        userfollow[followerId].push_back(followeeId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unfollow</span><span class="params">(<span class="keyword">int</span> followerId, <span class="keyword">int</span> followeeId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(followerId == followeeId)<span class="keyword">return</span> ;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;t = userfollow[followerId];</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n = t.<span class="built_in">size</span>(),index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t[i] == followeeId)&#123;</span><br><span class="line">                flag=<span class="number">0</span>;</span><br><span class="line">                index=i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=index;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            t[i]=t[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        t.pop_back();</span><br><span class="line">        userfollow[followerId] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Twitter object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Twitter* obj = new Twitter();</span></span><br><span class="line"><span class="comment"> * obj-&gt;postTweet(userId,tweetId);</span></span><br><span class="line"><span class="comment"> * vector&lt;int&gt; param_2 = obj-&gt;getNewsFeed(userId);</span></span><br><span class="line"><span class="comment"> * obj-&gt;follow(followerId,followeeId);</span></span><br><span class="line"><span class="comment"> * obj-&gt;unfollow(followerId,followeeId);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>模拟</category>
        <category>设计</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>设计</tag>
      </tags>
  </entry>
  <entry>
    <title>二维费用的背包问题</title>
    <url>/posts/c3509816.html</url>
    <content><![CDATA[<hr>
<blockquote>
<p>完全背包问题的模型如下：<br>有 N 件物品和一个容量是 V 的背包，背包能承受的最大重量是 M。每件物品只能用一次。体积是 $v_i$，重量是 $m_i$，价值是 $w_i$。求解将哪些物品装入背包，可使物品总体积不超过背包容量，总重量不超过背包可承受的最大重量，且价值总和最大。<br>输出最大价值。</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>输入格式<br>第一行两个整数，N,V,M，用空格隔开，分别表示物品件数、背包容积和背包可承受的最大重量。<br>接下来有 N 行，每行三个整数 $v_i,m_i,w_i$，用空格隔开，分别表示第 i 件物品的体积、重量和价值。<br>输出格式<br>输出一个整数，表示最大价值。<br>数据范围</p>
<ol>
<li>$0&lt;N≤1000$</li>
<li>$0&lt;V,M≤100$</li>
<li>$0&lt;v_i,m_i≤100$</li>
<li>$0&lt;w_i≤1000$</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入样例</span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>思路：多了一维重量限制，其实和01背包是一样的多枚举一下重量即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,w;</span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=a;j--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=w;k&gt;=b;k--)&#123;</span><br><span class="line">                f[j][k] = <span class="built_in">max</span>(f[j][k],f[j-a][k-b]+c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f[m][w]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>混合背包</title>
    <url>/posts/4687017g.html</url>
    <content><![CDATA[<blockquote>
<p>有 N 种物品和一个容量是 V 的背包。<br>物品一共有三类：</p>
</blockquote>
<ol>
<li>第一类物品只能用1次(s&lt;0时)（01背包）；</li>
<li>第二类物品可以用无限次(s=0时)（完全背包）；</li>
<li>第三类物品最多只能用 $s_i$ 次(s&gt;0时)（多重背包）；<br>每种体积是 $v_i$，价值是 $w_i$。</li>
</ol>
<ul>
<li>求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。<br>输出最大价值。<a id="more"></a>
思路:<blockquote>
<p>按类别处理就行，要注意的就是将多重背包转化为二进制优化的01背包就行。</p>
</blockquote>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Goods</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> type,v,w;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Goods&gt;goods;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> v,w,s;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;v&gt;&gt;w&gt;&gt;s;</span><br><span class="line">        <span class="keyword">if</span>(s&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=s;k*=<span class="number">2</span>)&#123;</span><br><span class="line">                goods.push_back(&#123;<span class="number">-1</span>,k*v,k*w&#125;);</span><br><span class="line">                s-=k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s&gt;<span class="number">0</span>)goods.push_back(&#123;<span class="number">-1</span>,s*v,s*w&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> goods.push_back(&#123;s,v,w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> g:goods)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!g.type)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=g.v;j&lt;=m;j++)f[j] = <span class="built_in">max</span>(f[j],f[j-g.v]+g.w);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=g.v;j--)f[j] = <span class="built_in">max</span>(f[j],f[j-g.v]+g.w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f[m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode动态规划专题</title>
    <url>/posts/59a5b963.html</url>
    <content><![CDATA[<blockquote>
<p>感觉dp真的很困难，刷不动。打算后面几天刷一下dp的题。</p>
</blockquote>
<a id="more"></a>

<h1 id="leetcode-5-最长回文子串："><a href="#leetcode-5-最长回文子串：" class="headerlink" title="leetcode 5 最长回文子串："></a>leetcode 5 最长回文子串：</h1><blockquote>
<p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line">输入: “babad”</span><br><span class="line">输出: “bab”</span><br><span class="line">注意: “aba” 也是一个有效答案。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line">输入: “cbbd”</span><br><span class="line">输出: “bb”</span><br></pre></td></tr></table></figure>
<ul>
<li>来源：力扣（LeetCode）</li>
<li>链接：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-palindromic-substring</a></li>
</ul>
<blockquote>
<p>思路：参考了算法笔记的最长回文子串的做法，时间复杂度为\(O(N^2)\)。令dp[i][j]表示s[i]到s[j]所表示的子串是否时回文子串，是则为1，不是为0。这样根据s[i]是否等于s[j]，就可以把转移情况分为两类：<br>s[i]==s[[j],那么只要s[i+1][j-1]是回文子串，s[i]至s[j]就是回文子串；如果s[i+1][j-1]不是回文子串，则s[i]至s[j]也不是回文子串。<br>s[i]!=s[j]，那么s[i]至s[j]一定不是回文子串。<br>由此可以写出状态转移方程：<br>\(<br>dp[i][j] =<br>\begin{cases}<br>dp[i+1][j-1],  &amp; \text{s[i]==s[j]} \\<br>0,  &amp; \text{s[i]!=s[j]}<br>\end{cases}<br>\)<br>边界：\(dp[i][i]=1,dp[i][i+1]=(s[i]==s[i+1])?1:0\)。<br>到这里还有一个问题没有解决，那就是如果按照i和j从小到大的顺序来枚举子串的两个端点，然后更新dp[i][j],会无法保证dp[i+1][j-1]已经被计算过，从而无法得到正确的dp[i][j]。<br>如图所示，先固定i==0，然后枚举j从2开始。当求解dp[0][2]时，将会转换为求dp[1][1],而dp[1][1]时在初试化中得来得，当求解dp[0][3]时，将会转换为dp[1][2],而dp[1][2]也是在初始化中得来的，当求解dp[0][4]时，将会转换为dp[1][3],但是dp[1][3]并不是已经计算过的值，因此无法状态转移。事实上，无论对i和j的枚举顺序作何调整，都无法调和这个矛盾，因此必须想办法寻找新的枚举方式。<br>根据递推写法从边界出发的原理，注意到边界表示的是长度为1和2的子串，且每次转移时都对子串的长度减了1，因此不妨考虑按子串的初始位置进行枚举，即第一遍将长度为3的子串的dp值全部求出，第二遍通过第一遍结果计算出长度为4的子串的dp值…这样就可以避免状态无法转移的问题。可以先枚举子串长度L,再枚举左端点i，这样右端点i+L-1也可以直接得到。<br><img src="https://ae01.alicdn.com/kf/H667ca6c331af4b918ead3509366b5def3.png" alt=""></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length(),ans=<span class="number">1</span>,temp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i][i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;n<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==s[i+<span class="number">1</span>])&#123;</span><br><span class="line">                    dp[i][i+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">                    ans = <span class="number">2</span>;</span><br><span class="line">                    temp = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> L = <span class="number">3</span>;L&lt;=n;L++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+L<span class="number">-1</span>&lt;n;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> j=i+L<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==s[j]&amp;&amp;dp[i+<span class="number">1</span>][j<span class="number">-1</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">                    dp[i][j]=<span class="number">1</span>;</span><br><span class="line">                    temp = i;</span><br><span class="line">                    ans = L;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = temp + ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=temp;i&lt;m;i++)res+=s[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="leetcode-647-回文子串"><a href="#leetcode-647-回文子串" class="headerlink" title="leetcode 647 回文子串"></a>leetcode 647 回文子串</h1><blockquote>
<p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。<br>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被计为是不同的子串。<br>示例 1:<br>输入: “abc”<br>输出: 3<br>解释: 三个回文子串: “a”, “b”, “c”.<br>示例 2:<br>输入: “aaa”<br>输出: 6<br>说明: 6个回文子串: “a”, “a”, “a”, “aa”, “aa”, “aaa”.<br>注意:<br>输入的字符串长度不会超过1000。</p>
</blockquote>
<ul>
<li>来源：力扣（LeetCode）</li>
<li>链接：<a href="https://leetcode-cn.com/problems/palindromic-substrings" target="_blank" rel="noopener">https://leetcode-cn.com/problems/palindromic-substrings</a></li>
</ul>
<blockquote>
<p>思路：上面的代码稍加修改即可解。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length(),result=n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i][i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;n<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==s[i+<span class="number">1</span>])&#123;</span><br><span class="line">                    dp[i][i+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">                    result++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> L = <span class="number">3</span>;L&lt;=n;L++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+L<span class="number">-1</span>&lt;n;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> j=i+L<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==s[j]&amp;&amp;dp[i+<span class="number">1</span>][j<span class="number">-1</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">                    dp[i][j]=<span class="number">1</span>;</span><br><span class="line">                    result++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="leetcod-1025-除数博弈"><a href="#leetcod-1025-除数博弈" class="headerlink" title="leetcod 1025 除数博弈"></a>leetcod 1025 除数博弈</h1><blockquote>
<p>爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。最初，黑板上有一个数字N 。在每个玩家的回合，玩家需要执行以下操作：<br>选出任一x，满足 0 &lt; x &lt; N 且 N % x == 0 。<br>用 N - x 替换黑板上的数字 N 。<br>如果玩家无法执行这些操作，就会输掉游戏。<br>只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。<br>示例 1：<br>输入：2<br>输出：true<br>解释：爱丽丝选择 1，鲍勃无法进行操作。<br>示例 2：<br>输入：3<br>输出：false<br>解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。<br>提示：<br>1 &lt;= N &lt;= 1000</p>
</blockquote>
<ul>
<li>来源：力扣（LeetCode）</li>
<li>链接：<a href="https://leetcode-cn.com/problems/divisor-game" target="_blank" rel="noopener">https://leetcode-cn.com/problems/divisor-game</a></li>
</ul>
<blockquote>
<p>思路：有一种取巧找规律的做法很简单就不说了，自己推一下就行了。说一下自己的动态规划做法。首先明确一点，就是对于每个数其胜负结果都是确定的，也就是说每一个必胜态都有一个必败态的转化，每个必败态都有一个必胜态的转化。举个栗子：用dp数组来记录每个N的胜负情况，显然dp[1]=0,dp[2]=1,dp[3]=0,我们可以有前面状态的dp[i]来递推出后面dp[i+1]。求解dp[4]时，我们判断从dp[1-3]中可以被4整除数中是否有一个使得N-x必败态的数，如果有，则dp[4]则为必胜态，因为先手选数的玩家选了那个数后，使得对面到了必败态。例如我们可以选的数有1，2,选后的状态为dp[3]=0，dp[2]=1,所以我们肯定要选1使得对方转到必败态。代码实现也很简单：</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> dp[<span class="number">1010</span>];</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">divisorGame</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">0</span>,dp[<span class="number">2</span>]=<span class="number">1</span>,dp[<span class="number">3</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">4</span>;i&lt;=N;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;N<span class="number">-1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i%j==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dp[i-j]==<span class="number">0</span>)dp[i]=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[N];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="leetcode-303-区域和检索"><a href="#leetcode-303-区域和检索" class="headerlink" title="leetcode 303 区域和检索"></a>leetcode 303 区域和检索</h1><blockquote>
<p>给定一个整数数组 nums，求出数组从索引 i 到 j (i ≤ j) 范围内元素的总和，包含 i, j 两点。<br>示例：<br>给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()<br>sumRange(0, 2) -&gt; 1<br>sumRange(2, 5) -&gt; -1<br>sumRange(0, 5) -&gt; -3<br>说明:<br>你可以假设数组不可变。<br>会多次调用 sumRange 方法。</p>
</blockquote>
<ul>
<li>来源：力扣（LeetCode）</li>
<li>链接：<a href="https://leetcode-cn.com/problems/range-sum-query-immutable" target="_blank" rel="noopener">https://leetcode-cn.com/problems/range-sum-query-immutable</a></li>
</ul>
<blockquote>
<p>思路：水题，直接前缀和完事。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp,num;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    NumArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span><br><span class="line">    &#123;</span><br><span class="line">        n = nums.<span class="built_in">size</span>();</span><br><span class="line">        num = nums;</span><br><span class="line">        presum();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dp[j]-dp[i]+num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">presum</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n)</span><br><span class="line">        &#123;</span><br><span class="line">            dp.push_back(num[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp.push_back(dp[i<span class="number">-1</span>]+num[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;<span class="class"><span class="keyword">class</span> <span class="title">NumArray</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp,num;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    NumArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span><br><span class="line">    &#123;</span><br><span class="line">        n = nums.<span class="built_in">size</span>();</span><br><span class="line">        num = nums;</span><br><span class="line">        presum();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dp[j]-dp[i]+num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">presum</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n)</span><br><span class="line">        &#123;</span><br><span class="line">            dp.push_back(num[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp.push_back(dp[i<span class="number">-1</span>]+num[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 377 组合总和Ⅳ</title>
    <url>/posts/758b2bfb.html</url>
    <content><![CDATA[<blockquote>
<p>给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。</p>
</blockquote>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">target = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">所有可能的组合为：</span><br><span class="line">(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">请注意，顺序不同的序列被视作不同的组合。</span><br><span class="line"></span><br><span class="line">因此输出为 <span class="number">7</span>。</span><br></pre></td></tr></table></figure>

<ul>
<li>来源：力扣（LeetCode）</li>
<li>链接：<a href="https://leetcode-cn.com/problems/combination-sum-iv" target="_blank" rel="noopener">https://leetcode-cn.com/problems/combination-sum-iv</a></li>
</ul>
<blockquote>
<p>思路：第一想法就是暴搜,从数组的第一个数开始，搜索使用第一个数字，看能有多少种方案可以使总和恰好为target，然后继续算用以第二个数字作为第一数字能有多少种方案可以使综合恰好为target,以此类推。这种方法的弊端非常明显，如果target比数组的数都大很多的话，递归深度太深了会超时，所以果然TEL了。后面想到可以做记忆化，用ans记录总和恰好等于target的所有方案数，所以有<br>\(ans[target]=ans[target-current] + count\)状态转移方程。其中current表示1target之中的状态，count表示总和恰好为current时有多少种方案。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">超时代码:</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        dfs(target,target,candidates);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> target,<span class="keyword">int</span> remain,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(remain&lt;<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(remain==<span class="number">0</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;candidates.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            dfs(target,remain - candidates[i],candidates);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">加了记忆化之后的代码</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; temp;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        temp = <span class="built_in">vector</span>(target+<span class="number">1</span>,<span class="number">-1l</span>l);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=target;i++)&#123;</span><br><span class="line">            count=<span class="number">0</span>;</span><br><span class="line">            dfs(i,i,candidates);</span><br><span class="line">            temp[i]=count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> target,<span class="keyword">int</span> remain,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(remain&lt;<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(temp[remain]!=<span class="number">-1</span>)&#123;<span class="comment">//如果还要凑的数已经算过了则加上当前方案数之和返回即可。</span></span><br><span class="line">            count+=temp[remain];</span><br><span class="line">            count%=INT_MAX;<span class="comment">//防止超出整数的表示范围</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(remain==<span class="number">0</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;candidates.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            dfs(target,remain - candidates[i],candidates);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 72 编辑距离</title>
    <url>/posts/5a2e5835.html</url>
    <content><![CDATA[<blockquote>
<p>给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。<br>你可以对一个单词进行如下三种操作：</p>
<ol>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ol>
</blockquote>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: word1 = <span class="string">"horse"</span>, word2 = <span class="string">"ros"</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释:</span><br><span class="line">horse -&gt; rorse (将 <span class="string">'h'</span> 替换为 <span class="string">'r'</span>)</span><br><span class="line">rorse -&gt; rose (删除 <span class="string">'r'</span>)</span><br><span class="line">rose -&gt; ros (删除 <span class="string">'e'</span>)</span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: word1 = <span class="string">"intention"</span>, word2 = <span class="string">"execution"</span></span><br><span class="line">输出: <span class="number">5</span></span><br><span class="line">解释:</span><br><span class="line">intention -&gt; inention (删除 <span class="string">'t'</span>)</span><br><span class="line">inention -&gt; enention (将 <span class="string">'i'</span> 替换为 <span class="string">'e'</span>)</span><br><span class="line">enention -&gt; exention (将 <span class="string">'n'</span> 替换为 <span class="string">'x'</span>)</span><br><span class="line">exention -&gt; exection (将 <span class="string">'n'</span> 替换为 <span class="string">'c'</span>)</span><br><span class="line">exection -&gt; execution (插入 <span class="string">'u'</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>来源：力扣（LeetCode）</li>
<li>链接：<a href="https://leetcode-cn.com/problems/edit-distance" target="_blank" rel="noopener">https://leetcode-cn.com/problems/edit-distance</a></li>
</ul>
<blockquote>
<p>思路：f[i,j]表示将word1前i个字母变为word2前j个字母需要的最少操作数。所以可以分成三类：插入，删除，替换<br>状态转移如图所示<br><img src="https://ae01.alicdn.com/kf/H56b598d3701948c081878842e04a0525R.png" alt=""></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = word1.<span class="built_in">size</span>(),m = word2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;f(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)f[i][<span class="number">0</span>]=i;<span class="comment">//初始化 将word1前i个字母变成word2前0个字母需要将前i个字母删掉</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;i++)f[<span class="number">0</span>][i]=i;<span class="comment">//初始化 将word1前0个字母变成word2前i个字母需要将前i个字母插入</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                f[i][j] = <span class="built_in">min</span>(f[i<span class="number">-1</span>][j],f[i][j<span class="number">-1</span>]) + <span class="number">1</span>;</span><br><span class="line">                f[i][j] = <span class="built_in">min</span>(f[i][j],f[i<span class="number">-1</span>][j<span class="number">-1</span>] + (word1[i<span class="number">-1</span>]!=word2[j<span class="number">-1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 52 N皇后题解</title>
    <url>/posts/d11b2892.html</url>
    <content><![CDATA[<p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<a id="more"></a>

<p><img src="https://ae01.alicdn.com/kf/Ha9739138b02145c289d0c1b9bca533faH.png" alt=""></p>
<blockquote>
<p>上图为 8 皇后问题的一种解法。<br>给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。<br>每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。<br>示例:</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">4</span></span><br><span class="line">输出: [</span><br><span class="line"> [<span class="string">".Q.."</span>,  <span class="comment">// 解法 1</span></span><br><span class="line">  <span class="string">"...Q"</span>,</span><br><span class="line">  <span class="string">"Q..."</span>,</span><br><span class="line">  <span class="string">"..Q."</span>],</span><br><span class="line"></span><br><span class="line"> [<span class="string">"..Q."</span>,  <span class="comment">// 解法 2</span></span><br><span class="line">  <span class="string">"Q..."</span>,</span><br><span class="line">  <span class="string">"...Q"</span>,</span><br><span class="line">  <span class="string">".Q.."</span>]</span><br><span class="line">]</span><br><span class="line">解释: <span class="number">4</span> 皇后问题存在两个不同的解法。</span><br></pre></td></tr></table></figure>
<ul>
<li>来源：力扣（LeetCode）</li>
<li>链接：<a href="https://leetcode-cn.com/problems/n-queens" target="_blank" rel="noopener">https://leetcode-cn.com/problems/n-queens</a></li>
</ul>
<blockquote>
<p>思路：首先考虑暴力求解，从\(n^2\)个位置中选择n个位置，那么将需要枚举\(C_{n*n}^n\)次,当n=8时就是54502232次枚举，如果n更大，那么就炸了。所以要换个思路，考虑每行只能放一个皇后，每列只能放一个皇后，如果把n列皇后所在的行号依次写出，那么就是1-n的一个排列。于是只需要枚举1-n的所有排列，查看每个排列对应得放置方案是否合法，当n=8时，只需要40320次枚举。遍历每两个皇后，判断他们是否在一条对角线上(不在同一行和同一列是显然得)，若不是则为一种情况,加入ans中。实现如下：</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> P[<span class="number">10</span>],hashTable[<span class="number">10</span>]=&#123;<span class="literal">false</span>&#125;,m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;ans;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">generateP</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == m+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=m;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">abs</span>(i-j)==<span class="built_in">abs</span>(P[i]-P[j]))&#123;</span><br><span class="line">                        flag = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">return</span> ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;t;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                <span class="built_in">string</span> r = <span class="string">""</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)r+=<span class="string">"."</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)t.push_back(r);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)t[P[i]<span class="number">-1</span>][i<span class="number">-1</span>]=<span class="string">'Q'</span>;</span><br><span class="line">                ans.push_back(t);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=m;x++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hashTable[x]==<span class="literal">false</span>)&#123;</span><br><span class="line">                P[index]=x;</span><br><span class="line">                hashTable[x]=<span class="literal">true</span>;</span><br><span class="line">                generateP(index+<span class="number">1</span>);</span><br><span class="line">                hashTable[x]=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        m=n;</span><br><span class="line">        generateP(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>事实上，通过思考可以发现，当已经放置了一部分皇后之后，可能剩余得皇后无论怎样都不可能合法，此时就没必要往下递归了，直接返回上层即可，这样可以减少很多计算量，例如35141，当放置了前3个皇后，可以发现剩下两个皇后无论怎么放都会产生冲突，就没必要继续递归了。<br>回溯算法如下：</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> P[<span class="number">10</span>],hashTable[<span class="number">10</span>]=&#123;<span class="literal">false</span>&#125;,m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;ans;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">generateP</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;t;</span><br><span class="line">        <span class="keyword">if</span>(index == m+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">string</span> r;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)r+=<span class="string">"."</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)t.push_back(r);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)t[P[i]<span class="number">-1</span>][i<span class="number">-1</span>]=<span class="string">'Q'</span>;</span><br><span class="line">            ans.push_back(t);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=m;x++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hashTable[x]==<span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> pre =<span class="number">1</span>;pre&lt;index;pre++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">abs</span>(index-pre)==<span class="built_in">abs</span>(x-P[pre]))&#123;</span><br><span class="line">                        flag = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                    P[index]=x;</span><br><span class="line">                    hashTable[x]=<span class="literal">true</span>;</span><br><span class="line">                    generateP(index+<span class="number">1</span>);</span><br><span class="line">                    hashTable[x]=<span class="literal">false</span>;  </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        m=n;</span><br><span class="line">        generateP(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>dfs</category>
        <category>回溯</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dfs</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript迭代器和函数深入</title>
    <url>/posts/ba033a64.html</url>
    <content><![CDATA[<blockquote>
<p>Js迭代器和函数深入</p>
</blockquote>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//迭代器和生成器</span></span><br><span class="line"><span class="keyword">const</span> book = [</span><br><span class="line">    <span class="string">"Twinkle, twinkle, little bat!"</span>,</span><br><span class="line">    <span class="string">"How I wonder what you're at!"</span>,</span><br><span class="line">    <span class="string">"Up above the world you fly,"</span>,</span><br><span class="line">    <span class="string">"Like a tea tray in the sky."</span>,</span><br><span class="line">    <span class="string">"Twinkle, twinkle, little bat!"</span>,</span><br><span class="line">    <span class="string">"How I wonder what you're at!"</span></span><br><span class="line">];</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">const</span> it = book.values();<span class="comment">//values（）方法获取迭代器</span></span><br><span class="line"><span class="keyword">for</span> (let i = it.next(); !i.done; i = it.next()) &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(i.value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代协议</span></span><br><span class="line"><span class="comment">/*迭代器协议可以让任何对象变得可迭代</span></span><br><span class="line"><span class="comment">* 如果一个类提供了一个符号方法Symbol.iterator，这个方法返回一个具有迭代行为</span></span><br><span class="line"><span class="comment">* 的对象（比如：对象有next()方法，同时next方法返回一个包含value和done的对象</span></span><br><span class="line"><span class="comment">* ），那么这个类就是可迭代的*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Log</span> &#123;</span></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        <span class="keyword">this</span>.messages = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    add(message) &#123;</span><br><span class="line">        <span class="keyword">this</span>.messages.push(&#123;message, timestamp: Date.now()&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [Symbol.iterator]() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.messages.values();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">log</span> = <span class="keyword">new</span> Log();</span><br><span class="line"><span class="built_in">log</span>.add(<span class="string">"first day at sea"</span>);</span><br><span class="line"><span class="built_in">log</span>.add(<span class="string">"spotted whale"</span>);</span><br><span class="line"><span class="built_in">log</span>.add(<span class="string">"spotted another vessel"</span>);</span><br><span class="line"><span class="keyword">for</span> (let i of <span class="built_in">log</span>) &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(`$&#123;i.message&#125; @ $&#123;i.timestamp&#125;`);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以编写自己的迭代器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Log2</span> &#123;</span></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        <span class="keyword">this</span>.messages = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    add(message) &#123;</span><br><span class="line">        <span class="keyword">this</span>.messages.push(&#123;message, timestamp: Date.now()&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [Symbol.iterator]() &#123;</span><br><span class="line">        <span class="keyword">const</span> messages = <span class="keyword">this</span>.messages;</span><br><span class="line">        let i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            next() &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= messages.length)</span><br><span class="line">                    <span class="keyword">return</span> &#123;value: undefined, done: <span class="literal">true</span>&#125;;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> &#123;value: messages[i++], done: <span class="literal">false</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">const</span> log2 = <span class="keyword">new</span> Log2();</span><br><span class="line">log2.add(<span class="string">"first day at sea"</span>);</span><br><span class="line">log2.add(<span class="string">"spotted whale"</span>);</span><br><span class="line">log2.add(<span class="string">"spotted another vessel"</span>);</span><br><span class="line"><span class="keyword">for</span> (let i of log2) &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(`$&#123;i.message&#125; @ $&#123;i.timestamp&#125;`);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*至此，以上使用的例子都是迭代预先定义好元素个数的数组：一本书的页数，或者log中</span></span><br><span class="line"><span class="comment">* 的日期消息记录。迭代器还可以用来表示含有无穷值的对象。*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FibonacciSequence</span> &#123;</span></span><br><span class="line">    [Symbol.iterator]() &#123;</span><br><span class="line">        let a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            next() &#123;</span><br><span class="line">                let temp = b;</span><br><span class="line">                b += a;</span><br><span class="line">                a = temp;</span><br><span class="line">                <span class="keyword">return</span> &#123;value: temp, done: <span class="literal">false</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fib = <span class="keyword">new</span> FibonacciSequence();</span><br><span class="line">let i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (let n of fib) &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(n);</span><br><span class="line">    <span class="keyword">if</span> (++i &gt; <span class="number">9</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//IIEFs和异步代码</span></span><br><span class="line"><span class="comment">/*setTimeout函数会根据第二个参数设置的时间延迟执行第一个参数（一个函数）*/</span></span><br><span class="line"><span class="comment">// setTimeout(function () &#123;</span></span><br><span class="line"><span class="comment">//     console.log("hello");</span></span><br><span class="line"><span class="comment">// &#125;,1500);</span></span><br><span class="line"><span class="comment">//有了这些知识储备，可以编写倒计时代码</span></span><br><span class="line">var j;</span><br><span class="line"><span class="comment">// for(j=5;j&gt;=0;j--)&#123;</span></span><br><span class="line"><span class="comment">//     setTimeout(function () &#123;</span></span><br><span class="line"><span class="comment">//         console.log(j===0? "go!":j);</span></span><br><span class="line"><span class="comment">//     &#125;,(5-j)*1000);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">/*运行结果是6个-1 异步编程。。还没理解这里的setTimeout函数再循环中没有被调用他</span></span><br><span class="line"><span class="comment">们会在未来的某个时间点被调用。所以循环会正常运行，从5开始，到-1结束..而这发生</span></span><br><span class="line"><span class="comment">在函数被调用之前。所以，当函数被调用是j的值是-1。*/</span></span><br><span class="line"><span class="comment">/*for (j = 5; j &gt;= 0; j--) &#123;</span></span><br><span class="line"><span class="comment">    (function (j) &#123;</span></span><br><span class="line"><span class="comment">        setTimeout(function () &#123;</span></span><br><span class="line"><span class="comment">            console.log(j === 0 ? "go!" : j);</span></span><br><span class="line"><span class="comment">        &#125;, (5 - j) * 1000);</span></span><br><span class="line"><span class="comment">    &#125;)(j);//IIFE + 匿名函数 + 闭包解决问题</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="comment">// for(let j=5;j&gt;=0;j--)&#123;</span></span><br><span class="line"><span class="comment">//     setTimeout(function () &#123;</span></span><br><span class="line"><span class="comment">//         console.log(j===0? "go!":j);</span></span><br><span class="line"><span class="comment">//     &#125;,(5-j)*1000);</span></span><br><span class="line"><span class="comment">// &#125;/*for循环使用let关键字也可以解决作用域的问题*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*函数变量：函数被调用之前和其他变量一样是静态的，被调用的时候是动态的</span></span><br><span class="line"><span class="comment">* 凡是能够使用变量的地方，都可以使用函数，意味着除了变量的普通用法外，</span></span><br><span class="line"><span class="comment">* 还可以做这些事</span></span><br><span class="line"><span class="comment">* · 通过创建一个指向函数的变量来给函数起一个别名</span></span><br><span class="line"><span class="comment">* · 将函数放入数组中（可能混合其他类型的数据）</span></span><br><span class="line"><span class="comment">* · 将函数当作对象的属性</span></span><br><span class="line"><span class="comment">* · 将函数传入到另一个函数中</span></span><br><span class="line"><span class="comment">* · 从一个函数中返回一个函数</span></span><br><span class="line"><span class="comment">* · 从一个把函数当作参数的函数中返回一个函数*/</span></span><br><span class="line"><span class="comment">//别名</span></span><br><span class="line"><span class="function">function <span class="title">addThreeSquareAddFiveTakeSquareRoot</span><span class="params">(x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Math.<span class="built_in">sqrt</span>(Math.<span class="built_in">pow</span>(x+<span class="number">3</span>,<span class="number">2</span>)+<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> f3 = addThreeSquareAddFiveTakeSquareRoot;</span><br><span class="line"><span class="keyword">const</span> answer = (f3(<span class="number">5</span>)+f3(<span class="number">2</span>))/f3(<span class="number">7</span>);</span><br><span class="line">console.<span class="built_in">log</span>(answer);</span><br><span class="line"><span class="comment">//数组中的函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">cos</span> = Math.<span class="built_in">cos</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">sin</span> = Math.<span class="built_in">sin</span>;</span><br><span class="line"><span class="keyword">const</span> theta = Math.PI/<span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> zoom = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> offset = [<span class="number">1</span>,<span class="number">-3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pipeline = [</span><br><span class="line">    function rotate(p)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            x: p.x * <span class="built_in">cos</span>(theta) - p.y * <span class="built_in">sin</span>(theta),</span><br><span class="line">            y: p.x * <span class="built_in">sin</span>(theta) + p.y * <span class="built_in">cos</span>(theta)</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function">function <span class="title">scale</span><span class="params">(p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x: p.x * zoom, y: p.y * zoom&#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function">function <span class="title">translate</span><span class="params">(p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x: p.x + offset[<span class="number">0</span>],y: p.y + offset[<span class="number">1</span>]&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> p = &#123;x: <span class="number">1</span>,y: <span class="number">1</span>&#125;;</span><br><span class="line">let p2 = p;</span><br><span class="line"><span class="keyword">for</span>(let i=<span class="number">0</span>;i&lt;pipeline.length;i++)&#123;</span><br><span class="line">    p2 = pipeline[i](p2);</span><br><span class="line">    console.<span class="built_in">log</span>(p2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将函数传给函数</span></span><br><span class="line"><span class="comment">/*之前已经接触了很多将函数传给函数的例子。比如把函数传给setTimeout或forEach。这样做</span></span><br><span class="line"><span class="comment">* 的另一个原因是为了管理异步编程。实现异步执行的常见方法是将一个函数(通常叫回调函数)</span></span><br><span class="line"><span class="comment">* 传给另一个函数。该函数在闭包函数执行完成时被调用*/</span></span><br><span class="line"><span class="function">function <span class="title">sum</span><span class="params">(arr,f)</span> </span>&#123;</span><br><span class="line">    if(typeof f != 'function')f = x =&gt; x;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce((a,x) =&gt; a+=f(x),<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"\n"</span> + sum([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]));</span><br><span class="line">console.<span class="built_in">log</span>(sum([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],x =&gt; x*x));</span><br><span class="line">console.<span class="built_in">log</span>(sum([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],x =&gt; Math.<span class="built_in">pow</span>(x,<span class="number">3</span>)));</span><br><span class="line"><span class="comment">//在函数中返回函数(有点难理解)</span></span><br><span class="line"><span class="comment">// function sumOfSquares(arr) &#123;</span></span><br><span class="line"><span class="comment">//     return sum(arr,x =&gt; x*x);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="function">function <span class="title">newSummer</span><span class="params">(f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr =&gt; sum(arr,f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> sumOfSquares = newSummer(x =&gt; x*x);</span><br><span class="line"><span class="keyword">const</span> sumOfCubes = newSummer(x =&gt; Math.<span class="built_in">pow</span>(x,<span class="number">3</span>));</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"\n"</span>+sumOfSquares([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]));</span><br><span class="line">console.<span class="built_in">log</span>(sumOfCubes([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]));</span><br><span class="line"></span><br><span class="line"><span class="comment">//14章 异步编程</span></span><br><span class="line"><span class="comment">/*JavaScript对异步编程的支持有三个不同的阶段：</span></span><br><span class="line"><span class="comment">回调(callback)阶段</span></span><br><span class="line"><span class="comment">* promise阶段</span></span><br><span class="line"><span class="comment">* 生成器(generator)阶段*/</span></span><br><span class="line"><span class="comment">/*如果知识简单的说生成器比任何出现在它之前的阶段都好，那么只要了解生成</span></span><br><span class="line"><span class="comment">* 器的工作原理跳过其他的就行了，但实际上没这么简单。生成器本身并不提供</span></span><br><span class="line"><span class="comment">* 任何对异步的支持：他们依赖于承诺或特定类型的回调来提供异步行为。同样</span></span><br><span class="line"><span class="comment">* 像承诺这样有用的东西，会依赖于回调（而回调本身又由于具有对象而变得更</span></span><br><span class="line"><span class="comment">* 有用）。除了用户输入外，异步编程技术的三个主要使用场景是：</span></span><br><span class="line"><span class="comment">* 网络请求（如Ajax请求）</span></span><br><span class="line"><span class="comment">* 文件系统操作（读/写文件等）</span></span><br><span class="line"><span class="comment">* 刻意的时间延迟功能（比如警告等）*/</span></span><br><span class="line"><span class="comment">/*类比：在一个人满为患且没有预定的餐厅里找一个空桌子。此时不需要排队等</span></span><br><span class="line"><span class="comment">* ，当有位子的时候餐厅会给打电话。这就类似回调：给餐厅的工作人员提供了</span></span><br><span class="line"><span class="comment">* 一些信息，允许他们在有位子的时候通知客户。所以餐厅可以做自己的事，客</span></span><br><span class="line"><span class="comment">* 户也可以做自己的事，没有人在等其他人。另一家餐厅也许会给客户一个传呼</span></span><br><span class="line"><span class="comment">* 机，在位子准备好的时候就会响。这更像是一个承诺：餐厅工作人员会给客户</span></span><br><span class="line"><span class="comment">* 一个承诺，承诺在有空桌子的时候通知客户。*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript学习记录面向对象编程-动态属性-原型-静态方法-继承-map-WeakMap-异常</title>
    <url>/posts/279f5654.html</url>
    <content><![CDATA[<blockquote>
<p>Js面向对象编程</p>
</blockquote>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">面向对象编程</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> &#123;</span></span><br><span class="line">    constructor()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> car1 = <span class="keyword">new</span> Car();</span><br><span class="line"><span class="keyword">const</span> car2 = <span class="keyword">new</span> Car();</span><br><span class="line">console.<span class="built_in">log</span>(car1 instanceof Car);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> &#123;</span></span><br><span class="line">    constructor(make,model)&#123;</span><br><span class="line">        <span class="keyword">this</span>.make = make;</span><br><span class="line">        <span class="keyword">this</span>.model = model;</span><br><span class="line">        <span class="keyword">this</span>.userGears = [<span class="string">'P'</span>,<span class="string">'N'</span>,<span class="string">'R'</span>,<span class="string">'D'</span>];</span><br><span class="line">        <span class="keyword">this</span>.userGear = <span class="keyword">this</span>.userGears[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    shift(gear)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.userGears.indexOf(gear)&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(`Invalid gear: $&#123;gear&#125;`);</span><br><span class="line">        <span class="keyword">this</span>.userGear = gear;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> car1 = <span class="keyword">new</span> Car(<span class="string">"Tesla"</span>,<span class="string">"Model S"</span>);</span><br><span class="line">car1.shift(<span class="string">'D'</span>);</span><br><span class="line">console.<span class="built_in">log</span>(car1.make,car1.model,car1.userGear);</span><br><span class="line">动态属性</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> &#123;</span></span><br><span class="line">    constructor(make,model)&#123;</span><br><span class="line">        <span class="keyword">this</span>.make = make;</span><br><span class="line">        <span class="keyword">this</span>.model = model;</span><br><span class="line">        <span class="keyword">this</span>._userGears = [<span class="string">'P'</span>,<span class="string">'N'</span>,<span class="string">'R'</span>,<span class="string">'D'</span>];<span class="comment">//穷人访问限制 给私有属性加下划线前缀</span></span><br><span class="line">        <span class="keyword">this</span>._userGear = <span class="keyword">this</span>._userGears[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">get</span> <span class="title">userGear</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>._userGear; &#125;</span><br><span class="line">    <span class="function"><span class="built_in">set</span> <span class="title">userGear</span><span class="params">(value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>._userGears.indexOf(value)&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(`Invalid gear: $&#123;value&#125;`);</span><br><span class="line">        <span class="keyword">this</span>._userGear = value;</span><br><span class="line">    &#125;</span><br><span class="line">    shift(gear)&#123;<span class="keyword">this</span>.userGear = gear;&#125;</span><br><span class="line">&#125;<span class="comment">/*并没有解决直接赋值问题*/</span></span><br><span class="line"><span class="comment">// WeakMap强制属性私有化</span></span><br><span class="line"><span class="keyword">const</span> Car = (function () &#123;</span><br><span class="line">    <span class="keyword">const</span> carProps = <span class="keyword">new</span> WeakMap();</span><br><span class="line"></span><br><span class="line">    class Car &#123;</span><br><span class="line">        constructor(make, model) &#123;</span><br><span class="line">            <span class="keyword">this</span>.make = make;</span><br><span class="line">            <span class="keyword">this</span>.model = model;</span><br><span class="line">            <span class="keyword">this</span>._userGears = [<span class="string">'P'</span>, <span class="string">'N'</span>, <span class="string">'R'</span>, <span class="string">'D'</span>];</span><br><span class="line">            carProps.<span class="built_in">set</span>(<span class="keyword">this</span>, &#123;userGear: <span class="keyword">this</span>._userGears[<span class="number">0</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">get</span> userGear() &#123;</span><br><span class="line">            <span class="keyword">return</span> carProps.<span class="built_in">get</span>(<span class="keyword">this</span>).userGear;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">set</span> userGear(value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>._userGears.indexOf(value) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(`Invalid gear:$&#123;value&#125;`);</span><br><span class="line">            carProps.<span class="built_in">get</span>(<span class="keyword">this</span>).userGear = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        shift(gear) &#123;</span><br><span class="line">            <span class="keyword">this</span>.userGear = gear;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Car;</span><br><span class="line">&#125;)();<span class="comment">/*这里使用即时调用函数将WeakMap隐藏再一个闭包内，从而阻止了外界的访问。这个WeakMap可以安全的存储任何不</span></span><br><span class="line"><span class="comment">像被Car类外部访问的属性*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//原型</span></span><br><span class="line"><span class="keyword">const</span> car1 = <span class="keyword">new</span> Car();</span><br><span class="line"><span class="keyword">const</span> car2 = <span class="keyword">new</span> Car();</span><br><span class="line">console.<span class="built_in">log</span>(car1.shift === Car.prototype.shift);</span><br><span class="line">car1.shift(<span class="string">"D"</span>);</span><br><span class="line"><span class="comment">//car1.shift('d')报错</span></span><br><span class="line">console.<span class="built_in">log</span>(car1.userGear);</span><br><span class="line">console.<span class="built_in">log</span>(car1.shift === car2.shift);</span><br><span class="line"></span><br><span class="line">car1.shift = function (gear) &#123;</span><br><span class="line">    <span class="keyword">this</span>.userGear = gear.toUpperCase();</span><br><span class="line">&#125;;</span><br><span class="line">console.<span class="built_in">log</span>(car1.shift === Car.prototype.shift);</span><br><span class="line">console.<span class="built_in">log</span>(car1.shift === car2.shift);</span><br><span class="line">car1.shift(<span class="string">'d'</span>);</span><br><span class="line">console.<span class="built_in">log</span>(car1.userGear);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*到目前为止，讨论的方法都是实例方法。它们只针对每个具体的实例才有用。还有一种静态方法，它不与实例绑定。在静态</span></span><br><span class="line"><span class="comment">方法中，this绑定的是类本身，但通常使用类名来代替this是公认的最佳实践。静态方法通常用来执行与类相关的任务，而非</span></span><br><span class="line"><span class="comment">跟具体的实例相关。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//静态方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car1</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">getNextVin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Car1.nextVin++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    constructor(make, model) &#123;</span><br><span class="line">        <span class="keyword">this</span>.make = make;</span><br><span class="line">        <span class="keyword">this</span>.model = model;</span><br><span class="line">        <span class="keyword">this</span>.vin = Car1.getNextVin();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">areSimilar</span><span class="params">(car1, car2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> car1.make === car2.make &amp;&amp; car1.model === car2.model;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">areSame</span><span class="params">(car1, car2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> car1.vin === car2.vin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Car1.nextVin = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> car3 = <span class="keyword">new</span> Car1(<span class="string">"Tesla"</span>, <span class="string">"S"</span>);</span><br><span class="line"><span class="keyword">const</span> car4 = <span class="keyword">new</span> Car1(<span class="string">"Mazda"</span>, <span class="string">"3"</span>);</span><br><span class="line"><span class="keyword">const</span> car5 = <span class="keyword">new</span> Car1(<span class="string">"Mazda"</span>, <span class="string">"3"</span>);</span><br><span class="line">console.<span class="built_in">log</span>(car3.vin);</span><br><span class="line">console.<span class="built_in">log</span>(car4.vin);</span><br><span class="line">console.<span class="built_in">log</span>(car5.vin);</span><br><span class="line">console.<span class="built_in">log</span>(Car1.areSimilar(car3, car4));</span><br><span class="line">console.<span class="built_in">log</span>(Car1.areSimilar(car4, car5));</span><br><span class="line">console.<span class="built_in">log</span>(Car1.areSame(car4, car5));</span><br><span class="line">console.<span class="built_in">log</span>(Car1.areSame(car4, car4));</span><br><span class="line"><span class="comment">//继承</span></span><br><span class="line"><span class="comment">/*在分析原型的时候，已经看到了继承的身影：当创建一个类的实例时，它继承了类原型中的所有的功能。如果一个方法没</span></span><br><span class="line"><span class="comment">有在对象原型中找到其定义，它会检查原型的原型。这样就建立了一个原型链。JavaScript会沿着原型链走下去，直到某个</span></span><br><span class="line"><span class="comment">原型满足了需求。如果找不到这样的原型，程序最终会报错。原型链的最大好处就是能够建立类的层次结构。前面已经讨论</span></span><br><span class="line"><span class="comment">了汽车如何归属与一种交通工具。原型链允许将功能置于最合适的继承层次上。例如，汽车可能有个方法deployAirbags，</span></span><br><span class="line"><span class="comment">可以将它当作一般的交通工具方法，但是，大家做过配备安全气囊的船吗？另一方面，几乎左右的交通工具都可以搭载乘客，</span></span><br><span class="line"><span class="comment">所以交通工具都可能有addPassenger的方法。下面实现这种场景*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> &#123;</span></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        <span class="keyword">this</span>.passengers = [];</span><br><span class="line">        console.<span class="built_in">log</span>(<span class="string">"Vehicle created"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addPassenger(p) &#123;</span><br><span class="line">        <span class="keyword">this</span>.passengers.push(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car2</span> <span class="title">extends</span> <span class="title">Vehicle</span> &#123;</span></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        super();<span class="comment">//特殊函数 调用了父类的构造器，必须调用否则报错</span></span><br><span class="line">        console.<span class="built_in">log</span>(<span class="string">"Car created"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    deployAirbags() &#123;</span><br><span class="line">        console.<span class="built_in">log</span>(<span class="string">"BWOOSH"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Vehicle.prototype.sneaky = <span class="string">"not recommended!"</span>;</span><br><span class="line"><span class="keyword">const</span> v = <span class="keyword">new</span> Vehicle();</span><br><span class="line">v.addPassenger(<span class="string">"Frank"</span>);</span><br><span class="line">v.addPassenger(<span class="string">"Judy"</span>);</span><br><span class="line">console.<span class="built_in">log</span>(v.passengers);</span><br><span class="line"><span class="keyword">const</span> c  = <span class="keyword">new</span> Car2();</span><br><span class="line">c.addPassenger(<span class="string">"Alice"</span>);</span><br><span class="line">c.addPassenger(<span class="string">"Cameron"</span>);</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">for</span>(let p in c)&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(`$&#123;p&#125;: $&#123;c[p]&#125;`+</span><br><span class="line">        (c.hasOwnProperty(p) ? '' : '(inherited)'));</span><br><span class="line">&#125;</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"\n"</span>);</span><br><span class="line">console.<span class="built_in">log</span>(c.passengers);</span><br><span class="line"><span class="comment">//v.deployAirbags()报错</span></span><br><span class="line">c.deployAirbags();<span class="comment">/*注意到可以在c上调用deployAirbags,但是不能在v上调用。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//map</span></span><br><span class="line">const u1 = &#123;name:'Cynthia'&#125;;</span><br><span class="line">const u2 = &#123;name:'Jackson'&#125;;</span><br><span class="line">const u3 = &#123;name:'James'&#125;;</span><br><span class="line"><span class="comment">// const userRoles = new Map();</span></span><br><span class="line"><span class="comment">// userRoles.set(u1,"User");</span></span><br><span class="line"><span class="comment">// userRoles.set(u2,"User");</span></span><br><span class="line"><span class="comment">// userRoles.set(u3,"Admin");</span></span><br><span class="line"><span class="comment">//set()链式赋值</span></span><br><span class="line"><span class="comment">//const userRoles = new Map();</span></span><br><span class="line"><span class="comment">// userRoles</span></span><br><span class="line"><span class="comment">//     .set(u1,"User")</span></span><br><span class="line"><span class="comment">//     .set(u2,"User")</span></span><br><span class="line"><span class="comment">//     .set(u3,"Admin");</span></span><br><span class="line"><span class="comment">//map的构函数赋值</span></span><br><span class="line"><span class="keyword">const</span> userRoles = <span class="keyword">new</span> Map([</span><br><span class="line">    [u1,'User'],</span><br><span class="line">    [u2,'User'],</span><br><span class="line">    [u3,'Admin']</span><br><span class="line">]);</span><br><span class="line"><span class="comment">/*如果key已经在map种，调用set()后key对应的value就会被替换</span></span><br><span class="line"><span class="comment">* size属性返回map的元素个数</span></span><br><span class="line"><span class="comment">* keys()方法可以拿到map中的所有键，values()可以拿到所有的值</span></span><br><span class="line"><span class="comment">* entries()可以以数组的方式获取键值对，数组的第一个元素为键，第二个为值。所有的这些方法返回一个可</span></span><br><span class="line"><span class="comment">* 以迭代的对象从而可以用for...of循环迭代*/</span></span><br><span class="line"><span class="keyword">for</span>(let u of userRoles.keys())console.<span class="built_in">log</span>(u.name);</span><br><span class="line"><span class="keyword">for</span>(let u of userRoles.values())console.<span class="built_in">log</span>(u);;</span><br><span class="line"><span class="keyword">for</span>(let u of userRoles.entries())console.<span class="built_in">log</span>(`$&#123;u[<span class="number">0</span>].name&#125;: $&#123;u[<span class="number">1</span>]&#125;`);</span><br><span class="line"><span class="comment">//通过解构让迭代更自然</span></span><br><span class="line"><span class="keyword">for</span>(let [u,r] of userRoles.entries())console.<span class="built_in">log</span>(`$&#123;u.name&#125;: $&#123;r&#125;`);</span><br><span class="line"><span class="comment">//如果需要一个数组，可以用展开运算符：</span></span><br><span class="line">console.<span class="built_in">log</span>([...userRoles.values()]);</span><br><span class="line"><span class="comment">//使用delete()方法可以删除map中的一个条目</span></span><br><span class="line">userRoles.<span class="keyword">delete</span>(u2);</span><br><span class="line">console.<span class="built_in">log</span>(userRoles.<span class="built_in">size</span>)</span><br><span class="line"><span class="comment">//如果想删除所有调用clear()方法</span></span><br><span class="line">userRoles.<span class="built_in">clear</span>();</span><br><span class="line">console.<span class="built_in">log</span>(userRoles.<span class="built_in">size</span>);</span><br><span class="line"><span class="comment">//Weak maps</span></span><br><span class="line"><span class="comment">/*本质和Map相同除了以下几点</span></span><br><span class="line"><span class="comment">* key必须时对象</span></span><br><span class="line"><span class="comment">* WeakMap中的key可以被垃圾回收</span></span><br><span class="line"><span class="comment">* WeakMap不能被迭代或者清空*/</span></span><br><span class="line"><span class="keyword">const</span> SecretHolder = (function () &#123;</span><br><span class="line">    <span class="keyword">const</span> secrets = <span class="keyword">new</span> WeakMap();</span><br><span class="line">    <span class="keyword">return</span> class &#123;</span><br><span class="line">        setSecret(secret)&#123;</span><br><span class="line">            secrets.<span class="built_in">set</span>(<span class="keyword">this</span>,secret);</span><br><span class="line">        &#125;</span><br><span class="line">        getSecret()&#123;</span><br><span class="line">            <span class="keyword">return</span> secrets.<span class="built_in">get</span>(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">/*这里把WeakMap放在IIFE中，同时还放入了一个使用它的类。在IIFE外，有一个叫做SectetHolder的类，这个类的实例可</span></span><br><span class="line"><span class="comment">以存储secrets.secret的赋值和取值只能分别通过setSecret方法和getSecret方法完成*/</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> SecretHolder();</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> SecretHolder();</span><br><span class="line">a.setSecret(<span class="string">"secret A"</span>);</span><br><span class="line">b.setSecret(<span class="string">"secret B"</span>);</span><br><span class="line">console.<span class="built_in">log</span>(a.getSecret() + b.getSecret());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Error对象</span></span><br><span class="line"><span class="function">function <span class="title">validateEmail</span><span class="params">(email)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> email.match(/@/)?</span><br><span class="line">        email:</span><br><span class="line">        <span class="keyword">new</span> Error(`invalid email: $&#123;email&#125;`);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> email = <span class="string">"jane@doe.com"</span>;</span><br><span class="line"><span class="keyword">const</span> validatedEmail = validateEmail(email);</span><br><span class="line"><span class="keyword">if</span>(validatedEmail instanceof Error)&#123;</span><br><span class="line">    console.error(`Error: $&#123;validatedEmail.message&#125;`);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(`Valid email: $&#123;validatedEmail&#125;`);</span><br><span class="line">&#125;<span class="comment">/*可以通过typeof运算符判断返回的是不是Error实例然后通过Error的message属性来获取错误信</span></span><br><span class="line"><span class="comment">息。虽然这样使用Error实例完全合法，也很有用，但实际上，它的大部分应用场景都在异常处理</span></span><br><span class="line"><span class="comment">中，这也是接下来要学的内容*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用try...catch处理异常</span></span><br><span class="line"><span class="comment">/*如果将前面的例子中的email设为null、数字、对象等任何非字符串值时都会出错，此时程序将</span></span><br><span class="line"><span class="comment">* 会非常不友好的崩溃。为了防范这种非预期错误，可以将用于验证邮箱的代码封装在try..catch</span></span><br><span class="line"><span class="comment">* 语句中*/</span></span><br><span class="line"><span class="keyword">const</span> email_ = null;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> validatedEmail = validateEmail(email_);</span><br><span class="line">    <span class="keyword">if</span>(validatedEmail instanceof Error)&#123;</span><br><span class="line">        console.error(`Error: $&#123;validatedEmail.message&#125;`);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        console.<span class="built_in">log</span>(`Valid email: $&#123;validatedEmail&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(`Error: $&#123;e.message&#125;`);</span><br><span class="line">&#125;<span class="comment">/*捕获异常后，程序就不会再崩溃了，而是打印了错误日志后继续执行。不过可能还会有别的问题：</span></span><br><span class="line"><span class="comment">如果这里需要输入一个合法的邮箱，而用户输入了无效的邮箱，那程序继续运行下去也没有意义了。</span></span><br><span class="line"><span class="comment">注意，一旦有错误产生，执行逻辑立即跳到catch中。所以validateEmail调用语句后的if语句就不</span></span><br><span class="line"><span class="comment">会执行。也可以再try块中写入任何期望的语句，最先产生错误的语句会使执行逻辑跳转到catch块</span></span><br><span class="line"><span class="comment">中。如果try块中的语句没有任何错误，catch块中的代码就不会被执行，程序会继续运行下去。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//抛出异常</span></span><br><span class="line"><span class="comment">/*function  billPay(amount,payee,account) &#123;</span></span><br><span class="line"><span class="comment">    if(amount &gt; account.balance)</span></span><br><span class="line"><span class="comment">        throw new Error("insufficient funds");</span></span><br><span class="line"><span class="comment">    account.transfer(payee,amount);</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//异常处理和调用栈</span></span><br><span class="line"><span class="function">function <span class="title">a_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    console.log('a: calling b');</span><br><span class="line">    b_();</span><br><span class="line">    console.log('a: done');</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">function <span class="title">b_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">"b: calling c"</span>);</span><br><span class="line">    c_();</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">"b: done"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">function <span class="title">c_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">"c: throwing error"</span>);</span><br><span class="line">    throw new Error('c error');</span><br><span class="line">    console.log('c: done');</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">function <span class="title">d_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    console.log('d: calling c');</span><br><span class="line">    c_();</span><br><span class="line">    console.log('d: done');</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    a_();</span><br><span class="line">&#125;<span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(e.<span class="built_in">stack</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    d_();</span><br><span class="line">&#125;<span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(e.<span class="built_in">stack</span>);</span><br><span class="line">&#125;<span class="comment">/*栈轨迹从最深层的函数开始，直到没有函数调用。所以出现异常应该从最上面开始解决*/</span></span><br><span class="line"><span class="comment">//try...catch...finally</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">"this line is executed..."</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"whoops"</span>);</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">"whis line is not..."</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">"there was an error.."</span>);</span><br><span class="line">&#125;finally &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">"...always executed"</span>);</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">"perform cleanup here"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Script学习记录 异步深入</title>
    <url>/posts/5be64662.html</url>
    <content><![CDATA[<blockquote>
<p>想吐槽一下，这个部分有点恶心 太绕了。</p>
</blockquote>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//回调</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"Before timeout: "</span> + <span class="keyword">new</span> Date());</span><br><span class="line"><span class="built_in">setTimeout</span>(function () &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">"After timeout: "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">&#125;,<span class="number">2000</span>);</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"I happen after setTimeout"</span>);</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"Me too"</span>);</span><br><span class="line"><span class="comment">/*可以看到代码编写的顺序与实际执行的顺序之间没有必然联系。这里就是回调异步*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//setInterval函数每隔一段特定的时间运行回调函数，并且一直运行下去，直到调用</span></span><br><span class="line"><span class="comment">//clearInterval函数</span></span><br><span class="line"><span class="keyword">const</span> start = <span class="keyword">new</span> Date();</span><br><span class="line">let i_1 =<span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> intervalId = setInterval(function () &#123;</span><br><span class="line">    let now = <span class="keyword">new</span> Date();</span><br><span class="line">    ++i_1;</span><br><span class="line">    <span class="keyword">if</span>(now.getMinutes() !== start.getMinutes() || i_1&gt;<span class="number">10</span>)</span><br><span class="line">        <span class="keyword">return</span> clearInterval(intervalId);</span><br><span class="line">    console.<span class="built_in">log</span>(`$&#123;i_1&#125;: $&#123;now&#125;`);</span><br><span class="line">&#125;,<span class="number">2000</span>);</span><br><span class="line"><span class="comment">/*setInterval返回了一个ID,在后面可以用来取消这次调用。与之对应的clearInterval</span></span><br><span class="line"><span class="comment">* 在timeout之前停止本次调用也是使用了这种方式</span></span><br><span class="line"><span class="comment">* setTimeout、setInterval、clearInterval都定义在全局对象中（浏览器中是window,</span></span><br><span class="line"><span class="comment">* Node中是global）*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//scope和异步执行</span></span><br><span class="line"><span class="comment">/*异步执行中容易让人疑惑或犯错的一点是：scope和闭包是如何影响异步执行的。每当</span></span><br><span class="line"><span class="comment">* 一个函数被执行时，都创建了一个闭包：所有在函数内部创建的变量(包括形参)只在</span></span><br><span class="line"><span class="comment">* 有被访问的是时候才存在*/</span></span><br><span class="line"><span class="function">function <span class="title">contdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">"Countdown:"</span>);</span><br><span class="line">    <span class="keyword">for</span>(let i=<span class="number">5</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(function () &#123;</span><br><span class="line">            console.<span class="built_in">log</span>(i===<span class="number">0</span>?<span class="string">"Go!"</span>:i);</span><br><span class="line">        &#125;,(<span class="number">5</span>-i)*<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">contdown();</span><br><span class="line"><span class="comment">//promise</span></span><br><span class="line"><span class="comment">/*创建一个带有函数的promise实例，它应该包含一个resolve(满足)和reject的回调。*/</span></span><br><span class="line"><span class="function">function <span class="title">countdown_</span><span class="params">(seconds)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promise(function (resolve,reject) &#123;</span><br><span class="line">        <span class="keyword">for</span>(let i=seconds;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(function () &#123;</span><br><span class="line">                <span class="keyword">if</span>(i===<span class="number">13</span>)<span class="keyword">return</span> reject(<span class="keyword">new</span> Error(<span class="string">"DEFINITELY NOT COUNTING THAT"</span>));</span><br><span class="line">                if(i&gt;0)console.log(i+'...');</span><br><span class="line">                <span class="keyword">else</span> resolve(console.<span class="built_in">log</span>(<span class="string">"Go"</span>));</span><br><span class="line">            &#125;,(seconds-i)*<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">countdown_(<span class="number">5</span>);</span><br><span class="line">使用promise</span><br><span class="line">countdown_(<span class="number">14</span>).then(</span><br><span class="line">    function () &#123;</span><br><span class="line">        console.<span class="built_in">log</span>(<span class="string">"countdown completed successfully"</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    function (err) &#123;</span><br><span class="line">        console.<span class="built_in">log</span>(<span class="string">"countdown experienced an error: "</span>+err.message);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"><span class="comment">/*从小于13的任何数字开始倒数都不会出错，从13或大于13的数字开始，则会在数到13的时候</span></span><br><span class="line"><span class="comment">* 会出错，但是控制台会一直打印log。调用reject并没能终止函数，他们只是修改了promise</span></span><br><span class="line"><span class="comment">* 的状态。显然countdown函数需要优化。通常，并不希望一个函数在被处理后还能继续运行</span></span><br><span class="line"><span class="comment">* (不管成功还是失败)，单数countdown却继续运行。控制台的log一点都不灵活，他们并不会</span></span><br><span class="line"><span class="comment">* 真的提供想要的控制权。</span></span><br><span class="line"><span class="comment">* promise提供了一个定义及其良好，并且可以安全地处理那些满足或者拒绝的异步任务的方式</span></span><br><span class="line"><span class="comment">* ，但是它却没有报告过程进度的能力。也就是说，promise只可能是满足或者拒绝，绝不会出</span></span><br><span class="line"><span class="comment">* 现“%50完成”。有的promise库中增加了一些很有用的功能，比如，可以报告过程,很可能</span></span><br><span class="line"><span class="comment">* JavaScript中的promise也会具备那些功能，不过现在，我们只能在没有这些功能的情况下</span></span><br><span class="line"><span class="comment">* 工作。如果想要这些功能，需要继续学习下面的内容*/</span></span><br><span class="line"><span class="comment">//事件</span></span><br><span class="line"><span class="comment">/*事件发射器可以广播事件，任意愿意监听这些事件的人都可以去做这件事。如何监听事件呢？</span></span><br><span class="line"><span class="comment">* 答案是回调。创建自己的事件系统其实很简单，即便如此，Node还是为我们提供了内建的支持</span></span><br><span class="line"><span class="comment">* 。如果使用浏览器，jQuery同样提供了一个事件机制（http://api.jquery.com/category/events）</span></span><br><span class="line"><span class="comment">* 。为了改进countdown，我们通常会Node的EvenEmitter。虽然也可以在像countdown这样的</span></span><br><span class="line"><span class="comment">* 函数中使用EventEmitter,不过实际上他的设计初衷时跟类一起使用。所以可以把countdown</span></span><br><span class="line"><span class="comment">* 函数放在Countdown类中。*/</span></span><br><span class="line">const EventEmitter = require('events').EventEmitter;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Countdown</span> <span class="title">extends</span> <span class="title">EventEmitter</span>&#123;</span></span><br><span class="line">    constructor (seconds,superstitious)&#123;</span><br><span class="line">        super();</span><br><span class="line">        <span class="keyword">this</span>.seconds = seconds;</span><br><span class="line">        <span class="keyword">this</span>.superstitious = superstitious;</span><br><span class="line">    &#125;</span><br><span class="line">    go()&#123;</span><br><span class="line">        <span class="keyword">const</span> countdown = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Promise(function (resolve,reject) &#123;</span><br><span class="line">            <span class="keyword">for</span>(let i=countdown.seconds;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">                <span class="built_in">setTimeout</span>(function () &#123;</span><br><span class="line">                    <span class="keyword">if</span>(countdown.superstitious &amp;&amp; i===<span class="number">13</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span> reject(<span class="keyword">new</span> Error(<span class="string">"DEFINITELY NOT COUNTING THAT"</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                    countdown.emit('tick',i);</span><br><span class="line">                    <span class="keyword">if</span>(i===<span class="number">0</span>)resolve();</span><br><span class="line">                &#125;,(countdown.seconds-i)*<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*Countdown类继承了EventEmitter,这样Countdown就可以发射事件。Go方法是正式开始倒计时</span></span><br><span class="line"><span class="comment">* 并返回promise的地方。注意在go函数中，我们做的第一件事就是把this赋给countdown。这</span></span><br><span class="line"><span class="comment">* 是应为在回调中，不论倒计时是否迷信数字，都需要this的值来获取倒计时的长度。要记住</span></span><br><span class="line"><span class="comment">* this是一个特殊变量，它与回调中的this不是同一个东西。所以我们需要保存当前的this值，</span></span><br><span class="line"><span class="comment">* 从而在promise中使用它。任何想要监听tick事件（可以任意命名）的人都可以监听它。接下</span></span><br><span class="line"><span class="comment">* 来看看如何使用这经过改进后的全新countdown。*/</span></span><br><span class="line"><span class="keyword">const</span> c_1 = <span class="keyword">new</span> Countdown(<span class="number">13</span>);</span><br><span class="line">c_1.on('tick',function (i) &#123;</span><br><span class="line">    if(i&gt;0)console.log(i+'...');</span><br><span class="line">&#125;);</span><br><span class="line">c_1.go().then(function () &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">"Go"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="keyword">catch</span>(function (err) &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(err.message);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode329矩阵中的最长递增路径</title>
    <url>/posts/410e261c.html</url>
    <content><![CDATA[<blockquote>
<p>给定一个整数矩阵，找出最长递增路径的长度。<br>对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。（就是非常经典的滑雪题）</p>
</blockquote>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: nums =</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [<span class="number">9</span>,<span class="number">9</span>,<span class="number">4</span>],</span><br><span class="line">  [<span class="number">6</span>,<span class="number">6</span>,<span class="number">8</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line">解释: 最长递增路径为 [<span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>]。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: nums =</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line">解释: 最长递增路径是 [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]。注意不允许在对角线方向上移动。</span><br></pre></td></tr></table></figure>

<ul>
<li>来源：力扣（LeetCode）</li>
<li>链接：<a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix</a></li>
</ul>
<blockquote>
<p>思路比较简单就是深搜+记忆化搜索</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;f;</span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(f[x][y]!=<span class="number">-1</span>)<span class="keyword">return</span> f[x][y];<span class="comment">//记忆化</span></span><br><span class="line">        f[x][y]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = x+dx[i],b=y+dy[i];</span><br><span class="line">            <span class="keyword">if</span>(a&gt;=<span class="number">0</span>&amp;&amp;a&lt;n&amp;&amp;b&gt;=<span class="number">0</span>&amp;&amp;b&lt;m&amp;&amp;matrix[x][y]&gt;matrix[a][b])</span><br><span class="line">                f[x][y] = <span class="built_in">max</span>(f[x][y],dp(a,b,matrix)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[x][y];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.empty())<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        n = matrix.<span class="built_in">size</span>(),m=matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        f = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m,<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                res = <span class="built_in">max</span>(res,dp(i,j,matrix));</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>01背包总结</title>
    <url>/posts/2b28a584.html</url>
    <content><![CDATA[<blockquote>
<p>有 $N$ 件物品和一个容量是 $V$ 的背包。每件物品只能使用一次。第i件物品的体积是 $v_i$，价值是 $w_i$。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>输入格式<br>第一行两个整数$N，V$，用空格隔开，分别表示物品数量和背包容积。<br>接下来有 $N$ 行，每行两个整数 $v_i$,$w_i$用空格隔开，分别表示第 $i$ 件物品的体积和价值。<br>输出格式<br>输出一个整数，表示最大价值。<br>数据范围</p>
</blockquote>
<p>$0&lt;N,V≤1000$<br>$0&lt;v_i,w_i≤1000$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入样例</span><br><span class="line"></span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>思路：今天太晚了，明天补上。三种方法，依次进行优化<br>增补：$F[i,j]$表示从前i个物品中选出了总体积为j的物品放入背包，物品的最大价值和。<br>$F[i,j]=max(F[i-1,j],F[i-1,j-v_i]+w_i)$<br>初值$F[0,0]=0$,其余负无穷，目标：$max{F[N][j]},  0&lt;=j&lt;=m$<br>//最朴素的做法</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N,V;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;V);</span><br><span class="line">    <span class="keyword">int</span> f[N+<span class="number">1</span>][V+<span class="number">1</span>],v[N+<span class="number">1</span>],w[N+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;v[i],&amp;w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0xcf</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=V;j++)&#123;</span><br><span class="line">            f[i][j]=f[i<span class="number">-1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=v[i];j&lt;=V;j++)&#123;</span><br><span class="line">            f[i][j]=<span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=V;j++)&#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,f[N][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>//使用滚动数组的做法<br>通过$DP$的状态转移方程，可以发现，每一阶段i的状态只与上一阶段$i-1$的状态有关。这种情况下，可以使用滚动数组的优化方法，降低空间开销。把阶段i的状态存储在第一位下标为 $i&amp;1$ 的二维数组中。当$i$为奇数时，$i&amp;1=1$ ；当$i$为偶数时，$i&amp;1=0$ ;因此，$DP$的状态就相当于在$F[0][]$和$F[1][]$两个数组中交替转移，空间复杂度从$O(nm)$降低为$O(m)$。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N,V;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;V);</span><br><span class="line">    <span class="keyword">int</span> f[<span class="number">2</span>][V+<span class="number">1</span>],v[N+<span class="number">1</span>],w[N+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;v[i],&amp;w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0xcf</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=V;j++)&#123;</span><br><span class="line">            f[i&amp;<span class="number">1</span>][j]=f[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=v[i];j&lt;=V;j++)&#123;</span><br><span class="line">            f[i&amp;<span class="number">1</span>][j]=<span class="built_in">max</span>(f[i&amp;<span class="number">1</span>][j],f[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=V;j++)&#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,f[N&amp;<span class="number">1</span>][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>//线性空间做法<br>进一步分析上面代码，容易发现在每个阶段开始时，实际上执行了一次从$F[i-1][]$到F$[i][]$的拷贝操作。这提示我们可以进一步省略调F数组的第一维，只用一维数组，即当外层循环到第i个物品时，$F[j]$表示背包中放入总体积为$j$的物品的最大价值和。请注意下述代码使用了倒序循环。循环到$j$时：</p>
</blockquote>
<ol>
<li>$F$数组的后半部分$F[j \leadsto m]$处于第$i$阶段，也就是已经考虑过放入第$i$个物品的情况。</li>
<li>前半部分$F[0 \leadsto j-1]$处于第$i-1$阶段，也就是没有第$i$个物品更新。<br>接下来$j$不断减小，意味着我们总是用第$i-1$阶段的状态向第$i$个阶段状态转移。<br>如果使用正序循环，假设$F[j]$被$F[j-v_i]+w_i$更新，接下来j增大到$j+v_i$时，$F[j+v_i]$又可能被$F[j]+w_i$更新。此时，两个都处于第i个状态的状态之间发生了转移，相当于第i个物品被使用了两次。所以，必须使用倒序循环才符合0/1背包问题中每个物品是唯一的，只能放入背包一次。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N,V;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;V);</span><br><span class="line">    <span class="keyword">int</span> f[V+<span class="number">1</span>],v[N+<span class="number">1</span>],w[N+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;v[i],&amp;w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0xcf</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=V;j&gt;=v[i];j--)&#123;</span><br><span class="line">            f[j]=<span class="built_in">max</span>(f[j],f[j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=V;j++)ans = <span class="built_in">max</span>(ans,f[j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-50-Pow-x-n</title>
    <url>/posts/89f24699.html</url>
    <content><![CDATA[<blockquote>
<p>实现 pow(x, n) ，即计算 x 的 n 次幂函数。</p>
</blockquote>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: <span class="number">2.00000</span>, <span class="number">10</span></span><br><span class="line">输出: <span class="number">1024.00000</span></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: <span class="number">2.10000</span>, <span class="number">3</span></span><br><span class="line">输出: <span class="number">9.26100</span></span><br><span class="line">示例 <span class="number">3</span>:</span><br><span class="line"></span><br><span class="line">输入: <span class="number">2.00000</span>, <span class="number">-2</span></span><br><span class="line">输出: <span class="number">0.25000</span></span><br><span class="line">解释: <span class="number">2</span><span class="number">-2</span> = <span class="number">1</span>/<span class="number">22</span> = <span class="number">1</span>/<span class="number">4</span> = <span class="number">0.25</span></span><br></pre></td></tr></table></figure>
<p>说明:</p>
<ol>
<li>-100.0 &lt; x &lt; 100.0</li>
<li>n 是 32 位有符号整数，其数值范围是([-2^{31},2^{31}-1]) 。</li>
</ol>
<ul>
<li>来源：力扣（LeetCode）</li>
<li>链接：<a href="https://leetcode-cn.com/problems/powx-n" target="_blank" rel="noopener">https://leetcode-cn.com/problems/powx-n</a></li>
</ul>
<blockquote>
<p>思路：思路：快速幂模板题</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> b=<span class="built_in">abs</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(b&amp;<span class="number">1</span>)ans = ans * x;</span><br><span class="line">            x = x * x ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>/ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>位运算</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode357计算各个位数不同的数字个数</title>
    <url>/posts/52d85e26.html</url>
    <content><![CDATA[<blockquote>
<p>给定一个非负整数 n，计算各位数字都不同的数字 x 的个数，其中 0 ≤ x &lt; 10^n 。</p>
</blockquote>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: <span class="number">2</span></span><br><span class="line">输出: <span class="number">91</span></span><br><span class="line">解释: 答案应为除去 <span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">66</span>,<span class="number">77</span>,<span class="number">88</span>,<span class="number">99</span> 外，在 [<span class="number">0</span>,<span class="number">100</span>) 区间内的所有数字。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>思路：这题第一感觉就是找规律…可以结合一些组合数学的知识然后dp解决。可以这样考虑，n限制了我们需要考虑的数的位数，稍微思考一下就可以得出如下结论，对于一个n位数，第一位数有9种选择（0要排除），第二位数不能和第一位数相同故有9种选择，第三位数不能和前两位数相同故有8种选择..依此类推到最后一位数，算完后要加上n-1位各个位数不同的数字个数(第一位是0的情况)。举例：n=1时各个位数不同的数字有10个，n=2时由上述过程各个位数不同的数字有9*9+10=91个。实现代码如下：</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countNumbersWithUniqueDigits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans[<span class="number">10</span>];</span><br><span class="line">        ans[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        ans[<span class="number">1</span>] = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">9</span>,k=<span class="number">1</span>;k&lt;i;k++)&#123;</span><br><span class="line">                temp = temp * j;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            ans[i] = temp * <span class="number">9</span> + ans[i<span class="number">-1</span>];            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>动态规划</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>leetcode</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode322零钱兑换</title>
    <url>/posts/89f24625.html</url>
    <content><![CDATA[<blockquote>
<p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
</blockquote>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: coins = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>], amount = <span class="number">11</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: <span class="number">11</span> = <span class="number">5</span> + <span class="number">5</span> + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: coins = [<span class="number">2</span>], amount = <span class="number">3</span></span><br><span class="line">输出: <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>说明: 你可以认为每种硬币的数量是无限的。</li>
</ul>
<blockquote>
<p>思路：经典的dp问题，完全背包。得找个时间把背包九讲复习整理一遍。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;f(amount+<span class="number">1</span>,INT_MAX/<span class="number">2</span>);</span><br><span class="line">        f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : coins)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = c;i&lt;=amount;i++)&#123;</span><br><span class="line">                f[i] = <span class="built_in">min</span>(f[i],f[i-c]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(f[amount]==INT_MAX/<span class="number">2</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> f[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode486预测赢家</title>
    <url>/posts/4651617d.html</url>
    <content><![CDATA[<blockquote>
<p>给定一个表示分数的非负整数数组。 玩家1从数组任意一端拿取一个分数，随后玩家2继续从剩余数组任意一端拿取分数，然后玩家1拿，……。每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。<br>给定一个表示分数的数组，预测玩家1是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。</p>
</blockquote>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: [<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>]</span><br><span class="line">输出: False</span><br><span class="line">解释: 一开始，玩家<span class="number">1</span>可以从<span class="number">1</span>和<span class="number">2</span>中进行选择。</span><br><span class="line">如果他选择<span class="number">2</span>（或者<span class="number">1</span>），那么玩家<span class="number">2</span>可以从<span class="number">1</span>（或者<span class="number">2</span>）和<span class="number">5</span>中进行选择。如果玩家<span class="number">2</span>选择了<span class="number">5</span>，那么玩家<span class="number">1</span>则只剩下<span class="number">1</span>（或者<span class="number">2</span>）可选。</span><br><span class="line">所以，玩家<span class="number">1</span>的最终分数为 <span class="number">1</span> + <span class="number">2</span> = <span class="number">3</span>，而玩家<span class="number">2</span>为 <span class="number">5</span>。</span><br><span class="line">因此，玩家<span class="number">1</span>永远不会成为赢家，返回 False。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: [<span class="number">1</span>, <span class="number">5</span>, <span class="number">233</span>, <span class="number">7</span>]</span><br><span class="line">输出: True</span><br><span class="line">解释: 玩家<span class="number">1</span>一开始选择<span class="number">1</span>。然后玩家<span class="number">2</span>必须从<span class="number">5</span>和<span class="number">7</span>中进行选择。无论玩家<span class="number">2</span>选择了哪个，玩家<span class="number">1</span>都可以选择<span class="number">233</span>。</span><br><span class="line">最终，玩家<span class="number">1</span>（<span class="number">234</span>分）比玩家<span class="number">2</span>（<span class="number">12</span>分）获得更多的分数，所以返回 True，表示玩家<span class="number">1</span>可以成为赢家。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:</p>
</blockquote>
<ol>
<li>1 &lt;= 给定的数组长度 &lt;= 20.</li>
<li>数组里所有分数都为非负数且不会大于10000000。</li>
<li>如果最终两个玩家的分数相等，那么玩家1仍为赢家。</li>
</ol>
<ul>
<li>来源：力扣（LeetCode）</li>
<li>链接：<a href="https://leetcode-cn.com/problems/predict-the-winner" target="_blank" rel="noopener">https://leetcode-cn.com/problems/predict-the-winner</a></li>
</ul>
<blockquote>
<p>思路：（区间dp问题，一般都要先枚举区间长度）。状态定义：f[i][j表示取完了除i-j区间外所有数，先手玩家可得最高分数。初始化时如果数组的数为奇数个则最后一次是先手玩家取数，若为偶数则啥也不干。枚举区间长度2-n，l表示区间左端点，r表示区间右端点。若当前取的数是第奇数个则是先手玩家取，故要采取对自己最有利的方式,从左右端点中取最大的那个数，状态转移方程为:<br>$f[l][r] = max(f[l+1][r] + nums[l],f[l][r-1]+nums[r])$<br>否则是对方取数，则会让先手玩家得分为最小，状态转移方程为：<br>$f[l][r] = min(f[l+1][r],f[l][r-1])$<br>（因为f[i][j]是先手玩家能得最大分）<br>由于若两个玩家最后的分数相等也是先手玩家赢，所以最后要比较一下先手玩家和后手玩家的分数。<br>代码如下：</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">PredictTheWinner</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;f(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">if</span>(n &amp; <span class="number">1</span>)<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)f[i][i] = nums[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> ; i&lt;=n; i++)&#123;<span class="comment">//枚举区间长度</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j+i<span class="number">-1</span>&lt;n;j++)&#123;<span class="comment">//f[i][j]表示取完了除i-j区间之后 玩家可得最高分数</span></span><br><span class="line">                <span class="keyword">int</span> l = j, r = i+j<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span>((n-(r-l+<span class="number">1</span>))%<span class="number">2</span>==<span class="number">0</span>)f[l][r] = <span class="built_in">max</span>(f[l+<span class="number">1</span>][r] + nums[l],f[l][r<span class="number">-1</span>]+nums[r]);</span><br><span class="line">                <span class="keyword">else</span> f[l][r] = <span class="built_in">min</span>(f[l+<span class="number">1</span>][r],f[l][r<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i=<span class="number">0</span>;i&lt;n;i++)sum+=nums[i];</span><br><span class="line">        <span class="keyword">if</span>(f[<span class="number">0</span>][n<span class="number">-1</span>]&gt;=sum-f[<span class="number">0</span>][n<span class="number">-1</span>])<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题解167,88,155,32,84,42</title>
    <url>/posts/81be5994.html</url>
    <content><![CDATA[<blockquote>
<p>练习了一下双指针，单调栈。三道简单，三道困难。分别是两数之和 II - 输入有序数组，合并两个有序数组，最小栈，最长有效括号，柱状图中最大的矩形，接雨水。难度着实有点大。</p>
</blockquote>
<a id="more"></a>

<blockquote>
<p>两数之和<br>给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。<br>示例:<br>输入: numbers = [2, 7, 11, 15], target = 9<br>输出: [1,2]<br>解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</p>
</blockquote>
<ul>
<li>来源：力扣（LeetCode）</li>
<li>链接：<a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted</a></li>
</ul>
<blockquote>
<p>思路：利用单调性使用双指针，可以想到假设(i&gt;j)nums[i]+nums[j]&gt;=target,<br>对于特定的j，i是使这个不等式成立的最小下标，则当j增大时，i必然减小或者不变。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>,i=nums.<span class="built_in">size</span>()<span class="number">-1</span>;j&lt;nums.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i<span class="number">-1</span>&gt;j&amp;&amp;nums[i<span class="number">-1</span>]+nums[j]&gt;=target)i--;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]+nums[j]==target)<span class="keyword">return</span> &#123;j+<span class="number">1</span>,i+<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>合并连个有序数组:<br>给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。<br>说明:</p>
</blockquote>
<ol>
<li>初始化 nums1 和 nums2 的元素数量分别为 m 和 n。</li>
<li>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。<blockquote>
<p>示例:<br>输入:<br>nums1 = [1,2,3,0,0,0], m = 3<br>nums2 = [2,5,6], n = 3<br>输出: [1,2,2,3,5,6]</p>
</blockquote>
</li>
</ol>
<ul>
<li>来源：力扣（LeetCode）</li>
<li>链接：<a href="https://leetcode-cn.com/problems/merge-sorted-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-sorted-array</a></li>
</ul>
<blockquote>
<p>思路：非常简单啦，考研复习时王道上面就有这个题，不多解释了。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=m<span class="number">-1</span>,j=n<span class="number">-1</span>,k=n+m<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i]&gt;nums2[j])nums1[k--]=nums1[i--];</span><br><span class="line">            <span class="keyword">else</span> nums1[k--]=nums2[j--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span>)nums1[k--]=nums2[j--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>最小栈：<br>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。</p>
</blockquote>
<ul>
<li><p>push(x) – 将元素 x 推入栈中。</p>
</li>
<li><p>pop() – 删除栈顶的元素。</p>
</li>
<li><p>top() – 获取栈顶元素。</p>
</li>
<li><p>getMin() – 检索栈中的最小元素。<br>示例:<br>MinStack minStack = new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.getMin(); –&gt; 返回 -3.<br>minStack.pop();<br>minStack.top(); –&gt; 返回 0.<br>minStack.getMin(); –&gt; 返回 -2.</p>
</li>
<li><p>来源：力扣（LeetCode）</p>
</li>
<li><p>链接：<a href="https://leetcode-cn.com/problems/min-stack" target="_blank" rel="noopener">https://leetcode-cn.com/problems/min-stack</a></p>
</li>
</ul>
<blockquote>
<p>思路：比较简单，维护两个栈，注意在插入时，如果保存最小元素的栈空，则直接插入，否则最小栈插入当前带插入元素和栈顶元素的小者。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;stkmin,stk;</span><br><span class="line">    MinStack() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stk.push(x);</span><br><span class="line">        <span class="keyword">if</span>(stkmin.empty())stkmin.push(x);</span><br><span class="line">        <span class="keyword">else</span> stkmin.push(<span class="built_in">min</span>(x,stkmin.top()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stk.pop();</span><br><span class="line">        stkmin.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stk.top();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stkmin.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>重头戏来了。。<br>最长有效括号：<br>给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。<br>示例 1:<br>输入: “(()”<br>输出: 2<br>解释: 最长有效括号子串为 “()”<br>示例 2:<br>输入: “)()())”<br>输出: 4<br>解释: 最长有效括号子串为 “()()”</p>
</blockquote>
<ul>
<li>来源：力扣（LeetCode）</li>
<li>链接：<a href="https://leetcode-cn.com/problems/longest-valid-parentheses" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-valid-parentheses</a></li>
</ul>
<blockquote>
<p>思路：要用到一些关于括号匹配的性质。如果括号序列有效，则对于每个括号，其对应的括号是固定的。比如(())，第1个括号必然对应第4个括号，第2个括号必然对应第3个括号，反之亦然。还有一个性质就是，如果一个括号序列合法，将左括号看作1，右括号看作-1，则这个序列的前缀和都大于0，且总和为0。但是还要考虑一下左括号比右括号多的情况，因此要反着考虑一遍。所以可以想到：cnt作为前缀和，碰到左括号则cnt++,否则cnt–，如果cnt&lt;0,则要从当前元素的下一个位置重新开始，并置cnt为0。为什么start不是从start+1而是从i+1开始呢，这个就用到了第一个性质，如果cnt&lt;0,则start到i不可能会有合法序列。如果cnt==0，说明找到了一个新的合法序列。返回最大值即可</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">work</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,start=<span class="number">0</span>,cnt=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'('</span>)cnt++;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cnt--;</span><br><span class="line">                <span class="keyword">if</span>(cnt&lt;<span class="number">0</span>)start=i+<span class="number">1</span>,cnt=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(cnt==<span class="number">0</span>)res=<span class="built_in">max</span>(res,i-start+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = work(s);</span><br><span class="line">        reverse(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c:s)c^=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(res,work(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>柱状图中最大矩形：<br>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。<br><img src="https://ae01.alicdn.com/kf/H60940b1e41cf461b9837212a24b35b582.png" alt=""><br>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。<br><img src="https://ae01.alicdn.com/kf/H3af88c1f70e349b2b6fa5ed63cd25d16L.png" alt=""></p>
</blockquote>
<blockquote>
<p>图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。<br>示例:<br>输入: [2,1,5,6,2,3]<br>输出: 10</p>
</blockquote>
<ul>
<li>来源：力扣（LeetCode）</li>
<li>链接：<a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram" target="_blank" rel="noopener">https://leetcode-cn.com/problems/largest-rectangle-in-histogram</a></li>
</ul>
<blockquote>
<p>思路：单调栈（找到每个柱子的左右两边第一个小于自己高度的柱子）。根据每个柱子的高度来找到左右两边第一个小于自己高度的柱子存在left和right中，枚举每个柱子能画出的最大面积$(height[i]*(right[i]-left[i]-1))$。</p>
<ol>
<li>如果栈不为空，且栈顶元素大于当前元素则出栈(不可能成为候选者)</li>
<li>如果栈为空则left(i)(或者right(i))赋为-1（或者n）否则赋为栈顶值</li>
<li>当前元素进栈</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = heights.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;s;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;left(n),right(n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(s.<span class="built_in">size</span>()&amp;&amp;heights[s.top()]&gt;=heights[i])s.pop();</span><br><span class="line">            <span class="keyword">if</span>(s.empty())left[i]=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> left[i]=s.top();</span><br><span class="line">            s.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(s.<span class="built_in">size</span>())s.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">while</span>(s.<span class="built_in">size</span>()&amp;&amp;heights[s.top()]&gt;=heights[i])s.pop();</span><br><span class="line">            <span class="keyword">if</span>(s.empty())right[i]=n;</span><br><span class="line">            <span class="keyword">else</span> right[i]=s.top();</span><br><span class="line">            s.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)res = <span class="built_in">max</span>(res,heights[i]*(right[i]-left[i]<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>接雨水：<br>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。<br><img src="https://ae01.alicdn.com/kf/H3e93ddc033774db4bb03c73c76403220l.png" alt=""><br>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。<br>示例:<br>输入: [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出: 6</p>
</blockquote>
<ul>
<li>来源：力扣（LeetCode）</li>
<li>链接：<a href="https://leetcode-cn.com/problems/trapping-rain-water" target="_blank" rel="noopener">https://leetcode-cn.com/problems/trapping-rain-water</a></li>
</ul>
<blockquote>
<p>思路：单调栈。关键在于找出雨水的面积求法。可以按层叠加。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">height</span>.<span class="built_in">size</span>(),res=<span class="number">0</span>,last;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            last = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(s.<span class="built_in">size</span>()&amp;&amp;<span class="built_in">height</span>[s.top()]&lt;=<span class="built_in">height</span>[i])&#123;</span><br><span class="line">                <span class="keyword">int</span> t = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                res+=(i-t<span class="number">-1</span>)*(<span class="built_in">height</span>[t]-last);</span><br><span class="line">                last = <span class="built_in">height</span>[t];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">size</span>())res+=(i-s.top()<span class="number">-1</span>)*(<span class="built_in">height</span>[i]-last);</span><br><span class="line">            s.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>双指针</category>
        <category>栈</category>
        <category>单调栈</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
        <tag>栈</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>多重背包</title>
    <url>/posts/4651617g.html</url>
    <content><![CDATA[<blockquote>
<p>多重背包模型如下：<br>有 N 种物品和一个容量是 M 的背包。第 i 种物品最多有 \(C_i\) 件，每件体积是 \(V_i\)，价值是 \(W_i\)。求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。</p>
</blockquote>
<a id="more"></a>
<p>思路:<br>直接拆分法，求解多重背包问题最直接的方法是把第i种物品当作独立的\(C_i\)个物品，转化为共\(\sum_{i=1}^{N}C_i\)个物品的0/1背包问题进行计算，时间复杂度为复杂度\(O(M*\sum_{i=1}^{N}C_i)\)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> f[MAX_M+<span class="number">1</span>];</span><br><span class="line"><span class="built_in">memset</span>(f,oxcf,<span class="keyword">sizeof</span>(f));</span><br><span class="line">f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=c[i];j++)&#123;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> k=m;k&gt;=v[i];k--)&#123;</span><br><span class="line">            f[k]=<span class="built_in">max</span>(f[k],f[k-v[i]]+w[i]);</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=m;i++)ans = <span class="built_in">max</span> (ans,f[i]);</span><br></pre></td></tr></table></figure>
<p>使用二进制优化<br>其实不用把c[i]个物品分成单独的01背包，可以使用二进制表示<br>如：s = 10 = 1 + 2 + 4 + 3<br>所以可以拆分成V=1<em>v,W=1</em>w, V=2<em>v,W=2</em>w, V=4<em>v,W=4</em>w, V=3<em>v,W=3</em>w的01背包<br>代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,f[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Goods</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Goods&gt;goods;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> v,w,s;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;v&gt;&gt;w&gt;&gt;s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=s;k*=<span class="number">2</span>)&#123;</span><br><span class="line">            goods.push_back(&#123;k*v,k*w&#125;);</span><br><span class="line">            s-=k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s&gt;<span class="number">0</span>)goods.push_back(&#123;s*v,s*w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> g:goods)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=g.v;j--)&#123;</span><br><span class="line">            f[j]=<span class="built_in">max</span>(f[j],f[j-g.v]+g.w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f[m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用单调队列优化：这个坑还没补上，还没看懂</p>
]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>完全背包</title>
    <url>/posts/4651617h.html</url>
    <content><![CDATA[<blockquote>
<p>完全背包问题的模型如下：<br>有 N 种物品和一个容量是 V 的背包，每种物品都有无限件可用。第 i 种物品的体积是 \(V_i\)，价值是 \(W_i\)。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。</p>
</blockquote>
<a id="more"></a>


<blockquote>
<p>输入格式<br>第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。接下来有 N 行，每行两个整数 \(V_i\),\(W_i\)，用空格隔开，分别表示第 i 种物品的体积和价值。<br><br>输出格式<br>输出一个整数，表示最大价值。<br>数据范围<br>0&lt;N,V≤1000<br>0&lt;$V_i$,$W_i$≤1000</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入样例</span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>思路：先考虑使用传统的二维线性DP的做法。设F[i,j]表示从前i种物品中选出了总体积为j的物品放入背包，物品的最大价值和。<br>$F[i,j] = max(F[i-1,j],F[i-1,j-V_i]+W_i)$<br>初值:$F[0,0]=0$,其余均为负无穷。目标：$max(F[N][j])$。<br>与0/1背包一样，我们也可以省略F数组的i这一维。根据我们在0/1背包中对循环顺序的分析，当采用正序循环时，就对应着每种物品可以使用无限次，也对应着$F[i,j] = F[i,j-V_i]+W_i$这个在两个均处于i阶段的状态之间进行转移的方程。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N,V,v=<span class="number">0</span>,w=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;V);</span><br><span class="line">    <span class="keyword">int</span> f[V+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0xcf</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;v,&amp;w);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=v;j&lt;=V;j++)&#123;</span><br><span class="line">            f[j]=<span class="built_in">max</span>(f[j],f[j-v]+w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=V;j++)ans = <span class="built_in">max</span>(ans,f[j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔2</title>
    <url>/posts/4651617f.html</url>
    <content><![CDATA[<blockquote>
<p>今天突然心血来潮想换个ide写算法题，试了vscode和visual studio,笔记本性能比较一般，运行VS会卡顿。。所以还是选择了visual studio code，不过这玩意儿只是个编辑器，还需要自己配置编译器，下插件，麻烦死了，花了老半天功夫才弄好，一直无法调试，一调试程序就崩溃了，后来改了很多配置文件才弄好，把配置文件贴在这里好了（我的服务器之前欠费宕机了，今天花了点时间又整了一下，顺便买了个域名，弄了一下域名备案，不知道啥时候可以备下来hhh）。</p>
</blockquote>
<a id="more"></a>

<blockquote>
<p>先下载安装vscode，按ctrl+shift+x,搜索c++,安装<br><img src="https://ae01.alicdn.com/kf/H5897989a61d947088d3a814c4d56c7282.png" alt=""><br>再搜索code run,安装<br><img src="https://ae01.alicdn.com/kf/Hebff0b70113f4aadb056b2e15a78d011k.png" alt=""><br>（还需要下载MinGW点击下载）打开MinGW安装器界面，勾选一下几个选项（右键Make for Installation进行标记）：</p>
</blockquote>
<blockquote>
<ol>
<li>minGW32-gcc(bin)</li>
<li>minGW32-gcc-g++(bin)</li>
<li>minGW32-gdb(bin)</li>
</ol>
</blockquote>
<blockquote>
<p>点击左上角的Installation菜单下的Apply Changes以应用修改，过程需要联网，安装完成后需要为环境变量配置Path，添加E:\MinGW\bin。<br>此时重新启动VSCode，编译完代码后按快捷键F5或者在菜单栏中找到调试按钮以进行调试操作。<br>注意vscode调试需要在打开的文件夹中进行，可以在资源管理器中创建一个文件夹来保存临时代码文件。<br>打开文件夹，创建一个.cpp文件，编写一段helloworld代码，创建一个.vscode文件夹。结构如下图：<br><img src="https://ae01.alicdn.com/kf/H7e95cc578c074334aa6f283bf1d7d58fw.png" alt=""><br>在.vscode中创建四个.json文件：</p>
</blockquote>
<p>c_cpp_properties.json</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"configurations"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"Win32"</span>,</span><br><span class="line">            <span class="string">"includePath"</span>: [</span><br><span class="line">                <span class="string">"$&#123;workspaceFolder&#125;"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">"defines"</span>: [</span><br><span class="line">                <span class="string">"_DEBUG"</span>,</span><br><span class="line">                <span class="string">"UNICODE"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">"compilerPath"</span>: <span class="string">"E:\\MinGW\\bin\\g++.exe"</span>,		</span><br><span class="line">            <span class="string">"intelliSenseMode"</span>: <span class="string">"msvc-x64"</span>,</span><br><span class="line">            <span class="string">"browse"</span>: &#123;</span><br><span class="line">                <span class="string">"path"</span>: [</span><br><span class="line">                    <span class="string">"$&#123;workspaceFolder&#125;"</span></span><br><span class="line">                ],</span><br><span class="line">                <span class="string">"limitSymbolsToIncludedHeaders"</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="string">"databaseFilename"</span>: <span class="string">""</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"cStandard"</span>: <span class="string">"c11"</span>,</span><br><span class="line">            <span class="string">"cppStandard"</span>: <span class="string">"c++17"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"version"</span>: <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//compilerPath的路径与安装的WinGW的c++环境对应，其他不用改。</span></span><br></pre></td></tr></table></figure>
<p>launch.json</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用 IntelliSense 了解相关属性。</span></span><br><span class="line">    <span class="comment">// 悬停以查看现有属性的描述。</span></span><br><span class="line">    <span class="comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">    <span class="string">"configurations"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"(gdb) Launch"</span>,</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"cppdbg"</span>,</span><br><span class="line">            <span class="string">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">            <span class="string">"program"</span>: <span class="string">"$&#123;workspaceFolder&#125;/$&#123;fileBasenameNoExtension&#125;.exe"</span>,	<span class="comment">//要运行的文件</span></span><br><span class="line">            <span class="string">"args"</span>: [],</span><br><span class="line">            <span class="string">"stopAtEntry"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"cwd"</span>: <span class="string">"$&#123;workspaceFolder&#125;"</span>,</span><br><span class="line">            <span class="string">"environment"</span>: [],</span><br><span class="line">            <span class="string">"externalConsole"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">"MIMode"</span>: <span class="string">"gdb"</span>,</span><br><span class="line">            <span class="string">"miDebuggerPath"</span>: <span class="string">"E:\\MinGW\\bin\\gdb.exe"</span>,</span><br><span class="line">            <span class="string">"setupCommands"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">"description"</span>: <span class="string">"Enable pretty-printing for gdb"</span>,</span><br><span class="line">                    <span class="string">"text"</span>: <span class="string">"-enable-pretty-printing"</span>,</span><br><span class="line">                    <span class="string">"ignoreFailures"</span>: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="string">"preLaunchTask"</span>: <span class="string">"complie"</span> <span class="comment">// 调试会话开始前执行的任务，类似于Ant，这里为我们的编译任务</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//miDebuggerPath这个也要改。</span></span><br></pre></td></tr></table></figure>
<p>settings.json</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"files.associations"</span>: &#123;</span><br><span class="line">        <span class="string">"iostream"</span>: <span class="string">"cpp"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tasks.json</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// See https://go.microsoft.com/fwlink/?LinkId=733558</span></span><br><span class="line">    <span class="comment">// for the documentation about the tasks.json format</span></span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"2.0.0"</span>,</span><br><span class="line">    <span class="string">"tasks"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"label"</span>: <span class="string">"complie"</span>,			<span class="comment">//任务名</span></span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"shell"</span>,</span><br><span class="line">            <span class="string">"command"</span>: <span class="string">"g++"</span>,</span><br><span class="line">            <span class="string">"args"</span>: [</span><br><span class="line">                <span class="comment">// Ask msbuild to generate full paths for file names.</span></span><br><span class="line">                <span class="string">"-g"</span>,</span><br><span class="line">                <span class="string">"$&#123;fileBasename&#125;"</span>,</span><br><span class="line">                <span class="string">"-o"</span>,</span><br><span class="line">                <span class="string">"$&#123;fileBasenameNoExtension&#125;.exe"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">"presentation"</span>: &#123;</span><br><span class="line">                <span class="comment">// Reveal the output only if unrecognized errors occur.</span></span><br><span class="line">                <span class="string">"reveal"</span>: <span class="string">"always"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// Use the standard MS compiler pattern to detect errors, warnings and infos</span></span><br><span class="line">            <span class="string">"problemMatcher"</span>: <span class="string">"$msCompile"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这样就完成了配置，可以尽情的玩耍了。<br>去中南的oj逛了逛感觉那些同学的做题热情不够哇。。除了排名最靠前的几个同学，后面的同学刷的比较少。顺手注册A了几个题hhh<br><img src="https://ae01.alicdn.com/kf/H4c053fe50fc949168066a53a5139f5f85.png" alt=""></p>
</blockquote>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔</title>
    <url>/posts/4651617e.html</url>
    <content><![CDATA[<blockquote>
<p>27号放假在家咸鱼了将近20天所以鸽了近20天。。15号回学校了，可以继续跟新博客了hhh。今天主要学习了一点机器学习的相关知识。<br>(今天有个颇有好感的老同学来找我玩了(她今天穿的有丶好看)，虽然啥也没干，也还是很开心的hhh，人家大老远跑过来连杯奶茶都没给人喝真是个大傻逼，感觉自己没机会了,害。第一次看到她的时候不记得是上啥课了，当时就感觉i了i了。。。害。。。)</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>了解了用于分类的线性模型<br>线性模型也广泛应用于分类问题。<br>$y=w[0]x[0]+w[1]x[1]+…+w[p]*x[p]+b&gt;0$<br>这个公式看起来与线性回归的公式非常相似，但我们没有返回特征的加权求和，而是为预测设置了阈值。如果函数值小于0，就预测类别为-1；如果函数值大于0，就预测类别为+1。对于所有用于分类的线性模型，这个预测规则都是通用的。同样，有很多种不同的方法来找出系数w和截距b。<br>对于用于回归的线性模型，输出y是特征的线性函数，是直线、平面或者超平面。对于用于分类的线性模型，决策边界是输入的线性模型。换句话说，线性分类器是利用直线、平面或超平面来分开两个类别的分类器。</p>
</blockquote>
<blockquote>
<p>学习线性模型有很多种算法。这些算法的区别在于以下两点：</p>
</blockquote>
<ul>
<li>系数和截距的特定组合对训练数据拟合好坏的度量方法；</li>
<li>是否使用正则化，以及使用哪种正则化方法</li>
</ul>
<blockquote>
<p>不同的算法使用不同的方法来度量“对训练集拟合的好坏”。由于数学上的技术原因，不可能调节w和b使得算法产生的误分类数量最少。<br>最常见的两种线性分类算法是Logistic回归（logistic regression）和线性支持向量机(SVM)，虽然含有回归，但其实是一种分类算法。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">from sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line">from sklearn.svm <span class="keyword">import</span> LinearSVC</span><br><span class="line">X,y=mglearn.datasets.make_forge()</span><br><span class="line">fig,axes=plt.subplots(<span class="number">1</span>,<span class="number">2</span>,figsize=(<span class="number">10</span>,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> model,ax in zip([LinearSVC(),LogisticRegression()],axes):</span><br><span class="line">    clf = model.fit(X,y)</span><br><span class="line">    mglearn.plots.plot_2d_separator(clf,X,<span class="built_in">fill</span>=False,eps=<span class="number">0.5</span>,ax=ax,alpha=<span class="number">.7</span>)</span><br><span class="line">    mglearn.discrete_scatter(X[:,<span class="number">0</span>],X[:,<span class="number">1</span>],y,ax=ax)</span><br><span class="line">    ax.set_title(<span class="string">"&#123;&#125;"</span>.format(clf.__class__.__name__))</span><br><span class="line">    ax.set_xlabel(<span class="string">"Feature 0"</span>)</span><br><span class="line">    ax.set_ylabel(<span class="string">"Feature 1"</span>)</span><br><span class="line">axes[<span class="number">0</span>].legend()</span><br></pre></td></tr></table></figure>
<p><img src="https://ae01.alicdn.com/kf/H119bded0afe546f2acd92aad58a13badX.png" alt=""></p>
<blockquote>
<p>图中，forge数据集的第一个特征位于x轴，第二个特征位于y轴，与前面相同。图中展示了LinearSVC和LogisticRegression得到的决策边界，都是直线，将顶部归为类别1的区域和底部归为类别0的区域分开了。换句话说，对于每个分类器而言，位于黑线上方的新数据点都会被化为类别1，下方化为类别0。<br>两个模型都默认使用L2正则化，就像Ridge对回归所做的那样。<br>对于LinearSVC和LogisticRegression，决定正则化强度的权衡参数叫做C。C值越大，对应的正则化越弱。换句话说，如果参数C值较大，那么LinearSVC和LogisticRegression将尽可能将训练集拟合到最好，而如果C值较小，那么模型更强调是系数向量接近于0。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy as np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot as plt</span><br><span class="line"><span class="keyword">import</span> pandas as pd</span><br><span class="line"><span class="keyword">import</span> mglearn</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"></span><br><span class="line">from sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line">from sklearn.svm <span class="keyword">import</span> LinearSVC</span><br><span class="line"></span><br><span class="line">warnings.filterwarnings(<span class="string">"ignore"</span>)</span><br><span class="line">X,y = mglearn.datasets.make_forge()</span><br><span class="line">fig,axes = plt.subplots(<span class="number">1</span>,<span class="number">2</span>,figsize=(<span class="number">10</span>,<span class="number">3</span>))</span><br><span class="line"><span class="keyword">for</span> model,ax in zip([LinearSVC(),LogisticRegression()],axes):</span><br><span class="line">    clf = model.fit(X,y)</span><br><span class="line">    mglearn.plots.plot_2d_separator(clf,X,<span class="built_in">fill</span> = False,eps=<span class="number">0.5</span>,ax=ax,alpha=<span class="number">.7</span>)</span><br><span class="line">    mglearn.discrete_scatter(X[:,<span class="number">0</span>],X[:,<span class="number">1</span>],y,ax=ax)</span><br><span class="line">    ax.set_title(<span class="string">"&#123;&#125;"</span>.format(clf.__class__.__name__))</span><br><span class="line">    ax.set_xlabel(<span class="string">"Feature 0"</span>)</span><br><span class="line">    ax.set_ylabel(<span class="string">"Feature 1"</span>)</span><br><span class="line">axes[<span class="number">0</span>].legend()</span><br></pre></td></tr></table></figure>
<p><img src="https://ae01.alicdn.com/kf/H052171b433bf4d0dbce937ea9cb48e62Y.png" alt=""></p>
<blockquote>
<p>较小的参数C可以让算法尽量适应“大多数”数据点，而较大的C值更强调每个数据点都分类正确的重要性。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">from sklearn.datasets <span class="keyword">import</span> load_breast_cancer</span><br><span class="line">from sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">cancer = load_breast_cancer()</span><br><span class="line">X_train,X_test,y_train,y_test = train_test_split(</span><br><span class="line">    cancer.data,cancer.target,stratify=cancer.target,random_state=<span class="number">42</span>)</span><br><span class="line">logreg = LogisticRegression().fit(X_train,y_train)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Training set score:&#123;:.3f&#125;"</span>.format(logreg.score(X_train,y_train)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Test set score:&#123;:.3f&#125;"</span>.format(logreg.score(X_test,y_test)))</span><br><span class="line"></span><br><span class="line">Training <span class="built_in">set</span> score:<span class="number">0.955</span></span><br><span class="line">Test <span class="built_in">set</span> score:<span class="number">0.958</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">logreg100 = LogisticRegression(C=<span class="number">100</span>).fit(X_train,y_train)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Training set score:&#123;:.3f&#125;"</span>.format(logreg100.score(X_train,y_train)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Test set score:&#123;:.3f&#125;"</span>.format(logreg100.score(X_test,y_test)))</span><br><span class="line"></span><br><span class="line">Training <span class="built_in">set</span> score:<span class="number">0.972</span></span><br><span class="line">Test <span class="built_in">set</span> score:<span class="number">0.965</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">logreg001 = LogisticRegression(C=<span class="number">0.01</span>).fit(X_train,y_train)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Training set score:&#123;:.3f&#125;"</span>.format(logreg001.score(X_train,y_train)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Test set score:&#123;:.3f&#125;"</span>.format(logreg001.score(X_test,y_test)))</span><br><span class="line"></span><br><span class="line">Training <span class="built_in">set</span> score:<span class="number">0.934</span></span><br><span class="line">Test <span class="built_in">set</span> score:<span class="number">0.930</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">plt.plot(logreg.coef_.T,<span class="string">'o'</span>,label=<span class="string">"C=1"</span>)</span><br><span class="line">plt.plot(logreg100.coef_.T,<span class="string">'^'</span>,label=<span class="string">"C=100"</span>)</span><br><span class="line">plt.plot(logreg001.coef_.T,<span class="string">'v'</span>,label=<span class="string">"C=0.01"</span>)</span><br><span class="line">plt.xticks(range(cancer.data.shape[<span class="number">1</span>]),cancer.feature_names,rotation=<span class="number">90</span>)</span><br><span class="line">plt.hlines(<span class="number">0</span>,<span class="number">0</span>,cancer.data.shape[<span class="number">1</span>])</span><br><span class="line">plt.ylim(<span class="number">-5</span>,<span class="number">5</span>)</span><br><span class="line">plt.xlabel(<span class="string">"Coefficient index"</span>)</span><br><span class="line">plt.ylabel(<span class="string">"Coefficient magnitude"</span>)</span><br><span class="line">plt.legend()</span><br></pre></td></tr></table></figure>
<p><img src="https://ae01.alicdn.com/kf/Hd05fa3d50a5545a4841c5376e01d6bb0E.png" alt=""></p>
<blockquote>
<p>用于多分类的线性模型<br>将二分类算法推广到多分类算法的常见方法是“一对其余”。对每个类别都学习一个二分类模型，将这个类别与所有其他类别尽量分别开，这样就生成了与类别个数一样多的二分类模型。在测试点上运行所有二分类器来进行预测。在对应类别上分数最高的分类器胜出。将这个类别标签返回作为预测结果。</p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">from sklearn.datasets <span class="keyword">import</span> make_blobs</span><br><span class="line">X,y=make_blobs(random_state=<span class="number">42</span>)</span><br><span class="line">mglearn.discrete_scatter(X[:,<span class="number">0</span>],X[:,<span class="number">1</span>],y)</span><br><span class="line"><span class="built_in">line</span> = np.linspace(<span class="number">-15</span>,<span class="number">15</span>)</span><br><span class="line"><span class="keyword">for</span> coef,intercept,color in zip(linear_svm.coef_,linear_svm.intercept_,[<span class="string">'b'</span>,<span class="string">'r'</span>,<span class="string">'g'</span>]):</span><br><span class="line">    plt.plot(<span class="built_in">line</span>,-(<span class="built_in">line</span> * coef[<span class="number">0</span>]+intercept)/coef[<span class="number">1</span>],c=color)</span><br><span class="line">plt.ylim(<span class="number">-10</span>,<span class="number">15</span>)</span><br><span class="line">plt.xlim(<span class="number">-10</span>,<span class="number">8</span>)</span><br><span class="line">plt.xlabel(<span class="string">"Feature 0"</span>)</span><br><span class="line">plt.ylabel(<span class="string">"Feature 1"</span>)</span><br><span class="line">plt.legend(["Class 0","Class 1","Class 2",'Line class 0','Line class 1','Line class 2'],loc=(1.01,0.3))</span><br></pre></td></tr></table></figure>
<p><img src="https://ae01.alicdn.com/kf/H7f1732d69995409ca8e108894c8d29e1o.png" alt=""></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mglearn.plots.plot_2d_classification(linear_svm,X,<span class="built_in">fill</span>=True,alpha=<span class="number">.7</span>)</span><br><span class="line">mglearn.discrete_scatter(X[:,<span class="number">0</span>],X[:,<span class="number">1</span>],y)</span><br><span class="line"><span class="built_in">line</span> = np.linspace(<span class="number">-15</span>,<span class="number">15</span>)</span><br><span class="line"><span class="keyword">for</span> coef,intercept,color in zip(linear_svm.coef_,linear_svm.intercept_,[<span class="string">'b'</span>,<span class="string">'r'</span>,<span class="string">'g'</span>]):</span><br><span class="line">    plt.plot(<span class="built_in">line</span>,-(<span class="built_in">line</span> * coef[<span class="number">0</span>]+intercept)/coef[<span class="number">1</span>],c=color)</span><br><span class="line">plt.ylim(<span class="number">-10</span>,<span class="number">15</span>)</span><br><span class="line">plt.xlim(<span class="number">-10</span>,<span class="number">8</span>)</span><br><span class="line">plt.xlabel(<span class="string">"Feature 0"</span>)</span><br><span class="line">plt.ylabel(<span class="string">"Feature 1"</span>)</span><br><span class="line">plt.legend(["Class 0","Class 1","Class 2",'Line class 0','Line class 1','Line class 2'],loc=(1.01,0.3))</span><br></pre></td></tr></table></figure>
<p><img src="https://ae01.alicdn.com/kf/Hf19136ef29e948c18e9c87109699b418V.png" alt=""></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
